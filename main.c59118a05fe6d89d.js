"use strict"; (self.webpackChunkcape_smash = self.webpackChunkcape_smash || []).push([[179], { 644: () => { function ie(t) { return "function" == typeof t } function Si(t) { const n = t(r => { Error.call(r), r.stack = (new Error).stack }); return n.prototype = Object.create(Error.prototype), n.prototype.constructor = n, n } const Ws = Si(t => function (n) { t(this), this.message = n ? `${n.length} errors occurred during unsubscription:\n${n.map((r, i) => `${i + 1}) ${r.toString()}`).join("\n  ")}` : "", this.name = "UnsubscriptionError", this.errors = n }); function Ii(t, e) { if (t) { const n = t.indexOf(e); 0 <= n && t.splice(n, 1) } } class vt { constructor(e) { this.initialTeardown = e, this.closed = !1, this._parentage = null, this._finalizers = null } unsubscribe() { let e; if (!this.closed) { this.closed = !0; const { _parentage: n } = this; if (n) if (this._parentage = null, Array.isArray(n)) for (const s of n) s.remove(this); else n.remove(this); const { initialTeardown: r } = this; if (ie(r)) try { r() } catch (s) { e = s instanceof Ws ? s.errors : [s] } const { _finalizers: i } = this; if (i) { this._finalizers = null; for (const s of i) try { Pf(s) } catch (o) { e = null != e ? e : [], o instanceof Ws ? e = [...e, ...o.errors] : e.push(o) } } if (e) throw new Ws(e) } } add(e) { var n; if (e && e !== this) if (this.closed) Pf(e); else { if (e instanceof vt) { if (e.closed || e._hasParent(this)) return; e._addParent(this) } (this._finalizers = null !== (n = this._finalizers) && void 0 !== n ? n : []).push(e) } } _hasParent(e) { const { _parentage: n } = this; return n === e || Array.isArray(n) && n.includes(e) } _addParent(e) { const { _parentage: n } = this; this._parentage = Array.isArray(n) ? (n.push(e), n) : n ? [n, e] : e } _removeParent(e) { const { _parentage: n } = this; n === e ? this._parentage = null : Array.isArray(n) && Ii(n, e) } remove(e) { const { _finalizers: n } = this; n && Ii(n, e), e instanceof vt && e._removeParent(this) } } vt.EMPTY = (() => { const t = new vt; return t.closed = !0, t })(); const xf = vt.EMPTY; function Ff(t) { return t instanceof vt || t && "closed" in t && ie(t.remove) && ie(t.add) && ie(t.unsubscribe) } function Pf(t) { ie(t) ? t() : t.unsubscribe() } const Jn = { onUnhandledError: null, onStoppedNotification: null, Promise: void 0, useDeprecatedSynchronousErrorHandling: !1, useDeprecatedNextContext: !1 }, Ks = { setTimeout(t, e, ...n) { const { delegate: r } = Ks; return (null == r ? void 0 : r.setTimeout) ? r.setTimeout(t, e, ...n) : setTimeout(t, e, ...n) }, clearTimeout(t) { const { delegate: e } = Ks; return ((null == e ? void 0 : e.clearTimeout) || clearTimeout)(t) }, delegate: void 0 }; function kf(t) { Ks.setTimeout(() => { const { onUnhandledError: e } = Jn; if (!e) throw t; e(t) }) } function Lf() { } const HE = sl("C", void 0, void 0); function sl(t, e, n) { return { kind: t, value: e, error: n } } let Xn = null; function Qs(t) { if (Jn.useDeprecatedSynchronousErrorHandling) { const e = !Xn; if (e && (Xn = { errorThrown: !1, error: null }), t(), e) { const { errorThrown: n, error: r } = Xn; if (Xn = null, n) throw r } } else t() } class ol extends vt { constructor(e) { super(), this.isStopped = !1, e ? (this.destination = e, Ff(e) && e.add(this)) : this.destination = QE } static create(e, n, r) { return new Ai(e, n, r) } next(e) { this.isStopped ? ll(function zE(t) { return sl("N", t, void 0) }(e), this) : this._next(e) } error(e) { this.isStopped ? ll(function $E(t) { return sl("E", void 0, t) }(e), this) : (this.isStopped = !0, this._error(e)) } complete() { this.isStopped ? ll(HE, this) : (this.isStopped = !0, this._complete()) } unsubscribe() { this.closed || (this.isStopped = !0, super.unsubscribe(), this.destination = null) } _next(e) { this.destination.next(e) } _error(e) { try { this.destination.error(e) } finally { this.unsubscribe() } } _complete() { try { this.destination.complete() } finally { this.unsubscribe() } } } const GE = Function.prototype.bind; function al(t, e) { return GE.call(t, e) } class WE { constructor(e) { this.partialObserver = e } next(e) { const { partialObserver: n } = this; if (n.next) try { n.next(e) } catch (r) { Zs(r) } } error(e) { const { partialObserver: n } = this; if (n.error) try { n.error(e) } catch (r) { Zs(r) } else Zs(e) } complete() { const { partialObserver: e } = this; if (e.complete) try { e.complete() } catch (n) { Zs(n) } } } class Ai extends ol { constructor(e, n, r) { let i; if (super(), ie(e) || !e) i = { next: null != e ? e : void 0, error: null != n ? n : void 0, complete: null != r ? r : void 0 }; else { let s; this && Jn.useDeprecatedNextContext ? (s = Object.create(e), s.unsubscribe = () => this.unsubscribe(), i = { next: e.next && al(e.next, s), error: e.error && al(e.error, s), complete: e.complete && al(e.complete, s) }) : i = e } this.destination = new WE(i) } } function Zs(t) { Jn.useDeprecatedSynchronousErrorHandling ? function qE(t) { Jn.useDeprecatedSynchronousErrorHandling && Xn && (Xn.errorThrown = !0, Xn.error = t) }(t) : kf(t) } function ll(t, e) { const { onStoppedNotification: n } = Jn; n && Ks.setTimeout(() => n(t, e)) } const QE = { closed: !0, next: Lf, error: function KE(t) { throw t }, complete: Lf }, ul = "function" == typeof Symbol && Symbol.observable || "@@observable"; function er(t) { return t } let ye = (() => { class t { constructor(n) { n && (this._subscribe = n) } lift(n) { const r = new t; return r.source = this, r.operator = n, r } subscribe(n, r, i) { const s = function YE(t) { return t && t instanceof ol || function ZE(t) { return t && ie(t.next) && ie(t.error) && ie(t.complete) }(t) && Ff(t) }(n) ? n : new Ai(n, r, i); return Qs(() => { const { operator: o, source: a } = this; s.add(o ? o.call(s, a) : a ? this._subscribe(s) : this._trySubscribe(s)) }), s } _trySubscribe(n) { try { return this._subscribe(n) } catch (r) { n.error(r) } } forEach(n, r) { return new (r = Bf(r))((i, s) => { const o = new Ai({ next: a => { try { n(a) } catch (l) { s(l), o.unsubscribe() } }, error: s, complete: i }); this.subscribe(o) }) } _subscribe(n) { var r; return null === (r = this.source) || void 0 === r ? void 0 : r.subscribe(n) } [ul]() { return this } pipe(...n) { return function jf(t) { return 0 === t.length ? er : 1 === t.length ? t[0] : function (n) { return t.reduce((r, i) => i(r), n) } }(n)(this) } toPromise(n) { return new (n = Bf(n))((r, i) => { let s; this.subscribe(o => s = o, o => i(o), () => r(s)) }) } } return t.create = e => new t(e), t })(); function Bf(t) { var e; return null !== (e = null != t ? t : Jn.Promise) && void 0 !== e ? e : Promise } const JE = Si(t => function () { t(this), this.name = "ObjectUnsubscribedError", this.message = "object unsubscribed" }); let ln = (() => { class t extends ye { constructor() { super(), this.closed = !1, this.currentObservers = null, this.observers = [], this.isStopped = !1, this.hasError = !1, this.thrownError = null } lift(n) { const r = new Vf(this, this); return r.operator = n, r } _throwIfClosed() { if (this.closed) throw new JE } next(n) { Qs(() => { if (this._throwIfClosed(), !this.isStopped) { this.currentObservers || (this.currentObservers = Array.from(this.observers)); for (const r of this.currentObservers) r.next(n) } }) } error(n) { Qs(() => { if (this._throwIfClosed(), !this.isStopped) { this.hasError = this.isStopped = !0, this.thrownError = n; const { observers: r } = this; for (; r.length;)r.shift().error(n) } }) } complete() { Qs(() => { if (this._throwIfClosed(), !this.isStopped) { this.isStopped = !0; const { observers: n } = this; for (; n.length;)n.shift().complete() } }) } unsubscribe() { this.isStopped = this.closed = !0, this.observers = this.currentObservers = null } get observed() { var n; return (null === (n = this.observers) || void 0 === n ? void 0 : n.length) > 0 } _trySubscribe(n) { return this._throwIfClosed(), super._trySubscribe(n) } _subscribe(n) { return this._throwIfClosed(), this._checkFinalizedStatuses(n), this._innerSubscribe(n) } _innerSubscribe(n) { const { hasError: r, isStopped: i, observers: s } = this; return r || i ? xf : (this.currentObservers = null, s.push(n), new vt(() => { this.currentObservers = null, Ii(s, n) })) } _checkFinalizedStatuses(n) { const { hasError: r, thrownError: i, isStopped: s } = this; r ? n.error(i) : s && n.complete() } asObservable() { const n = new ye; return n.source = this, n } } return t.create = (e, n) => new Vf(e, n), t })(); class Vf extends ln { constructor(e, n) { super(), this.destination = e, this.source = n } next(e) { var n, r; null === (r = null === (n = this.destination) || void 0 === n ? void 0 : n.next) || void 0 === r || r.call(n, e) } error(e) { var n, r; null === (r = null === (n = this.destination) || void 0 === n ? void 0 : n.error) || void 0 === r || r.call(n, e) } complete() { var e, n; null === (n = null === (e = this.destination) || void 0 === e ? void 0 : e.complete) || void 0 === n || n.call(e) } _subscribe(e) { var n, r; return null !== (r = null === (n = this.source) || void 0 === n ? void 0 : n.subscribe(e)) && void 0 !== r ? r : xf } } function Uf(t) { return ie(null == t ? void 0 : t.lift) } function ke(t) { return e => { if (Uf(e)) return e.lift(function (n) { try { return t(n, this) } catch (r) { this.error(r) } }); throw new TypeError("Unable to lift unknown Observable type") } } function Le(t, e, n, r, i) { return new XE(t, e, n, r, i) } class XE extends ol { constructor(e, n, r, i, s, o) { super(e), this.onFinalize = s, this.shouldUnsubscribe = o, this._next = n ? function (a) { try { n(a) } catch (l) { e.error(l) } } : super._next, this._error = i ? function (a) { try { i(a) } catch (l) { e.error(l) } finally { this.unsubscribe() } } : super._error, this._complete = r ? function () { try { r() } catch (a) { e.error(a) } finally { this.unsubscribe() } } : super._complete } unsubscribe() { var e; if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) { const { closed: n } = this; super.unsubscribe(), !n && (null === (e = this.onFinalize) || void 0 === e || e.call(this)) } } } function J(t, e) { return ke((n, r) => { let i = 0; n.subscribe(Le(r, s => { r.next(t.call(e, s, i++)) })) }) } function In(t) { return this instanceof In ? (this.v = t, this) : new In(t) } function zf(t, e, n) { if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined."); var i, r = n.apply(t, e || []), s = []; return i = {}, o("next"), o("throw"), o("return"), i[Symbol.asyncIterator] = function () { return this }, i; function o(f) { r[f] && (i[f] = function (h) { return new Promise(function (p, g) { s.push([f, h, p, g]) > 1 || a(f, h) }) }) } function a(f, h) { try { !function l(f) { f.value instanceof In ? Promise.resolve(f.value.v).then(u, c) : d(s[0][2], f) }(r[f](h)) } catch (p) { d(s[0][3], p) } } function u(f) { a("next", f) } function c(f) { a("throw", f) } function d(f, h) { f(h), s.shift(), s.length && a(s[0][0], s[0][1]) } } function qf(t) { if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined."); var n, e = t[Symbol.asyncIterator]; return e ? e.call(t) : (t = function hl(t) { var e = "function" == typeof Symbol && Symbol.iterator, n = e && t[e], r = 0; if (n) return n.call(t); if (t && "number" == typeof t.length) return { next: function () { return t && r >= t.length && (t = void 0), { value: t && t[r++], done: !t } } }; throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.") }(t), n = {}, r("next"), r("throw"), r("return"), n[Symbol.asyncIterator] = function () { return this }, n); function r(s) { n[s] = t[s] && function (o) { return new Promise(function (a, l) { !function i(s, o, a, l) { Promise.resolve(l).then(function (u) { s({ value: u, done: a }) }, o) }(a, l, (o = t[s](o)).done, o.value) }) } } } "function" == typeof SuppressedError && SuppressedError; const Gf = t => t && "number" == typeof t.length && "function" != typeof t; function Wf(t) { return ie(null == t ? void 0 : t.then) } function Kf(t) { return ie(t[ul]) } function Qf(t) { return Symbol.asyncIterator && ie(null == t ? void 0 : t[Symbol.asyncIterator]) } function Zf(t) { return new TypeError(`You provided ${null !== t && "object" == typeof t ? "an invalid object" : `'${t}'`} where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`) } const Yf = function EC() { return "function" == typeof Symbol && Symbol.iterator ? Symbol.iterator : "@@iterator" }(); function Jf(t) { return ie(null == t ? void 0 : t[Yf]) } function Xf(t) { return zf(this, arguments, function* () { const n = t.getReader(); try { for (; ;) { const { value: r, done: i } = yield In(n.read()); if (i) return yield In(void 0); yield yield In(r) } } finally { n.releaseLock() } }) } function eh(t) { return ie(null == t ? void 0 : t.getReader) } function Wt(t) { if (t instanceof ye) return t; if (null != t) { if (Kf(t)) return function CC(t) { return new ye(e => { const n = t[ul](); if (ie(n.subscribe)) return n.subscribe(e); throw new TypeError("Provided object does not correctly implement Symbol.observable") }) }(t); if (Gf(t)) return function bC(t) { return new ye(e => { for (let n = 0; n < t.length && !e.closed; n++)e.next(t[n]); e.complete() }) }(t); if (Wf(t)) return function wC(t) { return new ye(e => { t.then(n => { e.closed || (e.next(n), e.complete()) }, n => e.error(n)).then(null, kf) }) }(t); if (Qf(t)) return th(t); if (Jf(t)) return function MC(t) { return new ye(e => { for (const n of t) if (e.next(n), e.closed) return; e.complete() }) }(t); if (eh(t)) return function TC(t) { return th(Xf(t)) }(t) } throw Zf(t) } function th(t) { return new ye(e => { (function SC(t, e) { var n, r, i, s; return function Hf(t, e, n, r) { return new (n || (n = Promise))(function (s, o) { function a(c) { try { u(r.next(c)) } catch (d) { o(d) } } function l(c) { try { u(r.throw(c)) } catch (d) { o(d) } } function u(c) { c.done ? s(c.value) : function i(s) { return s instanceof n ? s : new n(function (o) { o(s) }) }(c.value).then(a, l) } u((r = r.apply(t, e || [])).next()) }) }(this, void 0, void 0, function* () { try { for (n = qf(t); !(r = yield n.next()).done;)if (e.next(r.value), e.closed) return } catch (o) { i = { error: o } } finally { try { r && !r.done && (s = n.return) && (yield s.call(n)) } finally { if (i) throw i.error } } e.complete() }) })(t, e).catch(n => e.error(n)) }) } function un(t, e, n, r = 0, i = !1) { const s = e.schedule(function () { n(), i ? t.add(this.schedule(null, r)) : this.unsubscribe() }, r); if (t.add(s), !i) return s } function Ie(t, e, n = 1 / 0) { return ie(e) ? Ie((r, i) => J((s, o) => e(r, s, i, o))(Wt(t(r, i))), n) : ("number" == typeof e && (n = e), ke((r, i) => function IC(t, e, n, r, i, s, o, a) { const l = []; let u = 0, c = 0, d = !1; const f = () => { d && !l.length && !u && e.complete() }, h = g => u < r ? p(g) : l.push(g), p = g => { s && e.next(g), u++; let y = !1; Wt(n(g, c++)).subscribe(Le(e, _ => { null == i || i(_), s ? h(_) : e.next(_) }, () => { y = !0 }, void 0, () => { if (y) try { for (u--; l.length && u < r;) { const _ = l.shift(); o ? un(e, o, () => p(_)) : p(_) } f() } catch (_) { e.error(_) } })) }; return t.subscribe(Le(e, h, () => { d = !0, f() })), () => { null == a || a() } }(r, i, t, n))) } function Ri(t = 1 / 0) { return Ie(er, t) } const cn = new ye(t => t.complete()); function pl(t) { return t[t.length - 1] } function Oi(t) { return function RC(t) { return t && ie(t.schedule) }(pl(t)) ? t.pop() : void 0 } function nh(t, e = 0) { return ke((n, r) => { n.subscribe(Le(r, i => un(r, t, () => r.next(i), e), () => un(r, t, () => r.complete(), e), i => un(r, t, () => r.error(i), e))) }) } function rh(t, e = 0) { return ke((n, r) => { r.add(t.schedule(() => n.subscribe(r), e)) }) } function ih(t, e) { if (!t) throw new Error("Iterable cannot be null"); return new ye(n => { un(n, e, () => { const r = t[Symbol.asyncIterator](); un(n, e, () => { r.next().then(i => { i.done ? n.complete() : n.next(i.value) }) }, 0, !0) }) }) } function Ue(t, e) { return e ? function jC(t, e) { if (null != t) { if (Kf(t)) return function xC(t, e) { return Wt(t).pipe(rh(e), nh(e)) }(t, e); if (Gf(t)) return function PC(t, e) { return new ye(n => { let r = 0; return e.schedule(function () { r === t.length ? n.complete() : (n.next(t[r++]), n.closed || this.schedule()) }) }) }(t, e); if (Wf(t)) return function FC(t, e) { return Wt(t).pipe(rh(e), nh(e)) }(t, e); if (Qf(t)) return ih(t, e); if (Jf(t)) return function kC(t, e) { return new ye(n => { let r; return un(n, e, () => { r = t[Yf](), un(n, e, () => { let i, s; try { ({ value: i, done: s } = r.next()) } catch (o) { return void n.error(o) } s ? n.complete() : n.next(i) }, 0, !0) }), () => ie(null == r ? void 0 : r.return) && r.return() }) }(t, e); if (eh(t)) return function LC(t, e) { return ih(Xf(t), e) }(t, e) } throw Zf(t) }(t, e) : Wt(t) } function gl(t, e, ...n) { if (!0 === e) return void t(); if (!1 === e) return; const r = new Ai({ next: () => { r.unsubscribe(), t() } }); return e(...n).subscribe(r) } function ne(t) { for (let e in t) if (t[e] === ne) return e; throw Error("Could not find renamed property on target object.") } function X(t) { if ("string" == typeof t) return t; if (Array.isArray(t)) return "[" + t.map(X).join(", ") + "]"; if (null == t) return "" + t; if (t.overriddenName) return `${t.overriddenName}`; if (t.name) return `${t.name}`; const e = t.toString(); if (null == e) return "" + e; const n = e.indexOf("\n"); return -1 === n ? e : e.substring(0, n) } function yl(t, e) { return null == t || "" === t ? null === e ? "" : e : null == e || "" === e ? t : t + " " + e } const UC = ne({ __forward_ref__: ne }); function _l(t) { return t.__forward_ref__ = _l, t.toString = function () { return X(this()) }, t } function U(t) { return function sh(t) { return "function" == typeof t && t.hasOwnProperty(UC) && t.__forward_ref__ === _l }(t) ? t() : t } class M extends Error { constructor(e, n) { super(function vl(t, e) { return `NG0${Math.abs(t)}${e ? ": " + e : ""}` }(e, n)), this.code = e } } function k(t) { return "string" == typeof t ? t : null == t ? "" : String(t) } function je(t) { return "function" == typeof t ? t.name || t.toString() : "object" == typeof t && null != t && "function" == typeof t.type ? t.type.name || t.type.toString() : k(t) } function Ys(t, e) { const n = e ? ` in ${e}` : ""; throw new M(-201, `No provider for ${je(t)} found${n}`) } function it(t, e) { null == t && function ee(t, e, n, r) { throw new Error(`ASSERTION ERROR: ${t}` + (null == r ? "" : ` [Expected=> ${n} ${r} ${e} <=Actual]`)) }(e, t, null, "!=") } function F(t) { return { token: t.token, providedIn: t.providedIn || null, factory: t.factory, value: void 0 } } function Xe(t) { return { providers: t.providers || [], imports: t.imports || [] } } function Dl(t) { return oh(t, Js) || oh(t, lh) } function oh(t, e) { return t.hasOwnProperty(e) ? t[e] : null } function ah(t) { return t && (t.hasOwnProperty(El) || t.hasOwnProperty(KC)) ? t[El] : null } const Js = ne({ \u0275prov: ne }), El = ne({ \u0275inj: ne }), lh = ne({ ngInjectableDef: ne }), KC = ne({ ngInjectorDef: ne }); var P = (() => ((P = P || {})[P.Default = 0] = "Default", P[P.Host = 1] = "Host", P[P.Self = 2] = "Self", P[P.SkipSelf = 4] = "SkipSelf", P[P.Optional = 8] = "Optional", P))(); let Cl; function An(t) { const e = Cl; return Cl = t, e } function uh(t, e, n) { const r = Dl(t); return r && "root" == r.providedIn ? void 0 === r.value ? r.value = r.factory() : r.value : n & P.Optional ? null : void 0 !== e ? e : void Ys(X(t), "Injector") } function Rn(t) { return { toString: t }.toString() } var Ot = (() => ((Ot = Ot || {})[Ot.OnPush = 0] = "OnPush", Ot[Ot.Default = 1] = "Default", Ot))(), Nt = (() => { return (t = Nt || (Nt = {}))[t.Emulated = 0] = "Emulated", t[t.None = 2] = "None", t[t.ShadowDom = 3] = "ShadowDom", Nt; var t })(); const ZC = "undefined" != typeof globalThis && globalThis, YC = "undefined" != typeof window && window, JC = "undefined" != typeof self && "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope && self, te = ZC || "undefined" != typeof global && global || YC || JC, Sr = {}, re = [], Xs = ne({ \u0275cmp: ne }), bl = ne({ \u0275dir: ne }), wl = ne({ \u0275pipe: ne }), ch = ne({ \u0275mod: ne }), fn = ne({ \u0275fac: ne }), Ni = ne({ __NG_ELEMENT_ID__: ne }); let XC = 0; function xt(t) { return Rn(() => { const n = {}, r = { type: t.type, providersResolver: null, decls: t.decls, vars: t.vars, factory: null, template: t.template || null, consts: t.consts || null, ngContentSelectors: t.ngContentSelectors, hostBindings: t.hostBindings || null, hostVars: t.hostVars || 0, hostAttrs: t.hostAttrs || null, contentQueries: t.contentQueries || null, declaredInputs: n, inputs: null, outputs: null, exportAs: t.exportAs || null, onPush: t.changeDetection === Ot.OnPush, directiveDefs: null, pipeDefs: null, selectors: t.selectors || re, viewQuery: t.viewQuery || null, features: t.features || null, data: t.data || {}, encapsulation: t.encapsulation || Nt.Emulated, id: "c", styles: t.styles || re, _: null, setInput: null, schemas: t.schemas || null, tView: null }, i = t.directives, s = t.features, o = t.pipes; return r.id += XC++, r.inputs = ph(t.inputs, n), r.outputs = ph(t.outputs), s && s.forEach(a => a(r)), r.directiveDefs = i ? () => ("function" == typeof i ? i() : i).map(dh) : null, r.pipeDefs = o ? () => ("function" == typeof o ? o() : o).map(fh) : null, r }) } function dh(t) { return Be(t) || function On(t) { return t[bl] || null }(t) } function fh(t) { return function tr(t) { return t[wl] || null }(t) } const hh = {}; function st(t) { return Rn(() => { const e = { type: t.type, bootstrap: t.bootstrap || re, declarations: t.declarations || re, imports: t.imports || re, exports: t.exports || re, transitiveCompileScopes: null, schemas: t.schemas || null, id: t.id || null }; return null != t.id && (hh[t.id] = t.type), e }) } function ph(t, e) { if (null == t) return Sr; const n = {}; for (const r in t) if (t.hasOwnProperty(r)) { let i = t[r], s = i; Array.isArray(i) && (s = i[1], i = i[0]), n[i] = r, e && (e[i] = s) } return n } const Ae = xt; function Be(t) { return t[Xs] || null } function Dt(t, e) { const n = t[ch] || null; if (!n && !0 === e) throw new Error(`Type ${X(t)} does not have '\u0275mod' property.`); return n } const B = 11; function Kt(t) { return Array.isArray(t) && "object" == typeof t[1] } function Pt(t) { return Array.isArray(t) && !0 === t[1] } function Sl(t) { return 0 != (8 & t.flags) } function ro(t) { return 2 == (2 & t.flags) } function io(t) { return 1 == (1 & t.flags) } function kt(t) { return null !== t.template } function sb(t) { return 0 != (512 & t[2]) } function sr(t, e) { return t.hasOwnProperty(fn) ? t[fn] : null } class lb { constructor(e, n, r) { this.previousValue = e, this.currentValue = n, this.firstChange = r } isFirstChange() { return this.firstChange } } function mh(t) { return t.type.prototype.ngOnChanges && (t.setInput = cb), ub } function ub() { const t = _h(this), e = null == t ? void 0 : t.current; if (e) { const n = t.previous; if (n === Sr) t.previous = e; else for (let r in e) n[r] = e[r]; t.current = null, this.ngOnChanges(e) } } function cb(t, e, n, r) { const i = _h(t) || function db(t, e) { return t[yh] = e }(t, { previous: Sr, current: null }), s = i.current || (i.current = {}), o = i.previous, a = this.declaredInputs[n], l = o[a]; s[a] = new lb(l && l.currentValue, e, o === Sr), t[r] = e } const yh = "__ngSimpleChanges__"; function _h(t) { return t[yh] || null } let Nl; function pe(t) { return !!t.listen } const vh = { createRenderer: (t, e) => function xl() { return void 0 !== Nl ? Nl : "undefined" != typeof document ? document : void 0 }() }; function _e(t) { for (; Array.isArray(t);)t = t[0]; return t } function so(t, e) { return _e(e[t]) } function at(t, e) { return _e(e[t.index]) } function Fl(t, e) { return t.data[e] } function lt(t, e) { const n = e[t]; return Kt(n) ? n : n[0] } function Pl(t) { return 128 == (128 & t[2]) } function Nn(t, e) { return null == e ? null : t[e] } function Eh(t) { t[18] = 0 } function kl(t, e) { t[5] += e; let n = t, r = t[3]; for (; null !== r && (1 === e && 1 === n[5] || -1 === e && 0 === n[5]);)r[5] += e, n = r, r = r[3] } const L = { lFrame: Rh(null), bindingsEnabled: !0 }; function bh() { return L.bindingsEnabled } function v() { return L.lFrame.lView } function Q() { return L.lFrame.tView } function ki(t) { return L.lFrame.contextLView = t, t[8] } function be() { let t = wh(); for (; null !== t && 64 === t.type;)t = t.parent; return t } function wh() { return L.lFrame.currentTNode } function Qt(t, e) { const n = L.lFrame; n.currentTNode = t, n.isParent = e } function Ll() { return L.lFrame.isParent } function jl() { L.lFrame.isParent = !1 } function xr() { return L.lFrame.bindingIndex++ } function Ib(t, e) { const n = L.lFrame; n.bindingIndex = n.bindingRootIndex = t, Bl(e) } function Bl(t) { L.lFrame.currentDirectiveIndex = t } function Ul(t) { L.lFrame.currentQueryIndex = t } function Rb(t) { const e = t[1]; return 2 === e.type ? e.declTNode : 1 === e.type ? t[6] : null } function Ih(t, e, n) { if (n & P.SkipSelf) { let i = e, s = t; for (; !(i = i.parent, null !== i || n & P.Host || (i = Rb(s), null === i || (s = s[15], 10 & i.type)));); if (null === i) return !1; e = i, t = s } const r = L.lFrame = Ah(); return r.currentTNode = e, r.lView = t, !0 } function ao(t) { const e = Ah(), n = t[1]; L.lFrame = e, e.currentTNode = n.firstChild, e.lView = t, e.tView = n, e.contextLView = t, e.bindingIndex = n.bindingStartIndex, e.inI18n = !1 } function Ah() { const t = L.lFrame, e = null === t ? null : t.child; return null === e ? Rh(t) : e } function Rh(t) { const e = { currentTNode: null, isParent: !0, lView: null, tView: null, selectedIndex: -1, contextLView: null, elementDepthCount: 0, currentNamespace: null, currentDirectiveIndex: -1, bindingRootIndex: -1, bindingIndex: -1, currentQueryIndex: 0, parent: t, child: null, inI18n: !1 }; return null !== t && (t.child = e), e } function Oh() { const t = L.lFrame; return L.lFrame = t.parent, t.currentTNode = null, t.lView = null, t } const Nh = Oh; function lo() { const t = Oh(); t.isParent = !0, t.tView = null, t.selectedIndex = -1, t.contextLView = null, t.elementDepthCount = 0, t.currentDirectiveIndex = -1, t.currentNamespace = null, t.bindingRootIndex = -1, t.bindingIndex = -1, t.currentQueryIndex = 0 } function We() { return L.lFrame.selectedIndex } function xn(t) { L.lFrame.selectedIndex = t } function ue() { const t = L.lFrame; return Fl(t.tView, t.selectedIndex) } function uo(t, e) { for (let n = e.directiveStart, r = e.directiveEnd; n < r; n++) { const s = t.data[n].type.prototype, { ngAfterContentInit: o, ngAfterContentChecked: a, ngAfterViewInit: l, ngAfterViewChecked: u, ngOnDestroy: c } = s; o && (t.contentHooks || (t.contentHooks = [])).push(-n, o), a && ((t.contentHooks || (t.contentHooks = [])).push(n, a), (t.contentCheckHooks || (t.contentCheckHooks = [])).push(n, a)), l && (t.viewHooks || (t.viewHooks = [])).push(-n, l), u && ((t.viewHooks || (t.viewHooks = [])).push(n, u), (t.viewCheckHooks || (t.viewCheckHooks = [])).push(n, u)), null != c && (t.destroyHooks || (t.destroyHooks = [])).push(n, c) } } function co(t, e, n) { xh(t, e, 3, n) } function fo(t, e, n, r) { (3 & t[2]) === n && xh(t, e, n, r) } function Hl(t, e) { let n = t[2]; (3 & n) === e && (n &= 2047, n += 1, t[2] = n) } function xh(t, e, n, r) { const s = null != r ? r : -1, o = e.length - 1; let a = 0; for (let l = void 0 !== r ? 65535 & t[18] : 0; l < o; l++)if ("number" == typeof e[l + 1]) { if (a = e[l], null != r && a >= r) break } else e[l] < 0 && (t[18] += 65536), (a < s || -1 == s) && (Bb(t, n, e, l), t[18] = (4294901760 & t[18]) + l + 2), l++ } function Bb(t, e, n, r) { const i = n[r] < 0, s = n[r + 1], a = t[i ? -n[r] : n[r]]; if (i) { if (t[2] >> 11 < t[18] >> 16 && (3 & t[2]) === e) { t[2] += 2048; try { s.call(a) } finally { } } } else try { s.call(a) } finally { } } class ji { constructor(e, n, r) { this.factory = e, this.resolving = !1, this.canSeeViewProviders = n, this.injectImpl = r } } function ho(t, e, n) { const r = pe(t); let i = 0; for (; i < n.length;) { const s = n[i]; if ("number" == typeof s) { if (0 !== s) break; i++; const o = n[i++], a = n[i++], l = n[i++]; r ? t.setAttribute(e, a, l, o) : e.setAttributeNS(o, a, l) } else { const o = s, a = n[++i]; zl(o) ? r && t.setProperty(e, o, a) : r ? t.setAttribute(e, o, a) : e.setAttribute(o, a), i++ } } return i } function Fh(t) { return 3 === t || 4 === t || 6 === t } function zl(t) { return 64 === t.charCodeAt(0) } function po(t, e) { if (null !== e && 0 !== e.length) if (null === t || 0 === t.length) t = e.slice(); else { let n = -1; for (let r = 0; r < e.length; r++) { const i = e[r]; "number" == typeof i ? n = i : 0 === n || Ph(t, n, i, null, -1 === n || 2 === n ? e[++r] : null) } } return t } function Ph(t, e, n, r, i) { let s = 0, o = t.length; if (-1 === e) o = -1; else for (; s < t.length;) { const a = t[s++]; if ("number" == typeof a) { if (a === e) { o = -1; break } if (a > e) { o = s - 1; break } } } for (; s < t.length;) { const a = t[s]; if ("number" == typeof a) break; if (a === n) { if (null === r) return void (null !== i && (t[s + 1] = i)); if (r === t[s + 1]) return void (t[s + 2] = i) } s++, null !== r && s++, null !== i && s++ } -1 !== o && (t.splice(o, 0, e), s = o + 1), t.splice(s++, 0, n), null !== r && t.splice(s++, 0, r), null !== i && t.splice(s++, 0, i) } function kh(t) { return -1 !== t } function Fr(t) { return 32767 & t } function Pr(t, e) { let n = function zb(t) { return t >> 16 }(t), r = e; for (; n > 0;)r = r[15], n--; return r } let ql = !0; function go(t) { const e = ql; return ql = t, e } let qb = 0; function Vi(t, e) { const n = Wl(t, e); if (-1 !== n) return n; const r = e[1]; r.firstCreatePass && (t.injectorIndex = e.length, Gl(r.data, t), Gl(e, null), Gl(r.blueprint, null)); const i = mo(t, e), s = t.injectorIndex; if (kh(i)) { const o = Fr(i), a = Pr(i, e), l = a[1].data; for (let u = 0; u < 8; u++)e[s + u] = a[o + u] | l[o + u] } return e[s + 8] = i, s } function Gl(t, e) { t.push(0, 0, 0, 0, 0, 0, 0, 0, e) } function Wl(t, e) { return -1 === t.injectorIndex || t.parent && t.parent.injectorIndex === t.injectorIndex || null === e[t.injectorIndex + 8] ? -1 : t.injectorIndex } function mo(t, e) { if (t.parent && -1 !== t.parent.injectorIndex) return t.parent.injectorIndex; let n = 0, r = null, i = e; for (; null !== i;) { const s = i[1], o = s.type; if (r = 2 === o ? s.declTNode : 1 === o ? i[6] : null, null === r) return -1; if (n++, i = i[15], -1 !== r.injectorIndex) return r.injectorIndex | n << 16 } return -1 } function yo(t, e, n) { !function Gb(t, e, n) { let r; "string" == typeof n ? r = n.charCodeAt(0) || 0 : n.hasOwnProperty(Ni) && (r = n[Ni]), null == r && (r = n[Ni] = qb++); const i = 255 & r; e.data[t + (i >> 5)] |= 1 << i }(t, e, n) } function Bh(t, e, n) { if (n & P.Optional) return t; Ys(e, "NodeInjector") } function Vh(t, e, n, r) { if (n & P.Optional && void 0 === r && (r = null), 0 == (n & (P.Self | P.Host))) { const i = t[9], s = An(void 0); try { return i ? i.get(e, r, n & P.Optional) : uh(e, r, n & P.Optional) } finally { An(s) } } return Bh(r, e, n) } function Uh(t, e, n, r = P.Default, i) { if (null !== t) { const s = function Zb(t) { if ("string" == typeof t) return t.charCodeAt(0) || 0; const e = t.hasOwnProperty(Ni) ? t[Ni] : void 0; return "number" == typeof e ? e >= 0 ? 255 & e : Kb : e }(n); if ("function" == typeof s) { if (!Ih(e, t, r)) return r & P.Host ? Bh(i, n, r) : Vh(e, n, r, i); try { const o = s(r); if (null != o || r & P.Optional) return o; Ys(n) } finally { Nh() } } else if ("number" == typeof s) { let o = null, a = Wl(t, e), l = -1, u = r & P.Host ? e[16][6] : null; for ((-1 === a || r & P.SkipSelf) && (l = -1 === a ? mo(t, e) : e[a + 8], -1 !== l && zh(r, !1) ? (o = e[1], a = Fr(l), e = Pr(l, e)) : a = -1); -1 !== a;) { const c = e[1]; if ($h(s, a, c.data)) { const d = Qb(a, e, n, o, r, u); if (d !== Hh) return d } l = e[a + 8], -1 !== l && zh(r, e[1].data[a + 8] === u) && $h(s, a, e) ? (o = c, a = Fr(l), e = Pr(l, e)) : a = -1 } } } return Vh(e, n, r, i) } const Hh = {}; function Kb() { return new kr(be(), v()) } function Qb(t, e, n, r, i, s) { const o = e[1], a = o.data[t + 8], c = function _o(t, e, n, r, i) { const s = t.providerIndexes, o = e.data, a = 1048575 & s, l = t.directiveStart, c = s >> 20, f = i ? a + c : t.directiveEnd; for (let h = r ? a : a + c; h < f; h++) { const p = o[h]; if (h < l && n === p || h >= l && p.type === n) return h } if (i) { const h = o[l]; if (h && kt(h) && h.type === n) return l } return null }(a, o, n, null == r ? ro(a) && ql : r != o && 0 != (3 & a.type), i & P.Host && s === a); return null !== c ? Ui(e, o, c, a) : Hh } function Ui(t, e, n, r) { let i = t[n]; const s = e.data; if (function Vb(t) { return t instanceof ji }(i)) { const o = i; o.resolving && function HC(t, e) { const n = e ? `. Dependency path: ${e.join(" > ")} > ${t}` : ""; throw new M(-200, `Circular dependency in DI detected for ${t}${n}`) }(je(s[n])); const a = go(o.canSeeViewProviders); o.resolving = !0; const l = o.injectImpl ? An(o.injectImpl) : null; Ih(t, r, P.Default); try { i = t[n] = o.factory(void 0, s, t, r), e.firstCreatePass && n >= r.directiveStart && function jb(t, e, n) { const { ngOnChanges: r, ngOnInit: i, ngDoCheck: s } = e.type.prototype; if (r) { const o = mh(e); (n.preOrderHooks || (n.preOrderHooks = [])).push(t, o), (n.preOrderCheckHooks || (n.preOrderCheckHooks = [])).push(t, o) } i && (n.preOrderHooks || (n.preOrderHooks = [])).push(0 - t, i), s && ((n.preOrderHooks || (n.preOrderHooks = [])).push(t, s), (n.preOrderCheckHooks || (n.preOrderCheckHooks = [])).push(t, s)) }(n, s[n], e) } finally { null !== l && An(l), go(a), o.resolving = !1, Nh() } } return i } function $h(t, e, n) { return !!(n[e + (t >> 5)] & 1 << t) } function zh(t, e) { return !(t & P.Self || t & P.Host && e) } class kr { constructor(e, n) { this._tNode = e, this._lView = n } get(e, n, r) { return Uh(this._tNode, this._lView, e, r, n) } } const jr = "__parameters__"; function Vr(t, e, n) { return Rn(() => { const r = function Ql(t) { return function (...n) { if (t) { const r = t(...n); for (const i in r) this[i] = r[i] } } }(e); function i(...s) { if (this instanceof i) return r.apply(this, s), this; const o = new i(...s); return a.annotation = o, a; function a(l, u, c) { const d = l.hasOwnProperty(jr) ? l[jr] : Object.defineProperty(l, jr, { value: [] })[jr]; for (; d.length <= c;)d.push(null); return (d[c] = d[c] || []).push(o), l } } return n && (i.prototype = Object.create(n.prototype)), i.prototype.ngMetadataName = t, i.annotationCls = i, i }) } class O { constructor(e, n) { this._desc = e, this.ngMetadataName = "InjectionToken", this.\u0275prov = void 0, "number" == typeof n ? this.__NG_ELEMENT_ID__ = n : void 0 !== n && (this.\u0275prov = F({ token: this, providedIn: n.providedIn || "root", factory: n.factory })) } toString() { return `InjectionToken ${this._desc}` } } const Xb = new O("AnalyzeForEntryComponents"); function Zt(t, e) { t.forEach(n => Array.isArray(n) ? Zt(n, e) : e(n)) } function Gh(t, e, n) { e >= t.length ? t.push(n) : t.splice(e, 0, n) } function vo(t, e) { return e >= t.length - 1 ? t.pop() : t.splice(e, 1)[0] } function qi(t, e) { const n = []; for (let r = 0; r < t; r++)n.push(e); return n } function ut(t, e, n) { let r = Ur(t, e); return r >= 0 ? t[1 | r] = n : (r = ~r, function nw(t, e, n, r) { let i = t.length; if (i == e) t.push(n, r); else if (1 === i) t.push(r, t[0]), t[0] = n; else { for (i--, t.push(t[i - 1], t[i]); i > e;)t[i] = t[i - 2], i--; t[e] = n, t[e + 1] = r } }(t, r, e, n)), r } function Yl(t, e) { const n = Ur(t, e); if (n >= 0) return t[1 | n] } function Ur(t, e) { return function Qh(t, e, n) { let r = 0, i = t.length >> n; for (; i !== r;) { const s = r + (i - r >> 1), o = t[s << n]; if (e === o) return s << n; o > e ? i = s : r = s + 1 } return ~(i << n) }(t, e, 1) } const Gi = {}, Xl = "__NG_DI_FLAG__", Eo = "ngTempTokenPath", uw = /\n/gm, Yh = "__source", dw = ne({ provide: String, useValue: ne }); let Wi; function Jh(t) { const e = Wi; return Wi = t, e } function fw(t, e = P.Default) { if (void 0 === Wi) throw new M(203, ""); return null === Wi ? uh(t, void 0, e) : Wi.get(t, e & P.Optional ? null : void 0, e) } function C(t, e = P.Default) { return (function QC() { return Cl }() || fw)(U(t), e) } const eu = C; function tu(t) { const e = []; for (let n = 0; n < t.length; n++) { const r = U(t[n]); if (Array.isArray(r)) { if (0 === r.length) throw new M(900, ""); let i, s = P.Default; for (let o = 0; o < r.length; o++) { const a = r[o], l = hw(a); "number" == typeof l ? -1 === l ? i = a.token : s |= l : i = a } e.push(C(i, s)) } else e.push(C(r)) } return e } function Ki(t, e) { return t[Xl] = e, t.prototype[Xl] = e, t } function hw(t) { return t[Xl] } const Co = Ki(Vr("Inject", t => ({ token: t })), -1), Pn = Ki(Vr("Optional"), 8), Qi = Ki(Vr("SkipSelf"), 4); var ct = (() => ((ct = ct || {})[ct.Important = 1] = "Important", ct[ct.DashCase = 2] = "DashCase", ct))(); const op = "__ngContext__"; function $e(t, e) { t[op] = e } function iu(t) { const e = function Yi(t) { return t[op] || null }(t); return e ? Array.isArray(e) ? e : e.lView : null } function ou(t, e) { return undefined(t, e) } function Ji(t) { const e = t[3]; return Pt(e) ? e[3] : e } function au(t) { return hp(t[13]) } function lu(t) { return hp(t[4]) } function hp(t) { for (; null !== t && !Pt(t);)t = t[4]; return t } function $r(t, e, n, r, i) { if (null != r) { let s, o = !1; Pt(r) ? s = r : Kt(r) && (o = !0, r = r[0]); const a = _e(r); 0 === t && null !== n ? null == i ? vp(e, n, a) : ar(e, n, a, i || null, !0) : 1 === t && null !== n ? ar(e, n, a, i || null, !0) : 2 === t ? function gu(t, e, n) { const r = wo(t, e); r && function zw(t, e, n, r) { pe(t) ? t.removeChild(e, n, r) : e.removeChild(n) }(t, r, e, n) }(e, a, o) : 3 === t && e.destroyNode(a), null != s && function Ww(t, e, n, r, i) { const s = n[7]; s !== _e(n) && $r(e, t, r, s, i); for (let a = 10; a < n.length; a++) { const l = n[a]; Xi(l[1], l, t, e, r, s) } }(e, t, s, n, i) } } function cu(t, e, n) { if (pe(t)) return t.createElement(e, n); { const r = null !== n ? function gb(t) { const e = t.toLowerCase(); return "svg" === e ? "http://www.w3.org/2000/svg" : "math" === e ? "http://www.w3.org/1998/MathML/" : null }(n) : null; return null === r ? t.createElement(e) : t.createElementNS(r, e) } } function gp(t, e) { const n = t[9], r = n.indexOf(e), i = e[3]; 1024 & e[2] && (e[2] &= -1025, kl(i, -1)), n.splice(r, 1) } function du(t, e) { if (t.length <= 10) return; const n = 10 + e, r = t[n]; if (r) { const i = r[17]; null !== i && i !== t && gp(i, r), e > 0 && (t[n - 1][4] = r[4]); const s = vo(t, 10 + e); !function kw(t, e) { Xi(t, e, e[B], 2, null, null), e[0] = null, e[6] = null }(r[1], r); const o = s[19]; null !== o && o.detachView(s[1]), r[3] = null, r[4] = null, r[2] &= -129 } return r } function mp(t, e) { if (!(256 & e[2])) { const n = e[B]; pe(n) && n.destroyNode && Xi(t, e, n, 3, null, null), function Bw(t) { let e = t[13]; if (!e) return fu(t[1], t); for (; e;) { let n = null; if (Kt(e)) n = e[13]; else { const r = e[10]; r && (n = r) } if (!n) { for (; e && !e[4] && e !== t;)Kt(e) && fu(e[1], e), e = e[3]; null === e && (e = t), Kt(e) && fu(e[1], e), n = e && e[4] } e = n } }(e) } } function fu(t, e) { if (!(256 & e[2])) { e[2] &= -129, e[2] |= 256, function $w(t, e) { let n; if (null != t && null != (n = t.destroyHooks)) for (let r = 0; r < n.length; r += 2) { const i = e[n[r]]; if (!(i instanceof ji)) { const s = n[r + 1]; if (Array.isArray(s)) for (let o = 0; o < s.length; o += 2) { const a = i[s[o]], l = s[o + 1]; try { l.call(a) } finally { } } else try { s.call(i) } finally { } } } }(t, e), function Hw(t, e) { const n = t.cleanup, r = e[7]; let i = -1; if (null !== n) for (let s = 0; s < n.length - 1; s += 2)if ("string" == typeof n[s]) { const o = n[s + 1], a = "function" == typeof o ? o(e) : _e(e[o]), l = r[i = n[s + 2]], u = n[s + 3]; "boolean" == typeof u ? a.removeEventListener(n[s], l, u) : u >= 0 ? r[i = u]() : r[i = -u].unsubscribe(), s += 2 } else { const o = r[i = n[s + 1]]; n[s].call(o) } if (null !== r) { for (let s = i + 1; s < r.length; s++)r[s](); e[7] = null } }(t, e), 1 === e[1].type && pe(e[B]) && e[B].destroy(); const n = e[17]; if (null !== n && Pt(e[3])) { n !== e[3] && gp(n, e); const r = e[19]; null !== r && r.detachView(t) } } } function yp(t, e, n) { return function _p(t, e, n) { let r = e; for (; null !== r && 40 & r.type;)r = (e = r).parent; if (null === r) return n[0]; if (2 & r.flags) { const i = t.data[r.directiveStart].encapsulation; if (i === Nt.None || i === Nt.Emulated) return null } return at(r, n) }(t, e.parent, n) } function ar(t, e, n, r, i) { pe(t) ? t.insertBefore(e, n, r, i) : e.insertBefore(n, r, i) } function vp(t, e, n) { pe(t) ? t.appendChild(e, n) : e.appendChild(n) } function Dp(t, e, n, r, i) { null !== r ? ar(t, e, n, r, i) : vp(t, e, n) } function wo(t, e) { return pe(t) ? t.parentNode(e) : e.parentNode } function Ep(t, e, n) { return bp(t, e, n) } let bp = function Cp(t, e, n) { return 40 & t.type ? at(t, n) : null }; function Mo(t, e, n, r) { const i = yp(t, r, e), s = e[B], a = Ep(r.parent || e[6], r, e); if (null != i) if (Array.isArray(n)) for (let l = 0; l < n.length; l++)Dp(s, i, n[l], a, !1); else Dp(s, i, n, a, !1) } function To(t, e) { if (null !== e) { const n = e.type; if (3 & n) return at(e, t); if (4 & n) return pu(-1, t[e.index]); if (8 & n) { const r = e.child; if (null !== r) return To(t, r); { const i = t[e.index]; return Pt(i) ? pu(-1, i) : _e(i) } } if (32 & n) return ou(e, t)() || _e(t[e.index]); { const r = Mp(t, e); return null !== r ? Array.isArray(r) ? r[0] : To(Ji(t[16]), r) : To(t, e.next) } } return null } function Mp(t, e) { return null !== e ? t[16][6].projection[e.projection] : null } function pu(t, e) { const n = 10 + t + 1; if (n < e.length) { const r = e[n], i = r[1].firstChild; if (null !== i) return To(r, i) } return e[7] } function mu(t, e, n, r, i, s, o) { for (; null != n;) { const a = r[n.index], l = n.type; if (o && 0 === e && (a && $e(_e(a), r), n.flags |= 4), 64 != (64 & n.flags)) if (8 & l) mu(t, e, n.child, r, i, s, !1), $r(e, t, i, a, s); else if (32 & l) { const u = ou(n, r); let c; for (; c = u();)$r(e, t, i, c, s); $r(e, t, i, a, s) } else 16 & l ? Tp(t, e, r, n, i, s) : $r(e, t, i, a, s); n = o ? n.projectionNext : n.next } } function Xi(t, e, n, r, i, s) { mu(n, r, t.firstChild, e, i, s, !1) } function Tp(t, e, n, r, i, s) { const o = n[16], l = o[6].projection[r.projection]; if (Array.isArray(l)) for (let u = 0; u < l.length; u++)$r(e, t, i, l[u], s); else mu(t, e, l, o[3], i, s, !0) } function Sp(t, e, n) { pe(t) ? t.setAttribute(e, "style", n) : e.style.cssText = n } function yu(t, e, n) { pe(t) ? "" === n ? t.removeAttribute(e, "class") : t.setAttribute(e, "class", n) : e.className = n } class Op { constructor(e) { this.changingThisBreaksApplicationSecurity = e } toString() { return `SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see https://g.co/ng/security#xss)` } } function kn(t) { return t instanceof Op ? t.changingThisBreaksApplicationSecurity : t } const l0 = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^&:/?#]*(?:[/?#]|$))/gi, u0 = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+\/]+=*$/i; var ve = (() => ((ve = ve || {})[ve.NONE = 0] = "NONE", ve[ve.HTML = 1] = "HTML", ve[ve.STYLE = 2] = "STYLE", ve[ve.SCRIPT = 3] = "SCRIPT", ve[ve.URL = 4] = "URL", ve[ve.RESOURCE_URL = 5] = "RESOURCE_URL", ve))(); function Oo(t) { const e = function ns() { const t = v(); return t && t[12] }(); return e ? e.sanitize(ve.URL, t) || "" : function es(t, e) { const n = function r0(t) { return t instanceof Op && t.getTypeName() || null }(t); if (null != n && n !== e) { if ("ResourceURL" === n && "URL" === e) return !0; throw new Error(`Required a safe ${e}, got a ${n} (see https://g.co/ng/security#xss)`) } return n === e }(t, "URL") ? kn(t) : function Ao(t) { return (t = String(t)).match(l0) || t.match(u0) ? t : "unsafe:" + t }(k(t)) } function Mu(t) { return t.ngOriginalError } function T0(t, ...e) { t.error(...e) } class rs { constructor() { this._console = console } handleError(e) { const n = this._findOriginalError(e), r = function M0(t) { return t && t.ngErrorLogger || T0 }(e); r(this._console, "ERROR", e), n && r(this._console, "ORIGINAL ERROR", n) } _findOriginalError(e) { let n = e && Mu(e); for (; n && Mu(n);)n = Mu(n); return n || null } } const x0 = (() => ("undefined" != typeof requestAnimationFrame && requestAnimationFrame || setTimeout).bind(te))(); function Jt(t) { return t instanceof Function ? t() : t } function Up(t, e, n) { let r = t.length; for (; ;) { const i = t.indexOf(e, n); if (-1 === i) return i; if (0 === i || t.charCodeAt(i - 1) <= 32) { const s = e.length; if (i + s === r || t.charCodeAt(i + s) <= 32) return i } n = i + 1 } } const Hp = "ng-template"; function L0(t, e, n) { let r = 0; for (; r < t.length;) { let i = t[r++]; if (n && "class" === i) { if (i = t[r], -1 !== Up(i.toLowerCase(), e, 0)) return !0 } else if (1 === i) { for (; r < t.length && "string" == typeof (i = t[r++]);)if (i.toLowerCase() === e) return !0; return !1 } } return !1 } function $p(t) { return 4 === t.type && t.value !== Hp } function j0(t, e, n) { return e === (4 !== t.type || n ? t.value : Hp) } function B0(t, e, n) { let r = 4; const i = t.attrs || [], s = function H0(t) { for (let e = 0; e < t.length; e++)if (Fh(t[e])) return e; return t.length }(i); let o = !1; for (let a = 0; a < e.length; a++) { const l = e[a]; if ("number" != typeof l) { if (!o) if (4 & r) { if (r = 2 | 1 & r, "" !== l && !j0(t, l, n) || "" === l && 1 === e.length) { if (Lt(r)) return !1; o = !0 } } else { const u = 8 & r ? l : e[++a]; if (8 & r && null !== t.attrs) { if (!L0(t.attrs, u, n)) { if (Lt(r)) return !1; o = !0 } continue } const d = V0(8 & r ? "class" : l, i, $p(t), n); if (-1 === d) { if (Lt(r)) return !1; o = !0; continue } if ("" !== u) { let f; f = d > s ? "" : i[d + 1].toLowerCase(); const h = 8 & r ? f : null; if (h && -1 !== Up(h, u, 0) || 2 & r && u !== f) { if (Lt(r)) return !1; o = !0 } } } } else { if (!o && !Lt(r) && !Lt(l)) return !1; if (o && Lt(l)) continue; o = !1, r = l | 1 & r } } return Lt(r) || o } function Lt(t) { return 0 == (1 & t) } function V0(t, e, n, r) { if (null === e) return -1; let i = 0; if (r || !n) { let s = !1; for (; i < e.length;) { const o = e[i]; if (o === t) return i; if (3 === o || 6 === o) s = !0; else { if (1 === o || 2 === o) { let a = e[++i]; for (; "string" == typeof a;)a = e[++i]; continue } if (4 === o) break; if (0 === o) { i += 4; continue } } i += s ? 1 : 2 } return -1 } return function $0(t, e) { let n = t.indexOf(4); if (n > -1) for (n++; n < t.length;) { const r = t[n]; if ("number" == typeof r) return -1; if (r === e) return n; n++ } return -1 }(e, t) } function zp(t, e, n = !1) { for (let r = 0; r < e.length; r++)if (B0(t, e[r], n)) return !0; return !1 } function z0(t, e) { e: for (let n = 0; n < e.length; n++) { const r = e[n]; if (t.length === r.length) { for (let i = 0; i < t.length; i++)if (t[i] !== r[i]) continue e; return !0 } } return !1 } function qp(t, e) { return t ? ":not(" + e.trim() + ")" : e } function q0(t) { let e = t[0], n = 1, r = 2, i = "", s = !1; for (; n < t.length;) { let o = t[n]; if ("string" == typeof o) if (2 & r) { const a = t[++n]; i += "[" + o + (a.length > 0 ? '="' + a + '"' : "") + "]" } else 8 & r ? i += "." + o : 4 & r && (i += " " + o); else "" !== i && !Lt(o) && (e += qp(s, i), i = ""), r = o, s = s || !Lt(r); n++ } return "" !== i && (e += qp(s, i)), e } const j = {}; function wt(t) { Gp(Q(), v(), We() + t, !1) } function Gp(t, e, n, r) { if (!r) if (3 == (3 & e[2])) { const s = t.preOrderCheckHooks; null !== s && co(e, s, n) } else { const s = t.preOrderHooks; null !== s && fo(e, s, 0, n) } xn(n) } function No(t, e) { return t << 17 | e << 2 } function jt(t) { return t >> 17 & 32767 } function Tu(t) { return 2 | t } function gn(t) { return (131068 & t) >> 2 } function Su(t, e) { return -131069 & t | e << 2 } function Iu(t) { return 1 | t } function rg(t, e) { const n = t.contentQueries; if (null !== n) for (let r = 0; r < n.length; r += 2) { const i = n[r], s = n[r + 1]; if (-1 !== s) { const o = t.data[s]; Ul(i), o.contentQueries(2, e[s], s) } } } function is(t, e, n, r, i, s, o, a, l, u) { const c = e.blueprint.slice(); return c[0] = i, c[2] = 140 | r, Eh(c), c[3] = c[15] = t, c[8] = n, c[10] = o || t && t[10], c[B] = a || t && t[B], c[12] = l || t && t[12] || null, c[9] = u || t && t[9] || null, c[6] = s, c[16] = 2 == e.type ? t[16] : c, c } function qr(t, e, n, r, i) { let s = t.data[e]; if (null === s) s = function Lu(t, e, n, r, i) { const s = wh(), o = Ll(), l = t.data[e] = function uM(t, e, n, r, i, s) { return { type: n, index: r, insertBeforeIndex: null, injectorIndex: e ? e.injectorIndex : -1, directiveStart: -1, directiveEnd: -1, directiveStylingLast: -1, propertyBindings: null, flags: 0, providerIndexes: 0, value: i, attrs: s, mergedAttrs: null, localNames: null, initialInputs: void 0, inputs: null, outputs: null, tViews: null, next: null, projectionNext: null, child: null, parent: e, projection: null, styles: null, stylesWithoutHost: null, residualStyles: void 0, classes: null, classesWithoutHost: null, residualClasses: void 0, classBindings: 0, styleBindings: 0 } }(0, o ? s : s && s.parent, n, e, r, i); return null === t.firstChild && (t.firstChild = l), null !== s && (o ? null == s.child && null !== l.parent && (s.child = l) : null === s.next && (s.next = l)), l }(t, e, n, r, i), function Sb() { return L.lFrame.inI18n }() && (s.flags |= 64); else if (64 & s.type) { s.type = n, s.value = r, s.attrs = i; const o = function Li() { const t = L.lFrame, e = t.currentTNode; return t.isParent ? e : e.parent }(); s.injectorIndex = null === o ? -1 : o.injectorIndex } return Qt(s, !0), s } function Gr(t, e, n, r) { if (0 === n) return -1; const i = e.length; for (let s = 0; s < n; s++)e.push(r), t.blueprint.push(r), t.data.push(null); return i } function ss(t, e, n) { ao(e); try { const r = t.viewQuery; null !== r && Gu(1, r, n); const i = t.template; null !== i && ig(t, e, i, 1, n), t.firstCreatePass && (t.firstCreatePass = !1), t.staticContentQueries && rg(t, e), t.staticViewQueries && Gu(2, t.viewQuery, n); const s = t.components; null !== s && function oM(t, e) { for (let n = 0; n < e.length; n++)SM(t, e[n]) }(e, s) } catch (r) { throw t.firstCreatePass && (t.incompleteFirstPass = !0, t.firstCreatePass = !1), r } finally { e[2] &= -5, lo() } } function Wr(t, e, n, r) { const i = e[2]; if (256 != (256 & i)) { ao(e); try { Eh(e), function Mh(t) { return L.lFrame.bindingIndex = t }(t.bindingStartIndex), null !== n && ig(t, e, n, 2, r); const o = 3 == (3 & i); if (o) { const u = t.preOrderCheckHooks; null !== u && co(e, u, null) } else { const u = t.preOrderHooks; null !== u && fo(e, u, 0, null), Hl(e, 0) } if (function MM(t) { for (let e = au(t); null !== e; e = lu(e)) { if (!e[2]) continue; const n = e[9]; for (let r = 0; r < n.length; r++) { const i = n[r], s = i[3]; 0 == (1024 & i[2]) && kl(s, 1), i[2] |= 1024 } } }(e), function wM(t) { for (let e = au(t); null !== e; e = lu(e))for (let n = 10; n < e.length; n++) { const r = e[n], i = r[1]; Pl(r) && Wr(i, r, i.template, r[8]) } }(e), null !== t.contentQueries && rg(t, e), o) { const u = t.contentCheckHooks; null !== u && co(e, u) } else { const u = t.contentHooks; null !== u && fo(e, u, 1), Hl(e, 1) } !function iM(t, e) { const n = t.hostBindingOpCodes; if (null !== n) try { for (let r = 0; r < n.length; r++) { const i = n[r]; if (i < 0) xn(~i); else { const s = i, o = n[++r], a = n[++r]; Ib(o, s), a(2, e[s]) } } } finally { xn(-1) } }(t, e); const a = t.components; null !== a && function sM(t, e) { for (let n = 0; n < e.length; n++)TM(t, e[n]) }(e, a); const l = t.viewQuery; if (null !== l && Gu(2, l, r), o) { const u = t.viewCheckHooks; null !== u && co(e, u) } else { const u = t.viewHooks; null !== u && fo(e, u, 2), Hl(e, 2) } !0 === t.firstUpdatePass && (t.firstUpdatePass = !1), e[2] &= -73, 1024 & e[2] && (e[2] &= -1025, kl(e[3], -1)) } finally { lo() } } } function aM(t, e, n, r) { const i = e[10], o = function Dh(t) { return 4 == (4 & t[2]) }(e); try { !o && i.begin && i.begin(), o && ss(t, e, r), Wr(t, e, n, r) } finally { !o && i.end && i.end() } } function ig(t, e, n, r, i) { const s = We(), o = 2 & r; try { xn(-1), o && e.length > 20 && Gp(t, e, 20, !1), n(r, i) } finally { xn(s) } } function sg(t, e, n) { if (Sl(e)) { const i = e.directiveEnd; for (let s = e.directiveStart; s < i; s++) { const o = t.data[s]; o.contentQueries && o.contentQueries(1, n[s], s) } } } function ju(t, e, n) { !bh() || (function mM(t, e, n, r) { const i = n.directiveStart, s = n.directiveEnd; t.firstCreatePass || Vi(n, e), $e(r, e); const o = n.initialInputs; for (let a = i; a < s; a++) { const l = t.data[a], u = kt(l); u && EM(e, n, l); const c = Ui(e, t, a, n); $e(c, e), null !== o && CM(0, a - i, c, l, 0, o), u && (lt(n.index, e)[8] = c) } }(t, e, n, at(n, e)), 128 == (128 & n.flags) && function yM(t, e, n) { const r = n.directiveStart, i = n.directiveEnd, o = n.index, a = function Ab() { return L.lFrame.currentDirectiveIndex }(); try { xn(o); for (let l = r; l < i; l++) { const u = t.data[l], c = e[l]; Bl(l), (null !== u.hostBindings || 0 !== u.hostVars || null !== u.hostAttrs) && hg(u, c) } } finally { xn(-1), Bl(a) } }(t, e, n)) } function Bu(t, e, n = at) { const r = e.localNames; if (null !== r) { let i = e.index + 1; for (let s = 0; s < r.length; s += 2) { const o = r[s + 1], a = -1 === o ? n(e, t) : t[o]; t[i++] = a } } } function og(t) { const e = t.tView; return null === e || e.incompleteFirstPass ? t.tView = Po(1, null, t.template, t.decls, t.vars, t.directiveDefs, t.pipeDefs, t.viewQuery, t.schemas, t.consts) : e } function Po(t, e, n, r, i, s, o, a, l, u) { const c = 20 + r, d = c + i, f = function lM(t, e) { const n = []; for (let r = 0; r < e; r++)n.push(r < t ? null : j); return n }(c, d), h = "function" == typeof u ? u() : u; return f[1] = { type: t, blueprint: f, template: n, queries: null, viewQuery: a, declTNode: e, data: f.slice().fill(null, c), bindingStartIndex: c, expandoStartIndex: d, hostBindingOpCodes: null, firstCreatePass: !0, firstUpdatePass: !0, staticViewQueries: !1, staticContentQueries: !1, preOrderHooks: null, preOrderCheckHooks: null, contentHooks: null, contentCheckHooks: null, viewHooks: null, viewCheckHooks: null, destroyHooks: null, cleanup: null, contentQueries: null, components: null, directiveRegistry: "function" == typeof s ? s() : s, pipeRegistry: "function" == typeof o ? o() : o, firstChild: null, schemas: l, consts: h, incompleteFirstPass: !1 } } function cg(t, e, n) { for (let r in t) if (t.hasOwnProperty(r)) { const i = t[r]; (n = null === n ? {} : n).hasOwnProperty(r) ? n[r].push(e, i) : n[r] = [e, i] } return n } function dt(t, e, n, r, i, s, o, a) { const l = at(e, n); let c, u = e.inputs; !a && null != u && (c = u[r]) ? (bg(t, n, c, r, i), ro(e) && function fM(t, e) { const n = lt(e, t); 16 & n[2] || (n[2] |= 64) }(n, e.index)) : 3 & e.type && (r = function dM(t) { return "class" === t ? "className" : "for" === t ? "htmlFor" : "formaction" === t ? "formAction" : "innerHtml" === t ? "innerHTML" : "readonly" === t ? "readOnly" : "tabindex" === t ? "tabIndex" : t }(r), i = null != o ? o(i, e.value || "", r) : i, pe(s) ? s.setProperty(l, r, i) : zl(r) || (l.setProperty ? l.setProperty(r, i) : l[r] = i)) } function Vu(t, e, n, r) { let i = !1; if (bh()) { const s = function _M(t, e, n) { const r = t.directiveRegistry; let i = null; if (r) for (let s = 0; s < r.length; s++) { const o = r[s]; zp(n, o.selectors, !1) && (i || (i = []), yo(Vi(n, e), t, o.type), kt(o) ? (pg(t, n), i.unshift(o)) : i.push(o)) } return i }(t, e, n), o = null === r ? null : { "": -1 }; if (null !== s) { i = !0, gg(n, t.data.length, s.length); for (let c = 0; c < s.length; c++) { const d = s[c]; d.providersResolver && d.providersResolver(d) } let a = !1, l = !1, u = Gr(t, e, s.length, null); for (let c = 0; c < s.length; c++) { const d = s[c]; n.mergedAttrs = po(n.mergedAttrs, d.hostAttrs), mg(t, n, e, u, d), DM(u, d, o), null !== d.contentQueries && (n.flags |= 8), (null !== d.hostBindings || null !== d.hostAttrs || 0 !== d.hostVars) && (n.flags |= 128); const f = d.type.prototype; !a && (f.ngOnChanges || f.ngOnInit || f.ngDoCheck) && ((t.preOrderHooks || (t.preOrderHooks = [])).push(n.index), a = !0), !l && (f.ngOnChanges || f.ngDoCheck) && ((t.preOrderCheckHooks || (t.preOrderCheckHooks = [])).push(n.index), l = !0), u++ } !function cM(t, e) { const r = e.directiveEnd, i = t.data, s = e.attrs, o = []; let a = null, l = null; for (let u = e.directiveStart; u < r; u++) { const c = i[u], d = c.inputs, f = null === s || $p(e) ? null : bM(d, s); o.push(f), a = cg(d, u, a), l = cg(c.outputs, u, l) } null !== a && (a.hasOwnProperty("class") && (e.flags |= 16), a.hasOwnProperty("style") && (e.flags |= 32)), e.initialInputs = o, e.inputs = a, e.outputs = l }(t, n) } o && function vM(t, e, n) { if (e) { const r = t.localNames = []; for (let i = 0; i < e.length; i += 2) { const s = n[e[i + 1]]; if (null == s) throw new M(-301, !1); r.push(e[i], s) } } }(n, r, o) } return n.mergedAttrs = po(n.mergedAttrs, n.attrs), i } function fg(t, e, n, r, i, s) { const o = s.hostBindings; if (o) { let a = t.hostBindingOpCodes; null === a && (a = t.hostBindingOpCodes = []); const l = ~e.index; (function gM(t) { let e = t.length; for (; e > 0;) { const n = t[--e]; if ("number" == typeof n && n < 0) return n } return 0 })(a) != l && a.push(l), a.push(r, i, o) } } function hg(t, e) { null !== t.hostBindings && t.hostBindings(1, e) } function pg(t, e) { e.flags |= 2, (t.components || (t.components = [])).push(e.index) } function DM(t, e, n) { if (n) { if (e.exportAs) for (let r = 0; r < e.exportAs.length; r++)n[e.exportAs[r]] = t; kt(e) && (n[""] = t) } } function gg(t, e, n) { t.flags |= 1, t.directiveStart = e, t.directiveEnd = e + n, t.providerIndexes = e } function mg(t, e, n, r, i) { t.data[r] = i; const s = i.factory || (i.factory = sr(i.type)), o = new ji(s, kt(i), null); t.blueprint[r] = o, n[r] = o, fg(t, e, 0, r, Gr(t, n, i.hostVars, j), i) } function EM(t, e, n) { const r = at(e, t), i = og(n), s = t[10], o = ko(t, is(t, i, null, n.onPush ? 64 : 16, r, e, s, s.createRenderer(r, n), null, null)); t[e.index] = o } function CM(t, e, n, r, i, s) { const o = s[e]; if (null !== o) { const a = r.setInput; for (let l = 0; l < o.length;) { const u = o[l++], c = o[l++], d = o[l++]; null !== a ? r.setInput(n, d, u, c) : n[c] = d } } } function bM(t, e) { let n = null, r = 0; for (; r < e.length;) { const i = e[r]; if (0 !== i) if (5 !== i) { if ("number" == typeof i) break; t.hasOwnProperty(i) && (null === n && (n = []), n.push(i, t[i], e[r + 1])), r += 2 } else r += 2; else r += 4 } return n } function yg(t, e, n, r) { return new Array(t, !0, !1, e, null, 0, r, n, null, null) } function TM(t, e) { const n = lt(e, t); if (Pl(n)) { const r = n[1]; 80 & n[2] ? Wr(r, n, r.template, n[8]) : n[5] > 0 && Hu(n) } } function Hu(t) { for (let r = au(t); null !== r; r = lu(r))for (let i = 10; i < r.length; i++) { const s = r[i]; if (1024 & s[2]) { const o = s[1]; Wr(o, s, o.template, s[8]) } else s[5] > 0 && Hu(s) } const n = t[1].components; if (null !== n) for (let r = 0; r < n.length; r++) { const i = lt(n[r], t); Pl(i) && i[5] > 0 && Hu(i) } } function SM(t, e) { const n = lt(e, t), r = n[1]; (function IM(t, e) { for (let n = e.length; n < t.blueprint.length; n++)e.push(t.blueprint[n]) })(r, n), ss(r, n, n[8]) } function ko(t, e) { return t[13] ? t[14][4] = e : t[13] = e, t[14] = e, e } function $u(t) { for (; t;) { t[2] |= 64; const e = Ji(t); if (sb(t) && !e) return t; t = e } return null } function _g(t) { !function zu(t) { for (let e = 0; e < t.components.length; e++) { const n = t.components[e], r = iu(n), i = r[1]; aM(i, r, i.template, n) } }(t[8]) } function Gu(t, e, n) { Ul(0), e(t, n) } const RM = (() => Promise.resolve(null))(); function vg(t) { return t[7] || (t[7] = []) } function Dg(t) { return t.cleanup || (t.cleanup = []) } function Cg(t, e) { const n = t[9], r = n ? n.get(rs, null) : null; r && r.handleError(e) } function bg(t, e, n, r, i) { for (let s = 0; s < n.length;) { const o = n[s++], a = n[s++], l = e[o], u = t.data[o]; null !== u.setInput ? u.setInput(l, i, r, a) : l[a] = i } } function mn(t, e, n) { const r = so(e, t); !function pp(t, e, n) { pe(t) ? t.setValue(e, n) : e.textContent = n }(t[B], r, n) } function Lo(t, e, n) { let r = n ? t.styles : null, i = n ? t.classes : null, s = 0; if (null !== e) for (let o = 0; o < e.length; o++) { const a = e[o]; "number" == typeof a ? s = a : 1 == s ? i = yl(i, a) : 2 == s && (r = yl(r, a + ": " + e[++o] + ";")) } n ? t.styles = r : t.stylesWithoutHost = r, n ? t.classes = i : t.classesWithoutHost = i } const Wu = new O("INJECTOR", -1); class wg { get(e, n = Gi) { if (n === Gi) { const r = new Error(`NullInjectorError: No provider for ${X(e)}!`); throw r.name = "NullInjectorError", r } return n } } const Ku = new O("Set Injector scope."), os = {}, xM = {}; let Qu; function Mg() { return void 0 === Qu && (Qu = new wg), Qu } function Tg(t, e = null, n = null, r) { const i = Sg(t, e, n, r); return i._resolveInjectorDefTypes(), i } function Sg(t, e = null, n = null, r) { return new FM(t, n, e || Mg(), r) } class FM { constructor(e, n, r, i = null) { this.parent = r, this.records = new Map, this.injectorDefTypes = new Set, this.onDestroy = new Set, this._destroyed = !1; const s = []; n && Zt(n, a => this.processProvider(a, e, n)), Zt([e], a => this.processInjectorType(a, [], s)), this.records.set(Wu, Kr(void 0, this)); const o = this.records.get(Ku); this.scope = null != o ? o.value : null, this.source = i || ("object" == typeof e ? null : X(e)) } get destroyed() { return this._destroyed } destroy() { this.assertNotDestroyed(), this._destroyed = !0; try { this.onDestroy.forEach(e => e.ngOnDestroy()) } finally { this.records.clear(), this.onDestroy.clear(), this.injectorDefTypes.clear() } } get(e, n = Gi, r = P.Default) { this.assertNotDestroyed(); const i = Jh(this), s = An(void 0); try { if (!(r & P.SkipSelf)) { let a = this.records.get(e); if (void 0 === a) { const l = function HM(t) { return "function" == typeof t || "object" == typeof t && t instanceof O }(e) && Dl(e); a = l && this.injectableDefInScope(l) ? Kr(Zu(e), os) : null, this.records.set(e, a) } if (null != a) return this.hydrate(e, a) } return (r & P.Self ? Mg() : this.parent).get(e, n = r & P.Optional && n === Gi ? null : n) } catch (o) { if ("NullInjectorError" === o.name) { if ((o[Eo] = o[Eo] || []).unshift(X(e)), i) throw o; return function pw(t, e, n, r) { const i = t[Eo]; throw e[Yh] && i.unshift(e[Yh]), t.message = function gw(t, e, n, r = null) { t = t && "\n" === t.charAt(0) && "\u0275" == t.charAt(1) ? t.substr(2) : t; let i = X(e); if (Array.isArray(e)) i = e.map(X).join(" -> "); else if ("object" == typeof e) { let s = []; for (let o in e) if (e.hasOwnProperty(o)) { let a = e[o]; s.push(o + ":" + ("string" == typeof a ? JSON.stringify(a) : X(a))) } i = `{${s.join(", ")}}` } return `${n}${r ? "(" + r + ")" : ""}[${i}]: ${t.replace(uw, "\n  ")}` }("\n" + t.message, i, n, r), t.ngTokenPath = i, t[Eo] = null, t }(o, e, "R3InjectorError", this.source) } throw o } finally { An(s), Jh(i) } } _resolveInjectorDefTypes() { this.injectorDefTypes.forEach(e => this.get(e)) } toString() { const e = []; return this.records.forEach((r, i) => e.push(X(i))), `R3Injector[${e.join(", ")}]` } assertNotDestroyed() { if (this._destroyed) throw new M(205, !1) } processInjectorType(e, n, r) { if (!(e = U(e))) return !1; let i = ah(e); const s = null == i && e.ngModule || void 0, o = void 0 === s ? e : s, a = -1 !== r.indexOf(o); if (void 0 !== s && (i = ah(s)), null == i) return !1; if (null != i.imports && !a) { let c; r.push(o); try { Zt(i.imports, d => { this.processInjectorType(d, n, r) && (void 0 === c && (c = []), c.push(d)) }) } finally { } if (void 0 !== c) for (let d = 0; d < c.length; d++) { const { ngModule: f, providers: h } = c[d]; Zt(h, p => this.processProvider(p, f, h || re)) } } this.injectorDefTypes.add(o); const l = sr(o) || (() => new o); this.records.set(o, Kr(l, os)); const u = i.providers; if (null != u && !a) { const c = e; Zt(u, d => this.processProvider(d, c, u)) } return void 0 !== s && void 0 !== e.providers } processProvider(e, n, r) { let i = Qr(e = U(e)) ? e : U(e && e.provide); const s = function kM(t, e, n) { return Ag(t) ? Kr(void 0, t.useValue) : Kr(function Ig(t, e, n) { let r; if (Qr(t)) { const i = U(t); return sr(i) || Zu(i) } if (Ag(t)) r = () => U(t.useValue); else if (function jM(t) { return !(!t || !t.useFactory) }(t)) r = () => t.useFactory(...tu(t.deps || [])); else if (function LM(t) { return !(!t || !t.useExisting) }(t)) r = () => C(U(t.useExisting)); else { const i = U(t && (t.useClass || t.provide)); if (!function VM(t) { return !!t.deps }(t)) return sr(i) || Zu(i); r = () => new i(...tu(t.deps)) } return r }(t), os) }(e); if (Qr(e) || !0 !== e.multi) this.records.get(i); else { let o = this.records.get(i); o || (o = Kr(void 0, os, !0), o.factory = () => tu(o.multi), this.records.set(i, o)), i = e, o.multi.push(e) } this.records.set(i, s) } hydrate(e, n) { return n.value === os && (n.value = xM, n.value = n.factory()), "object" == typeof n.value && n.value && function UM(t) { return null !== t && "object" == typeof t && "function" == typeof t.ngOnDestroy }(n.value) && this.onDestroy.add(n.value), n.value } injectableDefInScope(e) { if (!e.providedIn) return !1; const n = U(e.providedIn); return "string" == typeof n ? "any" === n || n === this.scope : this.injectorDefTypes.has(n) } } function Zu(t) { const e = Dl(t), n = null !== e ? e.factory : sr(t); if (null !== n) return n; if (t instanceof O) throw new M(204, !1); if (t instanceof Function) return function PM(t) { const e = t.length; if (e > 0) throw qi(e, "?"), new M(204, !1); const n = function GC(t) { const e = t && (t[Js] || t[lh]); if (e) { const n = function WC(t) { if (t.hasOwnProperty("name")) return t.name; const e = ("" + t).match(/^function\s*([^\s(]+)/); return null === e ? "" : e[1] }(t); return console.warn(`DEPRECATED: DI is instantiating a token "${n}" that inherits its @Injectable decorator but does not provide one itself.\nThis will become an error in a future version of Angular. Please add @Injectable() to the "${n}" class.`), e } return null }(t); return null !== n ? () => n.factory(t) : () => new t }(t); throw new M(204, !1) } function Kr(t, e, n = !1) { return { factory: t, value: e, multi: n ? [] : void 0 } } function Ag(t) { return null !== t && "object" == typeof t && dw in t } function Qr(t) { return "function" == typeof t } let tt = (() => { class t { static create(n, r) { var i; if (Array.isArray(n)) return Tg({ name: "" }, r, n, ""); { const s = null !== (i = n.name) && void 0 !== i ? i : ""; return Tg({ name: s }, n.parent, n.providers, s) } } } return t.THROW_IF_NOT_FOUND = Gi, t.NULL = new wg, t.\u0275prov = F({ token: t, providedIn: "any", factory: () => C(Wu) }), t.__NG_ELEMENT_ID__ = -1, t })(); function ZM(t, e) { uo(iu(t)[1], be()) } let jo = null; function Zr() { if (!jo) { const t = te.Symbol; if (t && t.iterator) jo = t.iterator; else { const e = Object.getOwnPropertyNames(Map.prototype); for (let n = 0; n < e.length; ++n) { const r = e[n]; "entries" !== r && "size" !== r && Map.prototype[r] === Map.prototype.entries && (jo = r) } } } return jo } function as(t) { return !!function ec(t) { return null !== t && ("function" == typeof t || "object" == typeof t) }(t) && (Array.isArray(t) || !(t instanceof Map) && Zr() in t) } function ze(t, e, n) { return !Object.is(t[e], n) && (t[e] = n, !0) } function Jr(t, e, n, r) { return ze(t, xr(), n) ? e + k(n) + r : j } function nc(t, e, n, r, i, s, o, a) { const l = v(), u = Q(), c = t + 20, d = u.firstCreatePass ? function aT(t, e, n, r, i, s, o, a, l) { const u = e.consts, c = qr(e, t, 4, o || null, Nn(u, a)); Vu(e, n, c, Nn(u, l)), uo(e, c); const d = c.tViews = Po(2, c, r, i, s, e.directiveRegistry, e.pipeRegistry, null, e.schemas, u); return null !== e.queries && (e.queries.template(e, c), d.queries = e.queries.embeddedTView(c)), c }(c, u, l, e, n, r, i, s, o) : u.data[c]; Qt(d, !1); const f = l[B].createComment(""); Mo(u, l, f, d), $e(f, l), ko(l, l[c] = yg(f, l, f, d)), io(d) && ju(u, l, d), null != o && Bu(l, d, a) } function S(t, e = P.Default) { const n = v(); return null === n ? C(t, e) : Uh(be(), n, U(t), e) } function ac() { throw new Error("invalid") } function yn(t, e, n) { const r = v(); return ze(r, xr(), e) && dt(Q(), ue(), r, t, e, r[B], n, !1), yn } function lc(t, e, n, r, i) { const o = i ? "class" : "style"; bg(t, n, e.inputs[o], o, r) } function Oe(t, e, n, r) { const i = v(), s = Q(), o = 20 + t, a = i[B], l = i[o] = cu(a, e, function Lb() { return L.lFrame.currentNamespace }()), u = s.firstCreatePass ? function AT(t, e, n, r, i, s, o) { const a = e.consts, u = qr(e, t, 2, i, Nn(a, s)); return Vu(e, n, u, Nn(a, o)), null !== u.attrs && Lo(u, u.attrs, !1), null !== u.mergedAttrs && Lo(u, u.mergedAttrs, !0), null !== e.queries && e.queries.elementStart(e, u), u }(o, s, i, 0, e, n, r) : s.data[o]; Qt(u, !0); const c = u.mergedAttrs; null !== c && ho(a, l, c); const d = u.classes; null !== d && yu(a, l, d); const f = u.styles; return null !== f && Sp(a, l, f), 64 != (64 & u.flags) && Mo(s, i, l, u), 0 === function Eb() { return L.lFrame.elementDepthCount }() && $e(l, i), function Cb() { L.lFrame.elementDepthCount++ }(), io(u) && (ju(s, i, u), sg(s, u, i)), null !== r && Bu(i, u), Oe } function Ne() { let t = be(); Ll() ? jl() : (t = t.parent, Qt(t, !1)); const e = t; !function bb() { L.lFrame.elementDepthCount-- }(); const n = Q(); return n.firstCreatePass && (uo(n, t), Sl(t) && n.queries.elementEnd(t)), null != e.classesWithoutHost && function Hb(t) { return 0 != (16 & t.flags) }(e) && lc(n, e, v(), e.classesWithoutHost, !0), null != e.stylesWithoutHost && function $b(t) { return 0 != (32 & t.flags) }(e) && lc(n, e, v(), e.stylesWithoutHost, !1), Ne } function Bn(t, e, n, r) { return Oe(t, e, n, r), Ne(), Bn } function us(t, e, n) { const r = v(), i = Q(), s = t + 20, o = i.firstCreatePass ? function RT(t, e, n, r, i) { const s = e.consts, o = Nn(s, r), a = qr(e, t, 8, "ng-container", o); return null !== o && Lo(a, o, !0), Vu(e, n, a, Nn(s, i)), null !== e.queries && e.queries.elementStart(e, a), a }(s, i, r, e, n) : i.data[s]; Qt(o, !0); const a = r[s] = r[B].createComment(""); return Mo(i, r, a, o), $e(a, r), io(o) && (ju(i, r, o), sg(i, o, r)), null != n && Bu(r, o), us } function cs() { let t = be(); const e = Q(); return Ll() ? jl() : (t = t.parent, Qt(t, !1)), e.firstCreatePass && (uo(e, t), Sl(t) && e.queries.elementEnd(t)), cs } function uc() { return v() } function Uo(t) { return !!t && "function" == typeof t.then } const cm = function um(t) { return !!t && "function" == typeof t.subscribe }; function Vn(t, e, n, r) { const i = v(), s = Q(), o = be(); return function fm(t, e, n, r, i, s, o, a) { const l = io(r), c = t.firstCreatePass && Dg(t), d = e[8], f = vg(e); let h = !0; if (3 & r.type || a) { const y = at(r, e), _ = a ? a(y) : y, m = f.length, D = a ? T => a(_e(T[r.index])) : r.index; if (pe(n)) { let T = null; if (!a && l && (T = function OT(t, e, n, r) { const i = t.cleanup; if (null != i) for (let s = 0; s < i.length - 1; s += 2) { const o = i[s]; if (o === n && i[s + 1] === r) { const a = e[7], l = i[s + 2]; return a.length > l ? a[l] : null } "string" == typeof o && (s += 2) } return null }(t, e, i, r.index)), null !== T) (T.__ngLastListenerFn__ || T).__ngNextListenerFn__ = s, T.__ngLastListenerFn__ = s, h = !1; else { s = cc(r, e, d, s, !1); const $ = n.listen(_, i, s); f.push(s, $), c && c.push(i, D, m, m + 1) } } else s = cc(r, e, d, s, !0), _.addEventListener(i, s, o), f.push(s), c && c.push(i, D, m, o) } else s = cc(r, e, d, s, !1); const p = r.outputs; let g; if (h && null !== p && (g = p[i])) { const y = g.length; if (y) for (let _ = 0; _ < y; _ += 2) { const le = e[g[_]][g[_ + 1]].subscribe(s), de = f.length; f.push(s, le), c && c.push(i, r.index, de, -(de + 1)) } } }(s, i, i[B], o, t, e, !!n, r), Vn } function hm(t, e, n, r) { try { return !1 !== n(r) } catch (i) { return Cg(t, i), !1 } } function cc(t, e, n, r, i) { return function s(o) { if (o === Function) return r; const a = 2 & t.flags ? lt(t.index, e) : e; 0 == (32 & e[2]) && $u(a); let l = hm(e, 0, r, o), u = s.__ngNextListenerFn__; for (; u;)l = hm(e, 0, u, o) && l, u = u.__ngNextListenerFn__; return i && !1 === l && (o.preventDefault(), o.returnValue = !1), l } } function ds(t = 1) { return function Ob(t) { return (L.lFrame.contextLView = function Nb(t, e) { for (; t > 0;)e = e[15], t--; return e }(t, L.lFrame.contextLView))[8] }(t) } function NT(t, e) { let n = null; const r = function U0(t) { const e = t.attrs; if (null != e) { const n = e.indexOf(5); if (0 == (1 & n)) return e[n + 1] } return null }(t); for (let i = 0; i < e.length; i++) { const s = e[i]; if ("*" !== s) { if (null === r ? zp(t, s, !0) : z0(r, s)) return i } else n = i } return n } function dc(t, e = 0, n) { const r = v(), i = Q(), s = qr(i, 20 + t, 16, null, n || null); null === s.projection && (s.projection = e), jl(), 64 != (64 & s.flags) && function Gw(t, e, n) { Tp(e[B], 0, e, n, yp(t, n, e), Ep(n.parent || e[6], n, e)) }(i, r, s) } function fc(t, e, n) { return Ho(t, "", e, "", n), fc } function Ho(t, e, n, r, i) { const s = v(), o = Jr(s, e, n, r); return o !== j && dt(Q(), ue(), s, t, o, s[B], i, !1), Ho } function bm(t, e, n, r, i) { const s = t[n + 1], o = null === e; let a = r ? jt(s) : gn(s), l = !1; for (; 0 !== a && (!1 === l || o);) { const c = t[a + 1]; PT(t[a], e) && (l = !0, t[a + 1] = r ? Iu(c) : Tu(c)), a = r ? jt(c) : gn(c) } l && (t[n + 1] = r ? Tu(s) : Iu(s)) } function PT(t, e) { return null === t || null == e || (Array.isArray(t) ? t[1] : t) === e || !(!Array.isArray(t) || "string" != typeof e) && Ur(t, e) >= 0 } function $o(t, e) { return function Vt(t, e, n, r) { const i = v(), s = Q(), o = function pn(t) { const e = L.lFrame, n = e.bindingIndex; return e.bindingIndex = e.bindingIndex + t, n }(2); s.firstUpdatePass && function Nm(t, e, n, r) { const i = t.data; if (null === i[n + 1]) { const s = i[We()], o = function Om(t, e) { return e >= t.expandoStartIndex }(t, n); (function km(t, e) { return 0 != (t.flags & (e ? 16 : 32)) })(s, r) && null === e && !o && (e = !1), e = function zT(t, e, n, r) { const i = function Vl(t) { const e = L.lFrame.currentDirectiveIndex; return -1 === e ? null : t[e] }(t); let s = r ? e.residualClasses : e.residualStyles; if (null === i) 0 === (r ? e.classBindings : e.styleBindings) && (n = fs(n = hc(null, t, e, n, r), e.attrs, r), s = null); else { const o = e.directiveStylingLast; if (-1 === o || t[o] !== i) if (n = hc(i, t, e, n, r), null === s) { let l = function qT(t, e, n) { const r = n ? e.classBindings : e.styleBindings; if (0 !== gn(r)) return t[jt(r)] }(t, e, r); void 0 !== l && Array.isArray(l) && (l = hc(null, t, e, l[1], r), l = fs(l, e.attrs, r), function GT(t, e, n, r) { t[jt(n ? e.classBindings : e.styleBindings)] = r }(t, e, r, l)) } else s = function WT(t, e, n) { let r; const i = e.directiveEnd; for (let s = 1 + e.directiveStylingLast; s < i; s++)r = fs(r, t[s].hostAttrs, n); return fs(r, e.attrs, n) }(t, e, r) } return void 0 !== s && (r ? e.residualClasses = s : e.residualStyles = s), n }(i, s, e, r), function xT(t, e, n, r, i, s) { let o = s ? e.classBindings : e.styleBindings, a = jt(o), l = gn(o); t[r] = n; let c, u = !1; if (Array.isArray(n)) { const d = n; c = d[1], (null === c || Ur(d, c) > 0) && (u = !0) } else c = n; if (i) if (0 !== l) { const f = jt(t[a + 1]); t[r + 1] = No(f, a), 0 !== f && (t[f + 1] = Su(t[f + 1], r)), t[a + 1] = function K0(t, e) { return 131071 & t | e << 17 }(t[a + 1], r) } else t[r + 1] = No(a, 0), 0 !== a && (t[a + 1] = Su(t[a + 1], r)), a = r; else t[r + 1] = No(l, 0), 0 === a ? a = r : t[l + 1] = Su(t[l + 1], r), l = r; u && (t[r + 1] = Tu(t[r + 1])), bm(t, c, r, !0), bm(t, c, r, !1), function FT(t, e, n, r, i) { const s = i ? t.residualClasses : t.residualStyles; null != s && "string" == typeof e && Ur(s, e) >= 0 && (n[r + 1] = Iu(n[r + 1])) }(e, c, t, r, s), o = No(a, l), s ? e.classBindings = o : e.styleBindings = o }(i, s, e, n, o, r) } }(s, t, o, r), e !== j && ze(i, o, e) && function Fm(t, e, n, r, i, s, o, a) { if (!(3 & e.type)) return; const l = t.data, u = l[a + 1]; zo(function Qp(t) { return 1 == (1 & t) }(u) ? Pm(l, e, n, i, gn(u), o) : void 0) || (zo(s) || function Kp(t) { return 2 == (2 & t) }(u) && (s = Pm(l, null, n, i, a, o)), function Kw(t, e, n, r, i) { const s = pe(t); if (e) i ? s ? t.addClass(n, r) : n.classList.add(r) : s ? t.removeClass(n, r) : n.classList.remove(r); else { let o = -1 === r.indexOf("-") ? void 0 : ct.DashCase; if (null == i) s ? t.removeStyle(n, r, o) : n.style.removeProperty(r); else { const a = "string" == typeof i && i.endsWith("!important"); a && (i = i.slice(0, -10), o |= ct.Important), s ? t.setStyle(n, r, i, o) : n.style.setProperty(r, i, a ? "important" : "") } } }(r, o, so(We(), n), i, s)) }(s, s.data[We()], i, i[B], t, i[o + 1] = function ZT(t, e) { return null == t || ("string" == typeof e ? t += e : "object" == typeof t && (t = X(kn(t)))), t }(e, n), r, o) }(t, e, null, !0), $o } function hc(t, e, n, r, i) { let s = null; const o = n.directiveEnd; let a = n.directiveStylingLast; for (-1 === a ? a = n.directiveStart : a++; a < o && (s = e[a], r = fs(r, s.hostAttrs, i), s !== t);)a++; return null !== t && (n.directiveStylingLast = a), r } function fs(t, e, n) { const r = n ? 1 : 2; let i = -1; if (null !== e) for (let s = 0; s < e.length; s++) { const o = e[s]; "number" == typeof o ? i = o : i === r && (Array.isArray(t) || (t = void 0 === t ? [] : ["", t]), ut(t, o, !!n || e[++s])) } return void 0 === t ? null : t } function Pm(t, e, n, r, i, s) { const o = null === e; let a; for (; i > 0;) { const l = t[i], u = Array.isArray(l), c = u ? l[1] : l, d = null === c; let f = n[i + 1]; f === j && (f = d ? re : void 0); let h = d ? Yl(f, r) : c === r ? f : void 0; if (u && !zo(h) && (h = Yl(l, r)), zo(h) && (a = h, o)) return a; const p = t[i + 1]; i = o ? jt(p) : gn(p) } if (null !== e) { let l = s ? e.residualClasses : e.residualStyles; null != l && (a = Yl(l, r)) } return a } function zo(t) { return void 0 !== t } function Un(t, e = "") { const n = v(), r = Q(), i = t + 20, s = r.firstCreatePass ? qr(r, i, 1, e, null) : r.data[i], o = n[i] = function uu(t, e) { return pe(t) ? t.createText(e) : t.createTextNode(e) }(n[B], e); Mo(r, n, o, s), Qt(s, !1) } function hs(t) { return pc("", t, ""), hs } function pc(t, e, n) { const r = v(), i = Jr(r, t, e, n); return i !== j && mn(r, We(), i), pc } const qo = "en-US"; let iy = qo; class Ay { } class vI { resolveComponentFactory(e) { throw function _I(t) { const e = Error(`No component factory found for ${X(t)}. Did you add it to @NgModule.entryComponents?`); return e.ngComponent = t, e }(e) } } let _s = (() => { class t { } return t.NULL = new vI, t })(); function DI() { return ci(be(), v()) } function ci(t, e) { return new Hn(at(t, e)) } let Hn = (() => { class t { constructor(n) { this.nativeElement = n } } return t.__NG_ELEMENT_ID__ = DI, t })(); class vs { } let wI = (() => { class t { } return t.\u0275prov = F({ token: t, providedIn: "root", factory: () => null }), t })(); class di { constructor(e) { this.full = e, this.major = e.split(".")[0], this.minor = e.split(".")[1], this.patch = e.split(".").slice(2).join(".") } } const MI = new di("13.3.12"), Ec = {}; function Yo(t, e, n, r, i = !1) { for (; null !== n;) { const s = e[n.index]; if (null !== s && r.push(_e(s)), Pt(s)) for (let a = 10; a < s.length; a++) { const l = s[a], u = l[1].firstChild; null !== u && Yo(l[1], l, u, r) } const o = n.type; if (8 & o) Yo(t, e, n.child, r); else if (32 & o) { const a = ou(n, e); let l; for (; l = a();)r.push(l) } else if (16 & o) { const a = Mp(e, n); if (Array.isArray(a)) r.push(...a); else { const l = Ji(e[16]); Yo(l[1], l, a, r, !0) } } n = i ? n.projectionNext : n.next } return r } class Ds { constructor(e, n) { this._lView = e, this._cdRefInjectingView = n, this._appRef = null, this._attachedToViewContainer = !1 } get rootNodes() { const e = this._lView, n = e[1]; return Yo(n, e, n.firstChild, []) } get context() { return this._lView[8] } set context(e) { this._lView[8] = e } get destroyed() { return 256 == (256 & this._lView[2]) } destroy() { if (this._appRef) this._appRef.detachView(this); else if (this._attachedToViewContainer) { const e = this._lView[3]; if (Pt(e)) { const n = e[8], r = n ? n.indexOf(this) : -1; r > -1 && (du(e, r), vo(n, r)) } this._attachedToViewContainer = !1 } mp(this._lView[1], this._lView) } onDestroy(e) { !function ug(t, e, n, r) { const i = vg(e); null === n ? i.push(r) : (i.push(n), t.firstCreatePass && Dg(t).push(r, i.length - 1)) }(this._lView[1], this._lView, null, e) } markForCheck() { $u(this._cdRefInjectingView || this._lView) } detach() { this._lView[2] &= -129 } reattach() { this._lView[2] |= 128 } detectChanges() { !function qu(t, e, n) { const r = e[10]; r.begin && r.begin(); try { Wr(t, e, t.template, n) } catch (i) { throw Cg(e, i), i } finally { r.end && r.end() } }(this._lView[1], this._lView, this.context) } checkNoChanges() { } attachToViewContainerRef() { if (this._appRef) throw new M(902, ""); this._attachedToViewContainer = !0 } detachFromAppRef() { this._appRef = null, function jw(t, e) { Xi(t, e, e[B], 2, null, null) }(this._lView[1], this._lView) } attachToAppRef(e) { if (this._attachedToViewContainer) throw new M(902, ""); this._appRef = e } } class TI extends Ds { constructor(e) { super(e), this._view = e } detectChanges() { _g(this._view) } checkNoChanges() { } get context() { return null } } class Oy extends _s { constructor(e) { super(), this.ngModule = e } resolveComponentFactory(e) { const n = Be(e); return new Cc(n, this.ngModule) } } function Ny(t) { const e = []; for (let n in t) t.hasOwnProperty(n) && e.push({ propName: t[n], templateName: n }); return e } class Cc extends Ay { constructor(e, n) { super(), this.componentDef = e, this.ngModule = n, this.componentType = e.type, this.selector = function G0(t) { return t.map(q0).join(",") }(e.selectors), this.ngContentSelectors = e.ngContentSelectors ? e.ngContentSelectors : [], this.isBoundToModule = !!n } get inputs() { return Ny(this.componentDef.inputs) } get outputs() { return Ny(this.componentDef.outputs) } create(e, n, r, i) { const s = (i = i || this.ngModule) ? function II(t, e) { return { get: (n, r, i) => { const s = t.get(n, Ec, i); return s !== Ec || r === Ec ? s : e.get(n, r, i) } } }(e, i.injector) : e, o = s.get(vs, vh), a = s.get(wI, null), l = o.createRenderer(null, this.componentDef), u = this.componentDef.selectors[0][0] || "div", c = r ? function lg(t, e, n) { if (pe(t)) return t.selectRootElement(e, n === Nt.ShadowDom); let r = "string" == typeof e ? t.querySelector(e) : e; return r.textContent = "", r }(l, r, this.componentDef.encapsulation) : cu(o.createRenderer(null, this.componentDef), u, function SI(t) { const e = t.toLowerCase(); return "svg" === e ? "svg" : "math" === e ? "math" : null }(u)), d = this.componentDef.onPush ? 576 : 528, f = function Vg(t, e) { return { components: [], scheduler: t || x0, clean: RM, playerHandler: e || null, flags: 0 } }(), h = Po(0, null, null, 1, 0, null, null, null, null, null), p = is(null, h, f, d, null, null, o, l, a, s); let g, y; ao(p); try { const _ = function jg(t, e, n, r, i, s) { const o = n[1]; n[20] = t; const l = qr(o, 20, 2, "#host", null), u = l.mergedAttrs = e.hostAttrs; null !== u && (Lo(l, u, !0), null !== t && (ho(i, t, u), null !== l.classes && yu(i, t, l.classes), null !== l.styles && Sp(i, t, l.styles))); const c = r.createRenderer(t, e), d = is(n, og(e), null, e.onPush ? 64 : 16, n[20], l, r, c, s || null, null); return o.firstCreatePass && (yo(Vi(l, n), o, e.type), pg(o, l), gg(l, n.length, 1)), ko(n, d), n[20] = d }(c, this.componentDef, p, o, l); if (c) if (r) ho(l, c, ["ng-version", MI.full]); else { const { attrs: m, classes: D } = function W0(t) { const e = [], n = []; let r = 1, i = 2; for (; r < t.length;) { let s = t[r]; if ("string" == typeof s) 2 === i ? "" !== s && e.push(s, t[++r]) : 8 === i && n.push(s); else { if (!Lt(i)) break; i = s } r++ } return { attrs: e, classes: n } }(this.componentDef.selectors[0]); m && ho(l, c, m), D && D.length > 0 && yu(l, c, D.join(" ")) } if (y = Fl(h, 20), void 0 !== n) { const m = y.projection = []; for (let D = 0; D < this.ngContentSelectors.length; D++) { const T = n[D]; m.push(null != T ? Array.from(T) : null) } } g = function Bg(t, e, n, r, i) { const s = n[1], o = function pM(t, e, n) { const r = be(); t.firstCreatePass && (n.providersResolver && n.providersResolver(n), mg(t, r, e, Gr(t, e, 1, null), n)); const i = Ui(e, t, r.directiveStart, r); $e(i, e); const s = at(r, e); return s && $e(s, e), i }(s, n, e); if (r.components.push(o), t[8] = o, i && i.forEach(l => l(o, e)), e.contentQueries) { const l = be(); e.contentQueries(1, o, l.directiveStart) } const a = be(); return !s.firstCreatePass || null === e.hostBindings && null === e.hostAttrs || (xn(a.index), fg(n[1], a, 0, a.directiveStart, a.directiveEnd, e), hg(e, o)), o }(_, this.componentDef, p, f, [ZM]), ss(h, p, null) } finally { lo() } return new RI(this.componentType, g, ci(y, p), p, y) } } class RI extends class yI { }{ constructor(e, n, r, i, s) { super(), this.location = r, this._rootLView = i, this._tNode = s, this.instance = n, this.hostView = this.changeDetectorRef = new TI(i), this.componentType = e } get injector() { return new kr(this._tNode, this._rootLView) } destroy() { this.hostView.destroy() } onDestroy(e) { this.hostView.onDestroy(e) } } class _n { } class xy { } const fi = new Map; class ky extends _n { constructor(e, n) { super(), this._parent = n, this._bootstrapComponents = [], this.injector = this, this.destroyCbs = [], this.componentFactoryResolver = new Oy(this); const r = Dt(e); this._bootstrapComponents = Jt(r.bootstrap), this._r3Injector = Sg(e, n, [{ provide: _n, useValue: this }, { provide: _s, useValue: this.componentFactoryResolver }], X(e)), this._r3Injector._resolveInjectorDefTypes(), this.instance = this.get(e) } get(e, n = tt.THROW_IF_NOT_FOUND, r = P.Default) { return e === tt || e === _n || e === Wu ? this : this._r3Injector.get(e, n, r) } destroy() { const e = this._r3Injector; !e.destroyed && e.destroy(), this.destroyCbs.forEach(n => n()), this.destroyCbs = null } onDestroy(e) { this.destroyCbs.push(e) } } class bc extends xy { constructor(e) { super(), this.moduleType = e, null !== Dt(e) && function NI(t) { const e = new Set; !function n(r) { const i = Dt(r, !0), s = i.id; null !== s && (function Fy(t, e, n) { if (e && e !== n) throw new Error(`Duplicate module registered for ${t} - ${X(e)} vs ${X(e.name)}`) }(s, fi.get(s), r), fi.set(s, r)); const o = Jt(i.imports); for (const a of o) e.has(a) || (e.add(a), n(a)) }(t) }(e) } create(e) { return new ky(this.moduleType, e) } } function wc(t) { return e => { setTimeout(t, void 0, e) } } const xe = class ZI extends ln { constructor(e = !1) { super(), this.__isAsync = e } emit(e) { super.next(e) } subscribe(e, n, r) { var i, s, o; let a = e, l = n || (() => null), u = r; if (e && "object" == typeof e) { const d = e; a = null === (i = d.next) || void 0 === i ? void 0 : i.bind(d), l = null === (s = d.error) || void 0 === s ? void 0 : s.bind(d), u = null === (o = d.complete) || void 0 === o ? void 0 : o.bind(d) } this.__isAsync && (l = wc(l), a && (a = wc(a)), u && (u = wc(u))); const c = super.subscribe({ next: a, error: l, complete: u }); return e instanceof vt && e.add(c), c } }; Symbol; let vn = (() => { class t { } return t.__NG_ELEMENT_ID__ = eA, t })(); const JI = vn, XI = class extends JI { constructor(e, n, r) { super(), this._declarationLView = e, this._declarationTContainer = n, this.elementRef = r } createEmbeddedView(e) { const n = this._declarationTContainer.tViews, r = is(this._declarationLView, n, e, 16, null, n.declTNode, null, null, null, null); r[17] = this._declarationLView[this._declarationTContainer.index]; const s = this._declarationLView[19]; return null !== s && (r[19] = s.createEmbeddedView(n)), ss(n, r, e), new Ds(r) } }; function eA() { return function Jo(t, e) { return 4 & t.type ? new XI(e, t, ci(t, e)) : null }(be(), v()) } let Ht = (() => { class t { } return t.__NG_ELEMENT_ID__ = tA, t })(); function tA() { return function zy(t, e) { let n; const r = e[t.index]; if (Pt(r)) n = r; else { let i; if (8 & t.type) i = _e(r); else { const s = e[B]; i = s.createComment(""); const o = at(t, e); ar(s, wo(s, o), i, function qw(t, e) { return pe(t) ? t.nextSibling(e) : e.nextSibling }(s, o), !1) } e[t.index] = n = yg(r, e, i, t), ko(e, n) } return new Hy(n, t, e) }(be(), v()) } const nA = Ht, Hy = class extends nA { constructor(e, n, r) { super(), this._lContainer = e, this._hostTNode = n, this._hostLView = r } get element() { return ci(this._hostTNode, this._hostLView) } get injector() { return new kr(this._hostTNode, this._hostLView) } get parentInjector() { const e = mo(this._hostTNode, this._hostLView); if (kh(e)) { const n = Pr(e, this._hostLView), r = Fr(e); return new kr(n[1].data[r + 8], n) } return new kr(null, this._hostLView) } clear() { for (; this.length > 0;)this.remove(this.length - 1) } get(e) { const n = $y(this._lContainer); return null !== n && n[e] || null } get length() { return this._lContainer.length - 10 } createEmbeddedView(e, n, r) { const i = e.createEmbeddedView(n || {}); return this.insert(i, r), i } createComponent(e, n, r, i, s) { const o = e && !function zi(t) { return "function" == typeof t }(e); let a; if (o) a = n; else { const d = n || {}; a = d.index, r = d.injector, i = d.projectableNodes, s = d.ngModuleRef } const l = o ? e : new Cc(Be(e)), u = r || this.parentInjector; if (!s && null == l.ngModule) { const f = (o ? u : this.parentInjector).get(_n, null); f && (s = f) } const c = l.create(u, i, void 0, s); return this.insert(c.hostView, a), c } insert(e, n) { const r = e._lView, i = r[1]; if (function Db(t) { return Pt(t[3]) }(r)) { const c = this.indexOf(e); if (-1 !== c) this.detach(c); else { const d = r[3], f = new Hy(d, d[6], d[3]); f.detach(f.indexOf(e)) } } const s = this._adjustIndex(n), o = this._lContainer; !function Vw(t, e, n, r) { const i = 10 + r, s = n.length; r > 0 && (n[i - 1][4] = e), r < s - 10 ? (e[4] = n[i], Gh(n, 10 + r, e)) : (n.push(e), e[4] = null), e[3] = n; const o = e[17]; null !== o && n !== o && function Uw(t, e) { const n = t[9]; e[16] !== e[3][3][16] && (t[2] = !0), null === n ? t[9] = [e] : n.push(e) }(o, e); const a = e[19]; null !== a && a.insertView(t), e[2] |= 128 }(i, r, o, s); const a = pu(s, o), l = r[B], u = wo(l, o[7]); return null !== u && function Lw(t, e, n, r, i, s) { r[0] = i, r[6] = e, Xi(t, r, n, 1, i, s) }(i, o[6], l, r, u, a), e.attachToViewContainerRef(), Gh(Tc(o), s, e), e } move(e, n) { return this.insert(e, n) } indexOf(e) { const n = $y(this._lContainer); return null !== n ? n.indexOf(e) : -1 } remove(e) { const n = this._adjustIndex(e, -1), r = du(this._lContainer, n); r && (vo(Tc(this._lContainer), n), mp(r[1], r)) } detach(e) { const n = this._adjustIndex(e, -1), r = du(this._lContainer, n); return r && null != vo(Tc(this._lContainer), n) ? new Ds(r) : null } _adjustIndex(e, n = 0) { return null == e ? this.length + n : e } }; function $y(t) { return t[8] } function Tc(t) { return t[8] || (t[8] = []) } function ta(...t) { } const Vc = new O("Application Initializer"); let Uc = (() => { class t { constructor(n) { this.appInits = n, this.resolve = ta, this.reject = ta, this.initialized = !1, this.done = !1, this.donePromise = new Promise((r, i) => { this.resolve = r, this.reject = i }) } runInitializers() { if (this.initialized) return; const n = [], r = () => { this.done = !0, this.resolve() }; if (this.appInits) for (let i = 0; i < this.appInits.length; i++) { const s = this.appInits[i](); if (Uo(s)) n.push(s); else if (cm(s)) { const o = new Promise((a, l) => { s.subscribe({ complete: a, error: l }) }); n.push(o) } } Promise.all(n).then(() => { r() }).catch(i => { this.reject(i) }), 0 === n.length && r(), this.initialized = !0 } } return t.\u0275fac = function (n) { return new (n || t)(C(Vc, 8)) }, t.\u0275prov = F({ token: t, factory: t.\u0275fac, providedIn: "root" }), t })(); const ws = new O("AppId", { providedIn: "root", factory: function f_() { return `${Hc()}${Hc()}${Hc()}` } }); function Hc() { return String.fromCharCode(97 + Math.floor(25 * Math.random())) } const h_ = new O("Platform Initializer"), na = new O("Platform ID", { providedIn: "platform", factory: () => "unknown" }), p_ = new O("appBootstrapListener"); let AA = (() => { class t { log(n) { console.log(n) } warn(n) { console.warn(n) } } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275prov = F({ token: t, factory: t.\u0275fac, providedIn: "platform" }), t })(); const Dn = new O("LocaleId", { providedIn: "root", factory: () => eu(Dn, P.Optional | P.SkipSelf) || function RA() { return "undefined" != typeof $localize && $localize.locale || qo }() }); class NA { constructor(e, n) { this.ngModuleFactory = e, this.componentFactories = n } } let g_ = (() => { class t { compileModuleSync(n) { return new bc(n) } compileModuleAsync(n) { return Promise.resolve(this.compileModuleSync(n)) } compileModuleAndAllComponentsSync(n) { const r = this.compileModuleSync(n), s = Jt(Dt(n).declarations).reduce((o, a) => { const l = Be(a); return l && o.push(new Cc(l)), o }, []); return new NA(r, s) } compileModuleAndAllComponentsAsync(n) { return Promise.resolve(this.compileModuleAndAllComponentsSync(n)) } clearCache() { } clearCacheFor(n) { } getModuleId(n) { } } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275prov = F({ token: t, factory: t.\u0275fac, providedIn: "root" }), t })(); const FA = (() => Promise.resolve(0))(); function $c(t) { "undefined" == typeof Zone ? FA.then(() => { t && t.apply(null, null) }) : Zone.current.scheduleMicroTask("scheduleMicrotask", t) } class Te { constructor({ enableLongStackTrace: e = !1, shouldCoalesceEventChangeDetection: n = !1, shouldCoalesceRunChangeDetection: r = !1 }) { if (this.hasPendingMacrotasks = !1, this.hasPendingMicrotasks = !1, this.isStable = !0, this.onUnstable = new xe(!1), this.onMicrotaskEmpty = new xe(!1), this.onStable = new xe(!1), this.onError = new xe(!1), "undefined" == typeof Zone) throw new Error("In this configuration Angular requires Zone.js"); Zone.assertZonePatched(); const i = this; i._nesting = 0, i._outer = i._inner = Zone.current, Zone.TaskTrackingZoneSpec && (i._inner = i._inner.fork(new Zone.TaskTrackingZoneSpec)), e && Zone.longStackTraceZoneSpec && (i._inner = i._inner.fork(Zone.longStackTraceZoneSpec)), i.shouldCoalesceEventChangeDetection = !r && n, i.shouldCoalesceRunChangeDetection = r, i.lastRequestAnimationFrameId = -1, i.nativeRequestAnimationFrame = function PA() { let t = te.requestAnimationFrame, e = te.cancelAnimationFrame; if ("undefined" != typeof Zone && t && e) { const n = t[Zone.__symbol__("OriginalDelegate")]; n && (t = n); const r = e[Zone.__symbol__("OriginalDelegate")]; r && (e = r) } return { nativeRequestAnimationFrame: t, nativeCancelAnimationFrame: e } }().nativeRequestAnimationFrame, function jA(t) { const e = () => { !function LA(t) { t.isCheckStableRunning || -1 !== t.lastRequestAnimationFrameId || (t.lastRequestAnimationFrameId = t.nativeRequestAnimationFrame.call(te, () => { t.fakeTopEventTask || (t.fakeTopEventTask = Zone.root.scheduleEventTask("fakeTopEventTask", () => { t.lastRequestAnimationFrameId = -1, qc(t), t.isCheckStableRunning = !0, zc(t), t.isCheckStableRunning = !1 }, void 0, () => { }, () => { })), t.fakeTopEventTask.invoke() }), qc(t)) }(t) }; t._inner = t._inner.fork({ name: "angular", properties: { isAngularZone: !0 }, onInvokeTask: (n, r, i, s, o, a) => { try { return m_(t), n.invokeTask(i, s, o, a) } finally { (t.shouldCoalesceEventChangeDetection && "eventTask" === s.type || t.shouldCoalesceRunChangeDetection) && e(), y_(t) } }, onInvoke: (n, r, i, s, o, a, l) => { try { return m_(t), n.invoke(i, s, o, a, l) } finally { t.shouldCoalesceRunChangeDetection && e(), y_(t) } }, onHasTask: (n, r, i, s) => { n.hasTask(i, s), r === i && ("microTask" == s.change ? (t._hasPendingMicrotasks = s.microTask, qc(t), zc(t)) : "macroTask" == s.change && (t.hasPendingMacrotasks = s.macroTask)) }, onHandleError: (n, r, i, s) => (n.handleError(i, s), t.runOutsideAngular(() => t.onError.emit(s)), !1) }) }(i) } static isInAngularZone() { return "undefined" != typeof Zone && !0 === Zone.current.get("isAngularZone") } static assertInAngularZone() { if (!Te.isInAngularZone()) throw new Error("Expected to be in Angular Zone, but it is not!") } static assertNotInAngularZone() { if (Te.isInAngularZone()) throw new Error("Expected to not be in Angular Zone, but it is!") } run(e, n, r) { return this._inner.run(e, n, r) } runTask(e, n, r, i) { const s = this._inner, o = s.scheduleEventTask("NgZoneEvent: " + i, e, kA, ta, ta); try { return s.runTask(o, n, r) } finally { s.cancelTask(o) } } runGuarded(e, n, r) { return this._inner.runGuarded(e, n, r) } runOutsideAngular(e) { return this._outer.run(e) } } const kA = {}; function zc(t) { if (0 == t._nesting && !t.hasPendingMicrotasks && !t.isStable) try { t._nesting++, t.onMicrotaskEmpty.emit(null) } finally { if (t._nesting--, !t.hasPendingMicrotasks) try { t.runOutsideAngular(() => t.onStable.emit(null)) } finally { t.isStable = !0 } } } function qc(t) { t.hasPendingMicrotasks = !!(t._hasPendingMicrotasks || (t.shouldCoalesceEventChangeDetection || t.shouldCoalesceRunChangeDetection) && -1 !== t.lastRequestAnimationFrameId) } function m_(t) { t._nesting++, t.isStable && (t.isStable = !1, t.onUnstable.emit(null)) } function y_(t) { t._nesting--, zc(t) } class BA { constructor() { this.hasPendingMicrotasks = !1, this.hasPendingMacrotasks = !1, this.isStable = !0, this.onUnstable = new xe, this.onMicrotaskEmpty = new xe, this.onStable = new xe, this.onError = new xe } run(e, n, r) { return e.apply(n, r) } runGuarded(e, n, r) { return e.apply(n, r) } runOutsideAngular(e) { return e() } runTask(e, n, r, i) { return e.apply(n, r) } } let Gc = (() => { class t { constructor(n) { this._ngZone = n, this._pendingCount = 0, this._isZoneStable = !0, this._didWork = !1, this._callbacks = [], this.taskTrackingZone = null, this._watchAngularEvents(), n.run(() => { this.taskTrackingZone = "undefined" == typeof Zone ? null : Zone.current.get("TaskTrackingZone") }) } _watchAngularEvents() { this._ngZone.onUnstable.subscribe({ next: () => { this._didWork = !0, this._isZoneStable = !1 } }), this._ngZone.runOutsideAngular(() => { this._ngZone.onStable.subscribe({ next: () => { Te.assertNotInAngularZone(), $c(() => { this._isZoneStable = !0, this._runCallbacksIfReady() }) } }) }) } increasePendingRequestCount() { return this._pendingCount += 1, this._didWork = !0, this._pendingCount } decreasePendingRequestCount() { if (this._pendingCount -= 1, this._pendingCount < 0) throw new Error("pending async requests below zero"); return this._runCallbacksIfReady(), this._pendingCount } isStable() { return this._isZoneStable && 0 === this._pendingCount && !this._ngZone.hasPendingMacrotasks } _runCallbacksIfReady() { if (this.isStable()) $c(() => { for (; 0 !== this._callbacks.length;) { let n = this._callbacks.pop(); clearTimeout(n.timeoutId), n.doneCb(this._didWork) } this._didWork = !1 }); else { let n = this.getPendingTasks(); this._callbacks = this._callbacks.filter(r => !r.updateCb || !r.updateCb(n) || (clearTimeout(r.timeoutId), !1)), this._didWork = !0 } } getPendingTasks() { return this.taskTrackingZone ? this.taskTrackingZone.macroTasks.map(n => ({ source: n.source, creationLocation: n.creationLocation, data: n.data })) : [] } addCallback(n, r, i) { let s = -1; r && r > 0 && (s = setTimeout(() => { this._callbacks = this._callbacks.filter(o => o.timeoutId !== s), n(this._didWork, this.getPendingTasks()) }, r)), this._callbacks.push({ doneCb: n, timeoutId: s, updateCb: i }) } whenStable(n, r, i) { if (i && !this.taskTrackingZone) throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?'); this.addCallback(n, r, i), this._runCallbacksIfReady() } getPendingRequestCount() { return this._pendingCount } findProviders(n, r, i) { return [] } } return t.\u0275fac = function (n) { return new (n || t)(C(Te)) }, t.\u0275prov = F({ token: t, factory: t.\u0275fac }), t })(), VA = (() => { class t { constructor() { this._applications = new Map, Wc.addToWindow(this) } registerApplication(n, r) { this._applications.set(n, r) } unregisterApplication(n) { this._applications.delete(n) } unregisterAllApplications() { this._applications.clear() } getTestability(n) { return this._applications.get(n) || null } getAllTestabilities() { return Array.from(this._applications.values()) } getAllRootElements() { return Array.from(this._applications.keys()) } findTestabilityInTree(n, r = !0) { return Wc.findTestabilityInTree(this, n, r) } } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275prov = F({ token: t, factory: t.\u0275fac, providedIn: "platform" }), t })(); class UA { addToWindow(e) { } findTestabilityInTree(e, n, r) { return null } } let Wc = new UA, dr = null; const __ = new O("AllowMultipleToken"), v_ = new O("PlatformOnDestroy"); class D_ { constructor(e, n) { this.name = e, this.token = n } } function E_(t, e, n = []) { const r = `Platform: ${e}`, i = new O(r); return (s = []) => { let o = Kc(); if (!o || o.injector.get(__, !1)) { const a = [...n, ...s, { provide: i, useValue: !0 }]; t ? t(a) : function qA(t) { if (dr && !dr.get(__, !1)) throw new M(400, ""); dr = t; const e = t.get(C_), n = t.get(h_, null); n && n.forEach(r => r()) }(function WA(t = [], e) { return tt.create({ name: e, providers: [{ provide: Ku, useValue: "platform" }, { provide: v_, useValue: () => dr = null }, ...t] }) }(a, r)) } return function GA(t) { const e = Kc(); if (!e) throw new M(401, ""); return e }() } } function Kc() { var t; return null !== (t = null == dr ? void 0 : dr.get(C_)) && void 0 !== t ? t : null } let C_ = (() => { class t { constructor(n) { this._injector = n, this._modules = [], this._destroyListeners = [], this._destroyed = !1 } bootstrapModuleFactory(n, r) { const a = function KA(t, e) { let n; return n = "noop" === t ? new BA : ("zone.js" === t ? void 0 : t) || new Te({ enableLongStackTrace: !1, shouldCoalesceEventChangeDetection: !!(null == e ? void 0 : e.ngZoneEventCoalescing), shouldCoalesceRunChangeDetection: !!(null == e ? void 0 : e.ngZoneRunCoalescing) }), n }(r ? r.ngZone : void 0, { ngZoneEventCoalescing: r && r.ngZoneEventCoalescing || !1, ngZoneRunCoalescing: r && r.ngZoneRunCoalescing || !1 }), l = [{ provide: Te, useValue: a }]; return a.run(() => { const u = tt.create({ providers: l, parent: this.injector, name: n.moduleType.name }), c = n.create(u), d = c.injector.get(rs, null); if (!d) throw new M(402, ""); return a.runOutsideAngular(() => { const f = a.onError.subscribe({ next: h => { d.handleError(h) } }); c.onDestroy(() => { Zc(this._modules, c), f.unsubscribe() }) }), function QA(t, e, n) { try { const r = n(); return Uo(r) ? r.catch(i => { throw e.runOutsideAngular(() => t.handleError(i)), i }) : r } catch (r) { throw e.runOutsideAngular(() => t.handleError(r)), r } }(d, a, () => { const f = c.injector.get(Uc); return f.runInitializers(), f.donePromise.then(() => (function ES(t) { it(t, "Expected localeId to be defined"), "string" == typeof t && (iy = t.toLowerCase().replace(/_/g, "-")) }(c.injector.get(Dn, qo) || qo), this._moduleDoBootstrap(c), c)) }) }) } bootstrapModule(n, r = []) { const i = b_({}, r); return function $A(t, e, n) { const r = new bc(n); return Promise.resolve(r) }(0, 0, n).then(s => this.bootstrapModuleFactory(s, i)) } _moduleDoBootstrap(n) { const r = n.injector.get(Qc); if (n._bootstrapComponents.length > 0) n._bootstrapComponents.forEach(i => r.bootstrap(i)); else { if (!n.instance.ngDoBootstrap) throw new M(403, ""); n.instance.ngDoBootstrap(r) } this._modules.push(n) } onDestroy(n) { this._destroyListeners.push(n) } get injector() { return this._injector } destroy() { if (this._destroyed) throw new M(404, ""); this._modules.slice().forEach(r => r.destroy()), this._destroyListeners.forEach(r => r()); const n = this._injector.get(v_, null); null == n || n(), this._destroyed = !0 } get destroyed() { return this._destroyed } } return t.\u0275fac = function (n) { return new (n || t)(C(tt)) }, t.\u0275prov = F({ token: t, factory: t.\u0275fac, providedIn: "platform" }), t })(); function b_(t, e) { return Array.isArray(e) ? e.reduce(b_, t) : Object.assign(Object.assign({}, t), e) } let Qc = (() => { class t { constructor(n, r, i, s) { this._zone = n, this._injector = r, this._exceptionHandler = i, this._initStatus = s, this._bootstrapListeners = [], this._views = [], this._runningTick = !1, this._stable = !0, this.componentTypes = [], this.components = [], this._onMicrotaskEmptySubscription = this._zone.onMicrotaskEmpty.subscribe({ next: () => { this._zone.run(() => { this.tick() }) } }); const o = new ye(l => { this._stable = this._zone.isStable && !this._zone.hasPendingMacrotasks && !this._zone.hasPendingMicrotasks, this._zone.runOutsideAngular(() => { l.next(this._stable), l.complete() }) }), a = new ye(l => { let u; this._zone.runOutsideAngular(() => { u = this._zone.onStable.subscribe(() => { Te.assertNotInAngularZone(), $c(() => { !this._stable && !this._zone.hasPendingMacrotasks && !this._zone.hasPendingMicrotasks && (this._stable = !0, l.next(!0)) }) }) }); const c = this._zone.onUnstable.subscribe(() => { Te.assertInAngularZone(), this._stable && (this._stable = !1, this._zone.runOutsideAngular(() => { l.next(!1) })) }); return () => { u.unsubscribe(), c.unsubscribe() } }); this.isStable = function BC(...t) { const e = Oi(t), n = function NC(t, e) { return "number" == typeof pl(t) ? t.pop() : e }(t, 1 / 0), r = t; return r.length ? 1 === r.length ? Wt(r[0]) : Ri(n)(Ue(r, e)) : cn }(o, a.pipe(function VC(t = {}) { const { connector: e = (() => new ln), resetOnError: n = !0, resetOnComplete: r = !0, resetOnRefCountZero: i = !0 } = t; return s => { let o, a, l, u = 0, c = !1, d = !1; const f = () => { null == a || a.unsubscribe(), a = void 0 }, h = () => { f(), o = l = void 0, c = d = !1 }, p = () => { const g = o; h(), null == g || g.unsubscribe() }; return ke((g, y) => { u++, !d && !c && f(); const _ = l = null != l ? l : e(); y.add(() => { u--, 0 === u && !d && !c && (a = gl(p, i)) }), _.subscribe(y), !o && u > 0 && (o = new Ai({ next: m => _.next(m), error: m => { d = !0, f(), a = gl(h, n, m), _.error(m) }, complete: () => { c = !0, f(), a = gl(h, r), _.complete() } }), Wt(g).subscribe(o)) })(s) } }())) } bootstrap(n, r) { if (!this._initStatus.done) throw new M(405, ""); let i; i = n instanceof Ay ? n : this._injector.get(_s).resolveComponentFactory(n), this.componentTypes.push(i.componentType); const s = function zA(t) { return t.isBoundToModule }(i) ? void 0 : this._injector.get(_n), a = i.create(tt.NULL, [], r || i.selector, s), l = a.location.nativeElement, u = a.injector.get(Gc, null), c = u && a.injector.get(VA); return u && c && c.registerApplication(l, u), a.onDestroy(() => { this.detachView(a.hostView), Zc(this.components, a), c && c.unregisterApplication(l) }), this._loadComponent(a), a } tick() { if (this._runningTick) throw new M(101, ""); try { this._runningTick = !0; for (let n of this._views) n.detectChanges() } catch (n) { this._zone.runOutsideAngular(() => this._exceptionHandler.handleError(n)) } finally { this._runningTick = !1 } } attachView(n) { const r = n; this._views.push(r), r.attachToAppRef(this) } detachView(n) { const r = n; Zc(this._views, r), r.detachFromAppRef() } _loadComponent(n) { this.attachView(n.hostView), this.tick(), this.components.push(n), this._injector.get(p_, []).concat(this._bootstrapListeners).forEach(i => i(n)) } ngOnDestroy() { this._views.slice().forEach(n => n.destroy()), this._onMicrotaskEmptySubscription.unsubscribe() } get viewCount() { return this._views.length } } return t.\u0275fac = function (n) { return new (n || t)(C(Te), C(tt), C(rs), C(Uc)) }, t.\u0275prov = F({ token: t, factory: t.\u0275fac, providedIn: "root" }), t })(); function Zc(t, e) { const n = t.indexOf(e); n > -1 && t.splice(n, 1) } let M_ = !0, ra = (() => { class t { } return t.__NG_ELEMENT_ID__ = JA, t })(); function JA(t) { return function XA(t, e, n) { if (ro(t) && !n) { const r = lt(t.index, e); return new Ds(r, r) } return 47 & t.type ? new Ds(e[16], e) : null }(be(), v(), 16 == (16 & t)) } class R_ { constructor() { } supports(e) { return as(e) } create(e) { return new sR(e) } } const iR = (t, e) => e; class sR { constructor(e) { this.length = 0, this._linkedRecords = null, this._unlinkedRecords = null, this._previousItHead = null, this._itHead = null, this._itTail = null, this._additionsHead = null, this._additionsTail = null, this._movesHead = null, this._movesTail = null, this._removalsHead = null, this._removalsTail = null, this._identityChangesHead = null, this._identityChangesTail = null, this._trackByFn = e || iR } forEachItem(e) { let n; for (n = this._itHead; null !== n; n = n._next)e(n) } forEachOperation(e) { let n = this._itHead, r = this._removalsHead, i = 0, s = null; for (; n || r;) { const o = !r || n && n.currentIndex < N_(r, i, s) ? n : r, a = N_(o, i, s), l = o.currentIndex; if (o === r) i--, r = r._nextRemoved; else if (n = n._next, null == o.previousIndex) i++; else { s || (s = []); const u = a - i, c = l - i; if (u != c) { for (let f = 0; f < u; f++) { const h = f < s.length ? s[f] : s[f] = 0, p = h + f; c <= p && p < u && (s[f] = h + 1) } s[o.previousIndex] = c - u } } a !== l && e(o, a, l) } } forEachPreviousItem(e) { let n; for (n = this._previousItHead; null !== n; n = n._nextPrevious)e(n) } forEachAddedItem(e) { let n; for (n = this._additionsHead; null !== n; n = n._nextAdded)e(n) } forEachMovedItem(e) { let n; for (n = this._movesHead; null !== n; n = n._nextMoved)e(n) } forEachRemovedItem(e) { let n; for (n = this._removalsHead; null !== n; n = n._nextRemoved)e(n) } forEachIdentityChange(e) { let n; for (n = this._identityChangesHead; null !== n; n = n._nextIdentityChange)e(n) } diff(e) { if (null == e && (e = []), !as(e)) throw new M(900, ""); return this.check(e) ? this : null } onDestroy() { } check(e) { this._reset(); let i, s, o, n = this._itHead, r = !1; if (Array.isArray(e)) { this.length = e.length; for (let a = 0; a < this.length; a++)s = e[a], o = this._trackByFn(a, s), null !== n && Object.is(n.trackById, o) ? (r && (n = this._verifyReinsertion(n, s, o, a)), Object.is(n.item, s) || this._addIdentityChange(n, s)) : (n = this._mismatch(n, s, o, a), r = !0), n = n._next } else i = 0, function oT(t, e) { if (Array.isArray(t)) for (let n = 0; n < t.length; n++)e(t[n]); else { const n = t[Zr()](); let r; for (; !(r = n.next()).done;)e(r.value) } }(e, a => { o = this._trackByFn(i, a), null !== n && Object.is(n.trackById, o) ? (r && (n = this._verifyReinsertion(n, a, o, i)), Object.is(n.item, a) || this._addIdentityChange(n, a)) : (n = this._mismatch(n, a, o, i), r = !0), n = n._next, i++ }), this.length = i; return this._truncate(n), this.collection = e, this.isDirty } get isDirty() { return null !== this._additionsHead || null !== this._movesHead || null !== this._removalsHead || null !== this._identityChangesHead } _reset() { if (this.isDirty) { let e; for (e = this._previousItHead = this._itHead; null !== e; e = e._next)e._nextPrevious = e._next; for (e = this._additionsHead; null !== e; e = e._nextAdded)e.previousIndex = e.currentIndex; for (this._additionsHead = this._additionsTail = null, e = this._movesHead; null !== e; e = e._nextMoved)e.previousIndex = e.currentIndex; this._movesHead = this._movesTail = null, this._removalsHead = this._removalsTail = null, this._identityChangesHead = this._identityChangesTail = null } } _mismatch(e, n, r, i) { let s; return null === e ? s = this._itTail : (s = e._prev, this._remove(e)), null !== (e = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(r, null)) ? (Object.is(e.item, n) || this._addIdentityChange(e, n), this._reinsertAfter(e, s, i)) : null !== (e = null === this._linkedRecords ? null : this._linkedRecords.get(r, i)) ? (Object.is(e.item, n) || this._addIdentityChange(e, n), this._moveAfter(e, s, i)) : e = this._addAfter(new oR(n, r), s, i), e } _verifyReinsertion(e, n, r, i) { let s = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(r, null); return null !== s ? e = this._reinsertAfter(s, e._prev, i) : e.currentIndex != i && (e.currentIndex = i, this._addToMoves(e, i)), e } _truncate(e) { for (; null !== e;) { const n = e._next; this._addToRemovals(this._unlink(e)), e = n } null !== this._unlinkedRecords && this._unlinkedRecords.clear(), null !== this._additionsTail && (this._additionsTail._nextAdded = null), null !== this._movesTail && (this._movesTail._nextMoved = null), null !== this._itTail && (this._itTail._next = null), null !== this._removalsTail && (this._removalsTail._nextRemoved = null), null !== this._identityChangesTail && (this._identityChangesTail._nextIdentityChange = null) } _reinsertAfter(e, n, r) { null !== this._unlinkedRecords && this._unlinkedRecords.remove(e); const i = e._prevRemoved, s = e._nextRemoved; return null === i ? this._removalsHead = s : i._nextRemoved = s, null === s ? this._removalsTail = i : s._prevRemoved = i, this._insertAfter(e, n, r), this._addToMoves(e, r), e } _moveAfter(e, n, r) { return this._unlink(e), this._insertAfter(e, n, r), this._addToMoves(e, r), e } _addAfter(e, n, r) { return this._insertAfter(e, n, r), this._additionsTail = null === this._additionsTail ? this._additionsHead = e : this._additionsTail._nextAdded = e, e } _insertAfter(e, n, r) { const i = null === n ? this._itHead : n._next; return e._next = i, e._prev = n, null === i ? this._itTail = e : i._prev = e, null === n ? this._itHead = e : n._next = e, null === this._linkedRecords && (this._linkedRecords = new O_), this._linkedRecords.put(e), e.currentIndex = r, e } _remove(e) { return this._addToRemovals(this._unlink(e)) } _unlink(e) { null !== this._linkedRecords && this._linkedRecords.remove(e); const n = e._prev, r = e._next; return null === n ? this._itHead = r : n._next = r, null === r ? this._itTail = n : r._prev = n, e } _addToMoves(e, n) { return e.previousIndex === n || (this._movesTail = null === this._movesTail ? this._movesHead = e : this._movesTail._nextMoved = e), e } _addToRemovals(e) { return null === this._unlinkedRecords && (this._unlinkedRecords = new O_), this._unlinkedRecords.put(e), e.currentIndex = null, e._nextRemoved = null, null === this._removalsTail ? (this._removalsTail = this._removalsHead = e, e._prevRemoved = null) : (e._prevRemoved = this._removalsTail, this._removalsTail = this._removalsTail._nextRemoved = e), e } _addIdentityChange(e, n) { return e.item = n, this._identityChangesTail = null === this._identityChangesTail ? this._identityChangesHead = e : this._identityChangesTail._nextIdentityChange = e, e } } class oR { constructor(e, n) { this.item = e, this.trackById = n, this.currentIndex = null, this.previousIndex = null, this._nextPrevious = null, this._prev = null, this._next = null, this._prevDup = null, this._nextDup = null, this._prevRemoved = null, this._nextRemoved = null, this._nextAdded = null, this._nextMoved = null, this._nextIdentityChange = null } } class aR { constructor() { this._head = null, this._tail = null } add(e) { null === this._head ? (this._head = this._tail = e, e._nextDup = null, e._prevDup = null) : (this._tail._nextDup = e, e._prevDup = this._tail, e._nextDup = null, this._tail = e) } get(e, n) { let r; for (r = this._head; null !== r; r = r._nextDup)if ((null === n || n <= r.currentIndex) && Object.is(r.trackById, e)) return r; return null } remove(e) { const n = e._prevDup, r = e._nextDup; return null === n ? this._head = r : n._nextDup = r, null === r ? this._tail = n : r._prevDup = n, null === this._head } } class O_ { constructor() { this.map = new Map } put(e) { const n = e.trackById; let r = this.map.get(n); r || (r = new aR, this.map.set(n, r)), r.add(e) } get(e, n) { const i = this.map.get(e); return i ? i.get(e, n) : null } remove(e) { const n = e.trackById; return this.map.get(n).remove(e) && this.map.delete(n), e } get isEmpty() { return 0 === this.map.size } clear() { this.map.clear() } } function N_(t, e, n) { const r = t.previousIndex; if (null === r) return r; let i = 0; return n && r < n.length && (i = n[r]), r + e + i } function F_() { return new oa([new R_]) } let oa = (() => { class t { constructor(n) { this.factories = n } static create(n, r) { if (null != r) { const i = r.factories.slice(); n = n.concat(i) } return new t(n) } static extend(n) { return { provide: t, useFactory: r => t.create(n, r || F_()), deps: [[t, new Qi, new Pn]] } } find(n) { const r = this.factories.find(i => i.supports(n)); if (null != r) return r; throw new M(901, "") } } return t.\u0275prov = F({ token: t, providedIn: "root", factory: F_ }), t })(); const fR = E_(null, "core", []); let hR = (() => { class t { constructor(n) { } } return t.\u0275fac = function (n) { return new (n || t)(C(Qc)) }, t.\u0275mod = st({ type: t }), t.\u0275inj = Xe({}), t })(), aa = null; function $n() { return aa } const Fe = new O("DocumentToken"); let hr = (() => { class t { historyGo(n) { throw new Error("Not implemented") } } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275prov = F({ token: t, factory: function () { return function yR() { return C(k_) }() }, providedIn: "platform" }), t })(); const _R = new O("Location Initialized"); let k_ = (() => { class t extends hr { constructor(n) { super(), this._doc = n, this._init() } _init() { this.location = window.location, this._history = window.history } getBaseHrefFromDOM() { return $n().getBaseHref(this._doc) } onPopState(n) { const r = $n().getGlobalEventTarget(this._doc, "window"); return r.addEventListener("popstate", n, !1), () => r.removeEventListener("popstate", n) } onHashChange(n) { const r = $n().getGlobalEventTarget(this._doc, "window"); return r.addEventListener("hashchange", n, !1), () => r.removeEventListener("hashchange", n) } get href() { return this.location.href } get protocol() { return this.location.protocol } get hostname() { return this.location.hostname } get port() { return this.location.port } get pathname() { return this.location.pathname } get search() { return this.location.search } get hash() { return this.location.hash } set pathname(n) { this.location.pathname = n } pushState(n, r, i) { L_() ? this._history.pushState(n, r, i) : this.location.hash = i } replaceState(n, r, i) { L_() ? this._history.replaceState(n, r, i) : this.location.hash = i } forward() { this._history.forward() } back() { this._history.back() } historyGo(n = 0) { this._history.go(n) } getState() { return this._history.state } } return t.\u0275fac = function (n) { return new (n || t)(C(Fe)) }, t.\u0275prov = F({ token: t, factory: function () { return function vR() { return new k_(C(Fe)) }() }, providedIn: "platform" }), t })(); function L_() { return !!window.history.pushState } function td(t, e) { if (0 == t.length) return e; if (0 == e.length) return t; let n = 0; return t.endsWith("/") && n++, e.startsWith("/") && n++, 2 == n ? t + e.substring(1) : 1 == n ? t + e : t + "/" + e } function j_(t) { const e = t.match(/#|\?|$/), n = e && e.index || t.length; return t.slice(0, n - ("/" === t[n - 1] ? 1 : 0)) + t.slice(n) } function En(t) { return t && "?" !== t[0] ? "?" + t : t } let pi = (() => { class t { historyGo(n) { throw new Error("Not implemented") } } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275prov = F({ token: t, factory: function () { return function DR(t) { const e = C(Fe).location; return new B_(C(hr), e && e.origin || "") }() }, providedIn: "root" }), t })(); const nd = new O("appBaseHref"); let B_ = (() => { class t extends pi { constructor(n, r) { if (super(), this._platformLocation = n, this._removeListenerFns = [], null == r && (r = this._platformLocation.getBaseHrefFromDOM()), null == r) throw new Error("No base href set. Please provide a value for the APP_BASE_HREF token or add a base element to the document."); this._baseHref = r } ngOnDestroy() { for (; this._removeListenerFns.length;)this._removeListenerFns.pop()() } onPopState(n) { this._removeListenerFns.push(this._platformLocation.onPopState(n), this._platformLocation.onHashChange(n)) } getBaseHref() { return this._baseHref } prepareExternalUrl(n) { return td(this._baseHref, n) } path(n = !1) { const r = this._platformLocation.pathname + En(this._platformLocation.search), i = this._platformLocation.hash; return i && n ? `${r}${i}` : r } pushState(n, r, i, s) { const o = this.prepareExternalUrl(i + En(s)); this._platformLocation.pushState(n, r, o) } replaceState(n, r, i, s) { const o = this.prepareExternalUrl(i + En(s)); this._platformLocation.replaceState(n, r, o) } forward() { this._platformLocation.forward() } back() { this._platformLocation.back() } historyGo(n = 0) { var r, i; null === (i = (r = this._platformLocation).historyGo) || void 0 === i || i.call(r, n) } } return t.\u0275fac = function (n) { return new (n || t)(C(hr), C(nd, 8)) }, t.\u0275prov = F({ token: t, factory: t.\u0275fac }), t })(), ER = (() => { class t extends pi { constructor(n, r) { super(), this._platformLocation = n, this._baseHref = "", this._removeListenerFns = [], null != r && (this._baseHref = r) } ngOnDestroy() { for (; this._removeListenerFns.length;)this._removeListenerFns.pop()() } onPopState(n) { this._removeListenerFns.push(this._platformLocation.onPopState(n), this._platformLocation.onHashChange(n)) } getBaseHref() { return this._baseHref } path(n = !1) { let r = this._platformLocation.hash; return null == r && (r = "#"), r.length > 0 ? r.substring(1) : r } prepareExternalUrl(n) { const r = td(this._baseHref, n); return r.length > 0 ? "#" + r : r } pushState(n, r, i, s) { let o = this.prepareExternalUrl(i + En(s)); 0 == o.length && (o = this._platformLocation.pathname), this._platformLocation.pushState(n, r, o) } replaceState(n, r, i, s) { let o = this.prepareExternalUrl(i + En(s)); 0 == o.length && (o = this._platformLocation.pathname), this._platformLocation.replaceState(n, r, o) } forward() { this._platformLocation.forward() } back() { this._platformLocation.back() } historyGo(n = 0) { var r, i; null === (i = (r = this._platformLocation).historyGo) || void 0 === i || i.call(r, n) } } return t.\u0275fac = function (n) { return new (n || t)(C(hr), C(nd, 8)) }, t.\u0275prov = F({ token: t, factory: t.\u0275fac }), t })(), rd = (() => { class t { constructor(n, r) { this._subject = new xe, this._urlChangeListeners = [], this._platformStrategy = n; const i = this._platformStrategy.getBaseHref(); this._platformLocation = r, this._baseHref = j_(V_(i)), this._platformStrategy.onPopState(s => { this._subject.emit({ url: this.path(!0), pop: !0, state: s.state, type: s.type }) }) } path(n = !1) { return this.normalize(this._platformStrategy.path(n)) } getState() { return this._platformLocation.getState() } isCurrentPathEqualTo(n, r = "") { return this.path() == this.normalize(n + En(r)) } normalize(n) { return t.stripTrailingSlash(function bR(t, e) { return t && e.startsWith(t) ? e.substring(t.length) : e }(this._baseHref, V_(n))) } prepareExternalUrl(n) { return n && "/" !== n[0] && (n = "/" + n), this._platformStrategy.prepareExternalUrl(n) } go(n, r = "", i = null) { this._platformStrategy.pushState(i, "", n, r), this._notifyUrlChangeListeners(this.prepareExternalUrl(n + En(r)), i) } replaceState(n, r = "", i = null) { this._platformStrategy.replaceState(i, "", n, r), this._notifyUrlChangeListeners(this.prepareExternalUrl(n + En(r)), i) } forward() { this._platformStrategy.forward() } back() { this._platformStrategy.back() } historyGo(n = 0) { var r, i; null === (i = (r = this._platformStrategy).historyGo) || void 0 === i || i.call(r, n) } onUrlChange(n) { this._urlChangeListeners.push(n), this._urlChangeSubscription || (this._urlChangeSubscription = this.subscribe(r => { this._notifyUrlChangeListeners(r.url, r.state) })) } _notifyUrlChangeListeners(n = "", r) { this._urlChangeListeners.forEach(i => i(n, r)) } subscribe(n, r, i) { return this._subject.subscribe({ next: n, error: r, complete: i }) } } return t.normalizeQueryParams = En, t.joinWithSlash = td, t.stripTrailingSlash = j_, t.\u0275fac = function (n) { return new (n || t)(C(pi), C(hr)) }, t.\u0275prov = F({ token: t, factory: function () { return function CR() { return new rd(C(pi), C(hr)) }() }, providedIn: "root" }), t })(); function V_(t) { return t.replace(/\/index.html$/, "") } function Q_(t, e) { e = encodeURIComponent(e); for (const n of t.split(";")) { const r = n.indexOf("="), [i, s] = -1 == r ? [n, ""] : [n.slice(0, r), n.slice(r + 1)]; if (i.trim() === e) return decodeURIComponent(s) } return null } class lO { constructor(e, n, r, i) { this.$implicit = e, this.ngForOf = n, this.index = r, this.count = i } get first() { return 0 === this.index } get last() { return this.index === this.count - 1 } get even() { return this.index % 2 == 0 } get odd() { return !this.even } } let Z_ = (() => { class t { constructor(n, r, i) { this._viewContainer = n, this._template = r, this._differs = i, this._ngForOf = null, this._ngForOfDirty = !0, this._differ = null } set ngForOf(n) { this._ngForOf = n, this._ngForOfDirty = !0 } set ngForTrackBy(n) { this._trackByFn = n } get ngForTrackBy() { return this._trackByFn } set ngForTemplate(n) { n && (this._template = n) } ngDoCheck() { if (this._ngForOfDirty) { this._ngForOfDirty = !1; const n = this._ngForOf; !this._differ && n && (this._differ = this._differs.find(n).create(this.ngForTrackBy)) } if (this._differ) { const n = this._differ.diff(this._ngForOf); n && this._applyChanges(n) } } _applyChanges(n) { const r = this._viewContainer; n.forEachOperation((i, s, o) => { if (null == i.previousIndex) r.createEmbeddedView(this._template, new lO(i.item, this._ngForOf, -1, -1), null === o ? void 0 : o); else if (null == o) r.remove(null === s ? void 0 : s); else if (null !== s) { const a = r.get(s); r.move(a, o), Y_(a, i) } }); for (let i = 0, s = r.length; i < s; i++) { const a = r.get(i).context; a.index = i, a.count = s, a.ngForOf = this._ngForOf } n.forEachIdentityChange(i => { Y_(r.get(i.currentIndex), i) }) } static ngTemplateContextGuard(n, r) { return !0 } } return t.\u0275fac = function (n) { return new (n || t)(S(Ht), S(vn), S(oa)) }, t.\u0275dir = Ae({ type: t, selectors: [["", "ngFor", "", "ngForOf", ""]], inputs: { ngForOf: "ngForOf", ngForTrackBy: "ngForTrackBy", ngForTemplate: "ngForTemplate" } }), t })(); function Y_(t, e) { t.context.$implicit = e.item } let LO = (() => { class t { } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275mod = st({ type: t }), t.\u0275inj = Xe({}), t })(); const tv = "browser"; let HO = (() => { class t { } return t.\u0275prov = F({ token: t, providedIn: "root", factory: () => new $O(C(Fe), window) }), t })(); class $O { constructor(e, n) { this.document = e, this.window = n, this.offset = () => [0, 0] } setOffset(e) { this.offset = Array.isArray(e) ? () => e : e } getScrollPosition() { return this.supportsScrolling() ? [this.window.pageXOffset, this.window.pageYOffset] : [0, 0] } scrollToPosition(e) { this.supportsScrolling() && this.window.scrollTo(e[0], e[1]) } scrollToAnchor(e) { if (!this.supportsScrolling()) return; const n = function zO(t, e) { const n = t.getElementById(e) || t.getElementsByName(e)[0]; if (n) return n; if ("function" == typeof t.createTreeWalker && t.body && (t.body.createShadowRoot || t.body.attachShadow)) { const r = t.createTreeWalker(t.body, NodeFilter.SHOW_ELEMENT); let i = r.currentNode; for (; i;) { const s = i.shadowRoot; if (s) { const o = s.getElementById(e) || s.querySelector(`[name="${e}"]`); if (o) return o } i = r.nextNode() } } return null }(this.document, e); n && (this.scrollToElement(n), n.focus()) } setHistoryScrollRestoration(e) { if (this.supportScrollRestoration()) { const n = this.window.history; n && n.scrollRestoration && (n.scrollRestoration = e) } } scrollToElement(e) { const n = e.getBoundingClientRect(), r = n.left + this.window.pageXOffset, i = n.top + this.window.pageYOffset, s = this.offset(); this.window.scrollTo(r - s[0], i - s[1]) } supportScrollRestoration() { try { if (!this.supportsScrolling()) return !1; const e = nv(this.window.history) || nv(Object.getPrototypeOf(this.window.history)); return !(!e || !e.writable && !e.set) } catch (e) { return !1 } } supportsScrolling() { try { return !!this.window && !!this.window.scrollTo && "pageXOffset" in this.window } catch (e) { return !1 } } } function nv(t) { return Object.getOwnPropertyDescriptor(t, "scrollRestoration") } class rv { } class yd extends class qO extends class mR { }{ constructor() { super(...arguments), this.supportsDOMEvents = !0 } }{ static makeCurrent() { !function gR(t) { aa || (aa = t) }(new yd) } onAndCancel(e, n, r) { return e.addEventListener(n, r, !1), () => { e.removeEventListener(n, r, !1) } } dispatchEvent(e, n) { e.dispatchEvent(n) } remove(e) { e.parentNode && e.parentNode.removeChild(e) } createElement(e, n) { return (n = n || this.getDefaultDocument()).createElement(e) } createHtmlDocument() { return document.implementation.createHTMLDocument("fakeTitle") } getDefaultDocument() { return document } isElementNode(e) { return e.nodeType === Node.ELEMENT_NODE } isShadowRoot(e) { return e instanceof DocumentFragment } getGlobalEventTarget(e, n) { return "window" === n ? window : "document" === n ? e : "body" === n ? e.body : null } getBaseHref(e) { const n = function GO() { return Is = Is || document.querySelector("base"), Is ? Is.getAttribute("href") : null }(); return null == n ? null : function WO(t) { ya = ya || document.createElement("a"), ya.setAttribute("href", t); const e = ya.pathname; return "/" === e.charAt(0) ? e : `/${e}` }(n) } resetBaseElement() { Is = null } getUserAgent() { return window.navigator.userAgent } getCookie(e) { return Q_(document.cookie, e) } } let ya, Is = null; const iv = new O("TRANSITION_ID"), QO = [{ provide: Vc, useFactory: function KO(t, e, n) { return () => { n.get(Uc).donePromise.then(() => { const r = $n(), i = e.querySelectorAll(`style[ng-transition="${t}"]`); for (let s = 0; s < i.length; s++)r.remove(i[s]) }) } }, deps: [iv, Fe, tt], multi: !0 }]; class _d { static init() { !function HA(t) { Wc = t }(new _d) } addToWindow(e) { te.getAngularTestability = (r, i = !0) => { const s = e.findTestabilityInTree(r, i); if (null == s) throw new Error("Could not find testability for element."); return s }, te.getAllAngularTestabilities = () => e.getAllTestabilities(), te.getAllAngularRootElements = () => e.getAllRootElements(), te.frameworkStabilizers || (te.frameworkStabilizers = []), te.frameworkStabilizers.push(r => { const i = te.getAllAngularTestabilities(); let s = i.length, o = !1; const a = function (l) { o = o || l, s--, 0 == s && r(o) }; i.forEach(function (l) { l.whenStable(a) }) }) } findTestabilityInTree(e, n, r) { if (null == n) return null; const i = e.getTestability(n); return null != i ? i : r ? $n().isShadowRoot(n) ? this.findTestabilityInTree(e, n.host, !0) : this.findTestabilityInTree(e, n.parentElement, !0) : null } } let ZO = (() => { class t { build() { return new XMLHttpRequest } } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275prov = F({ token: t, factory: t.\u0275fac }), t })(); const _a = new O("EventManagerPlugins"); let va = (() => { class t { constructor(n, r) { this._zone = r, this._eventNameToPlugin = new Map, n.forEach(i => i.manager = this), this._plugins = n.slice().reverse() } addEventListener(n, r, i) { return this._findPluginFor(r).addEventListener(n, r, i) } addGlobalEventListener(n, r, i) { return this._findPluginFor(r).addGlobalEventListener(n, r, i) } getZone() { return this._zone } _findPluginFor(n) { const r = this._eventNameToPlugin.get(n); if (r) return r; const i = this._plugins; for (let s = 0; s < i.length; s++) { const o = i[s]; if (o.supports(n)) return this._eventNameToPlugin.set(n, o), o } throw new Error(`No event manager plugin found for event ${n}`) } } return t.\u0275fac = function (n) { return new (n || t)(C(_a), C(Te)) }, t.\u0275prov = F({ token: t, factory: t.\u0275fac }), t })(); class sv { constructor(e) { this._doc = e } addGlobalEventListener(e, n, r) { const i = $n().getGlobalEventTarget(this._doc, e); if (!i) throw new Error(`Unsupported event target ${i} for event ${n}`); return this.addEventListener(i, n, r) } } let ov = (() => { class t { constructor() { this._stylesSet = new Set } addStyles(n) { const r = new Set; n.forEach(i => { this._stylesSet.has(i) || (this._stylesSet.add(i), r.add(i)) }), this.onStylesAdded(r) } onStylesAdded(n) { } getAllStyles() { return Array.from(this._stylesSet) } } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275prov = F({ token: t, factory: t.\u0275fac }), t })(), As = (() => { class t extends ov { constructor(n) { super(), this._doc = n, this._hostNodes = new Map, this._hostNodes.set(n.head, []) } _addStylesToHost(n, r, i) { n.forEach(s => { const o = this._doc.createElement("style"); o.textContent = s, i.push(r.appendChild(o)) }) } addHost(n) { const r = []; this._addStylesToHost(this._stylesSet, n, r), this._hostNodes.set(n, r) } removeHost(n) { const r = this._hostNodes.get(n); r && r.forEach(av), this._hostNodes.delete(n) } onStylesAdded(n) { this._hostNodes.forEach((r, i) => { this._addStylesToHost(n, i, r) }) } ngOnDestroy() { this._hostNodes.forEach(n => n.forEach(av)) } } return t.\u0275fac = function (n) { return new (n || t)(C(Fe)) }, t.\u0275prov = F({ token: t, factory: t.\u0275fac }), t })(); function av(t) { $n().remove(t) } const vd = { svg: "http://www.w3.org/2000/svg", xhtml: "http://www.w3.org/1999/xhtml", xlink: "http://www.w3.org/1999/xlink", xml: "http://www.w3.org/XML/1998/namespace", xmlns: "http://www.w3.org/2000/xmlns/", math: "http://www.w3.org/1998/MathML/" }, Dd = /%COMP%/g; function Da(t, e, n) { for (let r = 0; r < e.length; r++) { let i = e[r]; Array.isArray(i) ? Da(t, i, n) : (i = i.replace(Dd, t), n.push(i)) } return n } function cv(t) { return e => { if ("__ngUnwrap__" === e) return t; !1 === t(e) && (e.preventDefault(), e.returnValue = !1) } } let Ea = (() => { class t { constructor(n, r, i) { this.eventManager = n, this.sharedStylesHost = r, this.appId = i, this.rendererByCompId = new Map, this.defaultRenderer = new Ed(n) } createRenderer(n, r) { if (!n || !r) return this.defaultRenderer; switch (r.encapsulation) { case Nt.Emulated: { let i = this.rendererByCompId.get(r.id); return i || (i = new nN(this.eventManager, this.sharedStylesHost, r, this.appId), this.rendererByCompId.set(r.id, i)), i.applyToHost(n), i } case 1: case Nt.ShadowDom: return new rN(this.eventManager, this.sharedStylesHost, n, r); default: if (!this.rendererByCompId.has(r.id)) { const i = Da(r.id, r.styles, []); this.sharedStylesHost.addStyles(i), this.rendererByCompId.set(r.id, this.defaultRenderer) } return this.defaultRenderer } } begin() { } end() { } } return t.\u0275fac = function (n) { return new (n || t)(C(va), C(As), C(ws)) }, t.\u0275prov = F({ token: t, factory: t.\u0275fac }), t })(); class Ed { constructor(e) { this.eventManager = e, this.data = Object.create(null), this.destroyNode = null } destroy() { } createElement(e, n) { return n ? document.createElementNS(vd[n] || n, e) : document.createElement(e) } createComment(e) { return document.createComment(e) } createText(e) { return document.createTextNode(e) } appendChild(e, n) { e.appendChild(n) } insertBefore(e, n, r) { e && e.insertBefore(n, r) } removeChild(e, n) { e && e.removeChild(n) } selectRootElement(e, n) { let r = "string" == typeof e ? document.querySelector(e) : e; if (!r) throw new Error(`The selector "${e}" did not match any elements`); return n || (r.textContent = ""), r } parentNode(e) { return e.parentNode } nextSibling(e) { return e.nextSibling } setAttribute(e, n, r, i) { if (i) { n = i + ":" + n; const s = vd[i]; s ? e.setAttributeNS(s, n, r) : e.setAttribute(n, r) } else e.setAttribute(n, r) } removeAttribute(e, n, r) { if (r) { const i = vd[r]; i ? e.removeAttributeNS(i, n) : e.removeAttribute(`${r}:${n}`) } else e.removeAttribute(n) } addClass(e, n) { e.classList.add(n) } removeClass(e, n) { e.classList.remove(n) } setStyle(e, n, r, i) { i & (ct.DashCase | ct.Important) ? e.style.setProperty(n, r, i & ct.Important ? "important" : "") : e.style[n] = r } removeStyle(e, n, r) { r & ct.DashCase ? e.style.removeProperty(n) : e.style[n] = "" } setProperty(e, n, r) { e[n] = r } setValue(e, n) { e.nodeValue = n } listen(e, n, r) { return "string" == typeof e ? this.eventManager.addGlobalEventListener(e, n, cv(r)) : this.eventManager.addEventListener(e, n, cv(r)) } } class nN extends Ed { constructor(e, n, r, i) { super(e), this.component = r; const s = Da(i + "-" + r.id, r.styles, []); n.addStyles(s), this.contentAttr = function XO(t) { return "_ngcontent-%COMP%".replace(Dd, t) }(i + "-" + r.id), this.hostAttr = function eN(t) { return "_nghost-%COMP%".replace(Dd, t) }(i + "-" + r.id) } applyToHost(e) { super.setAttribute(e, this.hostAttr, "") } createElement(e, n) { const r = super.createElement(e, n); return super.setAttribute(r, this.contentAttr, ""), r } } class rN extends Ed { constructor(e, n, r, i) { super(e), this.sharedStylesHost = n, this.hostEl = r, this.shadowRoot = r.attachShadow({ mode: "open" }), this.sharedStylesHost.addHost(this.shadowRoot); const s = Da(i.id, i.styles, []); for (let o = 0; o < s.length; o++) { const a = document.createElement("style"); a.textContent = s[o], this.shadowRoot.appendChild(a) } } nodeOrShadowRoot(e) { return e === this.hostEl ? this.shadowRoot : e } destroy() { this.sharedStylesHost.removeHost(this.shadowRoot) } appendChild(e, n) { return super.appendChild(this.nodeOrShadowRoot(e), n) } insertBefore(e, n, r) { return super.insertBefore(this.nodeOrShadowRoot(e), n, r) } removeChild(e, n) { return super.removeChild(this.nodeOrShadowRoot(e), n) } parentNode(e) { return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(e))) } } let iN = (() => { class t extends sv { constructor(n) { super(n) } supports(n) { return !0 } addEventListener(n, r, i) { return n.addEventListener(r, i, !1), () => this.removeEventListener(n, r, i) } removeEventListener(n, r, i) { return n.removeEventListener(r, i) } } return t.\u0275fac = function (n) { return new (n || t)(C(Fe)) }, t.\u0275prov = F({ token: t, factory: t.\u0275fac }), t })(); const fv = ["alt", "control", "meta", "shift"], oN = { "\b": "Backspace", "\t": "Tab", "\x7f": "Delete", "\x1b": "Escape", Del: "Delete", Esc: "Escape", Left: "ArrowLeft", Right: "ArrowRight", Up: "ArrowUp", Down: "ArrowDown", Menu: "ContextMenu", Scroll: "ScrollLock", Win: "OS" }, hv = { A: "1", B: "2", C: "3", D: "4", E: "5", F: "6", G: "7", H: "8", I: "9", J: "*", K: "+", M: "-", N: ".", O: "/", "`": "0", "\x90": "NumLock" }, aN = { alt: t => t.altKey, control: t => t.ctrlKey, meta: t => t.metaKey, shift: t => t.shiftKey }; let lN = (() => { class t extends sv { constructor(n) { super(n) } supports(n) { return null != t.parseEventName(n) } addEventListener(n, r, i) { const s = t.parseEventName(r), o = t.eventCallback(s.fullKey, i, this.manager.getZone()); return this.manager.getZone().runOutsideAngular(() => $n().onAndCancel(n, s.domEventName, o)) } static parseEventName(n) { const r = n.toLowerCase().split("."), i = r.shift(); if (0 === r.length || "keydown" !== i && "keyup" !== i) return null; const s = t._normalizeKey(r.pop()); let o = ""; if (fv.forEach(l => { const u = r.indexOf(l); u > -1 && (r.splice(u, 1), o += l + ".") }), o += s, 0 != r.length || 0 === s.length) return null; const a = {}; return a.domEventName = i, a.fullKey = o, a } static getEventFullKey(n) { let r = "", i = function uN(t) { let e = t.key; if (null == e) { if (e = t.keyIdentifier, null == e) return "Unidentified"; e.startsWith("U+") && (e = String.fromCharCode(parseInt(e.substring(2), 16)), 3 === t.location && hv.hasOwnProperty(e) && (e = hv[e])) } return oN[e] || e }(n); return i = i.toLowerCase(), " " === i ? i = "space" : "." === i && (i = "dot"), fv.forEach(s => { s != i && aN[s](n) && (r += s + ".") }), r += i, r } static eventCallback(n, r, i) { return s => { t.getEventFullKey(s) === n && i.runGuarded(() => r(s)) } } static _normalizeKey(n) { return "esc" === n ? "escape" : n } } return t.\u0275fac = function (n) { return new (n || t)(C(Fe)) }, t.\u0275prov = F({ token: t, factory: t.\u0275fac }), t })(); const hN = E_(fR, "browser", [{ provide: na, useValue: tv }, { provide: h_, useValue: function cN() { yd.makeCurrent(), _d.init() }, multi: !0 }, { provide: Fe, useFactory: function fN() { return function mb(t) { Nl = t }(document), document }, deps: [] }]), pN = [{ provide: Ku, useValue: "root" }, { provide: rs, useFactory: function dN() { return new rs }, deps: [] }, { provide: _a, useClass: iN, multi: !0, deps: [Fe, Te, na] }, { provide: _a, useClass: lN, multi: !0, deps: [Fe] }, { provide: Ea, useClass: Ea, deps: [va, As, ws] }, { provide: vs, useExisting: Ea }, { provide: ov, useExisting: As }, { provide: As, useClass: As, deps: [Fe] }, { provide: Gc, useClass: Gc, deps: [Te] }, { provide: va, useClass: va, deps: [_a, Te] }, { provide: rv, useClass: ZO, deps: [] }]; let pv = (() => { class t { constructor(n) { if (n) throw new Error("BrowserModule has already been loaded. If you need access to common directives such as NgIf and NgFor from a lazy loaded module, import CommonModule instead.") } static withServerTransition(n) { return { ngModule: t, providers: [{ provide: ws, useValue: n.appId }, { provide: iv, useExisting: ws }, QO] } } } return t.\u0275fac = function (n) { return new (n || t)(C(t, 12)) }, t.\u0275mod = st({ type: t }), t.\u0275inj = Xe({ providers: pN, imports: [LO, hR] }), t })(); function V(...t) { return Ue(t, Oi(t)) } "undefined" != typeof window && window; class qt extends ln { constructor(e) { super(), this._value = e } get value() { return this.getValue() } _subscribe(e) { const n = super._subscribe(e); return !n.closed && e.next(this._value), n } getValue() { const { hasError: e, thrownError: n, _value: r } = this; if (e) throw n; return this._throwIfClosed(), r } next(e) { super.next(this._value = e) } } const { isArray: MN } = Array, { getPrototypeOf: TN, prototype: SN, keys: IN } = Object; const { isArray: ON } = Array; function PN(...t) { const e = Oi(t), n = function OC(t) { return ie(pl(t)) ? t.pop() : void 0 }(t), { args: r, keys: i } = function AN(t) { if (1 === t.length) { const e = t[0]; if (MN(e)) return { args: e, keys: null }; if (function RN(t) { return t && "object" == typeof t && TN(t) === SN }(e)) { const n = IN(e); return { args: n.map(r => e[r]), keys: n } } } return { args: t, keys: null } }(t); if (0 === r.length) return Ue([], e); const s = new ye(function kN(t, e, n = er) { return r => { yv(e, () => { const { length: i } = t, s = new Array(i); let o = i, a = i; for (let l = 0; l < i; l++)yv(e, () => { const u = Ue(t[l], e); let c = !1; u.subscribe(Le(r, d => { s[l] = d, c || (c = !0, a--), a || r.next(n(s.slice())) }, () => { --o || r.complete() })) }, r) }, r) } }(r, e, i ? o => function FN(t, e) { return t.reduce((n, r, i) => (n[r] = e[i], n), {}) }(i, o) : er)); return n ? s.pipe(function xN(t) { return J(e => function NN(t, e) { return ON(e) ? t(...e) : t(e) }(t, e)) }(n)) : s } function yv(t, e, n) { t ? un(n, t, e) : e() } function Ca(t, e) { const n = ie(t) ? t : () => t, r = i => i.error(n()); return new ye(e ? i => e.schedule(r, 0, i) : r) } const ba = Si(t => function () { t(this), this.name = "EmptyError", this.message = "no elements in sequence" }); function bd(...t) { return function LN() { return Ri(1) }()(Ue(t, Oi(t))) } function _v(t) { return new ye(e => { Wt(t()).subscribe(e) }) } function vv() { return ke((t, e) => { let n = null; t._refCount++; const r = Le(e, void 0, void 0, void 0, () => { if (!t || t._refCount <= 0 || 0 < --t._refCount) return void (n = null); const i = t._connection, s = n; n = null, i && (!s || i === s) && i.unsubscribe(), e.unsubscribe() }); t.subscribe(r), r.closed || (n = t.connect()) }) } class jN extends ye { constructor(e, n) { super(), this.source = e, this.subjectFactory = n, this._subject = null, this._refCount = 0, this._connection = null, Uf(e) && (this.lift = e.lift) } _subscribe(e) { return this.getSubject().subscribe(e) } getSubject() { const e = this._subject; return (!e || e.isStopped) && (this._subject = this.subjectFactory()), this._subject } _teardown() { this._refCount = 0; const { _connection: e } = this; this._subject = this._connection = null, null == e || e.unsubscribe() } connect() { let e = this._connection; if (!e) { e = this._connection = new vt; const n = this.getSubject(); e.add(this.source.subscribe(Le(n, void 0, () => { this._teardown(), n.complete() }, r => { this._teardown(), n.error(r) }, () => this._teardown()))), e.closed && (this._connection = null, e = vt.EMPTY) } return e } refCount() { return vv()(this) } } function pr(t, e) { return ke((n, r) => { let i = null, s = 0, o = !1; const a = () => o && !i && r.complete(); n.subscribe(Le(r, l => { null == i || i.unsubscribe(); let u = 0; const c = s++; Wt(t(l, c)).subscribe(i = Le(r, d => r.next(e ? e(l, d, c, u++) : d), () => { i = null, a() })) }, () => { o = !0, a() })) }) } function wd(t) { return t <= 0 ? () => cn : ke((e, n) => { let r = 0; e.subscribe(Le(n, i => { ++r <= t && (n.next(i), t <= r && n.complete()) })) }) } function VN(t, e, n, r, i) { return (s, o) => { let a = n, l = e, u = 0; s.subscribe(Le(o, c => { const d = u++; l = a ? t(l, c, d) : (a = !0, c), r && o.next(l) }, i && (() => { a && o.next(l), o.complete() }))) } } function Dv(t, e) { return ke(VN(t, e, arguments.length >= 2, !0)) } function gr(t, e) { return ke((n, r) => { let i = 0; n.subscribe(Le(r, s => t.call(e, s, i++) && r.next(s))) }) } function qn(t) { return ke((e, n) => { let s, r = null, i = !1; r = e.subscribe(Le(n, void 0, void 0, o => { s = Wt(t(o, qn(t)(e))), r ? (r.unsubscribe(), r = null, s.subscribe(n)) : i = !0 })), i && (r.unsubscribe(), r = null, s.subscribe(n)) }) } function gi(t, e) { return ie(e) ? Ie(t, e, 1) : Ie(t, 1) } function Md(t) { return t <= 0 ? () => cn : ke((e, n) => { let r = []; e.subscribe(Le(n, i => { r.push(i), t < r.length && r.shift() }, () => { for (const i of r) n.next(i); n.complete() }, void 0, () => { r = null })) }) } function Ev(t = UN) { return ke((e, n) => { let r = !1; e.subscribe(Le(n, i => { r = !0, n.next(i) }, () => r ? n.complete() : n.error(t()))) }) } function UN() { return new ba } function Cv(t) { return ke((e, n) => { let r = !1; e.subscribe(Le(n, i => { r = !0, n.next(i) }, () => { r || n.next(t), n.complete() })) }) } function mi(t, e) { const n = arguments.length >= 2; return r => r.pipe(t ? gr((i, s) => t(i, s, r)) : er, wd(1), n ? Cv(e) : Ev(() => new ba)) } function ft(t, e, n) { const r = ie(t) || e || n ? { next: t, error: e, complete: n } : t; return r ? ke((i, s) => { var o; null === (o = r.subscribe) || void 0 === o || o.call(r); let a = !0; i.subscribe(Le(s, l => { var u; null === (u = r.next) || void 0 === u || u.call(r, l), s.next(l) }, () => { var l; a = !1, null === (l = r.complete) || void 0 === l || l.call(r), s.complete() }, l => { var u; a = !1, null === (u = r.error) || void 0 === u || u.call(r, l), s.error(l) }, () => { var l, u; a && (null === (l = r.unsubscribe) || void 0 === l || l.call(r)), null === (u = r.finalize) || void 0 === u || u.call(r) })) }) : er } class bn { constructor(e, n) { this.id = e, this.url = n } } class Td extends bn { constructor(e, n, r = "imperative", i = null) { super(e, n), this.navigationTrigger = r, this.restoredState = i } toString() { return `NavigationStart(id: ${this.id}, url: '${this.url}')` } } class Rs extends bn { constructor(e, n, r) { super(e, n), this.urlAfterRedirects = r } toString() { return `NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')` } } class bv extends bn { constructor(e, n, r) { super(e, n), this.reason = r } toString() { return `NavigationCancel(id: ${this.id}, url: '${this.url}')` } } class zN extends bn { constructor(e, n, r) { super(e, n), this.error = r } toString() { return `NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})` } } class qN extends bn { constructor(e, n, r, i) { super(e, n), this.urlAfterRedirects = r, this.state = i } toString() { return `RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class GN extends bn { constructor(e, n, r, i) { super(e, n), this.urlAfterRedirects = r, this.state = i } toString() { return `GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class WN extends bn { constructor(e, n, r, i, s) { super(e, n), this.urlAfterRedirects = r, this.state = i, this.shouldActivate = s } toString() { return `GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})` } } class KN extends bn { constructor(e, n, r, i) { super(e, n), this.urlAfterRedirects = r, this.state = i } toString() { return `ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class QN extends bn { constructor(e, n, r, i) { super(e, n), this.urlAfterRedirects = r, this.state = i } toString() { return `ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class wv { constructor(e) { this.route = e } toString() { return `RouteConfigLoadStart(path: ${this.route.path})` } } class Mv { constructor(e) { this.route = e } toString() { return `RouteConfigLoadEnd(path: ${this.route.path})` } } class ZN { constructor(e) { this.snapshot = e } toString() { return `ChildActivationStart(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class YN { constructor(e) { this.snapshot = e } toString() { return `ChildActivationEnd(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class JN { constructor(e) { this.snapshot = e } toString() { return `ActivationStart(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class XN { constructor(e) { this.snapshot = e } toString() { return `ActivationEnd(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class Tv { constructor(e, n, r) { this.routerEvent = e, this.position = n, this.anchor = r } toString() { return `Scroll(anchor: '${this.anchor}', position: '${this.position ? `${this.position[0]}, ${this.position[1]}` : null}')` } } const q = "primary"; class ex { constructor(e) { this.params = e || {} } has(e) { return Object.prototype.hasOwnProperty.call(this.params, e) } get(e) { if (this.has(e)) { const n = this.params[e]; return Array.isArray(n) ? n[0] : n } return null } getAll(e) { if (this.has(e)) { const n = this.params[e]; return Array.isArray(n) ? n : [n] } return [] } get keys() { return Object.keys(this.params) } } function yi(t) { return new ex(t) } const Sv = "ngNavigationCancelingError"; function Sd(t) { const e = Error("NavigationCancelingError: " + t); return e[Sv] = !0, e } function nx(t, e, n) { const r = n.path.split("/"); if (r.length > t.length || "full" === n.pathMatch && (e.hasChildren() || r.length < t.length)) return null; const i = {}; for (let s = 0; s < r.length; s++) { const o = r[s], a = t[s]; if (o.startsWith(":")) i[o.substring(1)] = a; else if (o !== a.path) return null } return { consumed: t.slice(0, r.length), posParams: i } } function rn(t, e) { const n = t ? Object.keys(t) : void 0, r = e ? Object.keys(e) : void 0; if (!n || !r || n.length != r.length) return !1; let i; for (let s = 0; s < n.length; s++)if (i = n[s], !Iv(t[i], e[i])) return !1; return !0 } function Iv(t, e) { if (Array.isArray(t) && Array.isArray(e)) { if (t.length !== e.length) return !1; const n = [...t].sort(), r = [...e].sort(); return n.every((i, s) => r[s] === i) } return t === e } function Av(t) { return Array.prototype.concat.apply([], t) } function Rv(t) { return t.length > 0 ? t[t.length - 1] : null } function Ve(t, e) { for (const n in t) t.hasOwnProperty(n) && e(t[n], n) } function sn(t) { return cm(t) ? t : Uo(t) ? Ue(Promise.resolve(t)) : V(t) } const sx = { exact: function xv(t, e, n) { if (!yr(t.segments, e.segments) || !wa(t.segments, e.segments, n) || t.numberOfChildren !== e.numberOfChildren) return !1; for (const r in e.children) if (!t.children[r] || !xv(t.children[r], e.children[r], n)) return !1; return !0 }, subset: Fv }, Ov = { exact: function ox(t, e) { return rn(t, e) }, subset: function ax(t, e) { return Object.keys(e).length <= Object.keys(t).length && Object.keys(e).every(n => Iv(t[n], e[n])) }, ignored: () => !0 }; function Nv(t, e, n) { return sx[n.paths](t.root, e.root, n.matrixParams) && Ov[n.queryParams](t.queryParams, e.queryParams) && !("exact" === n.fragment && t.fragment !== e.fragment) } function Fv(t, e, n) { return Pv(t, e, e.segments, n) } function Pv(t, e, n, r) { if (t.segments.length > n.length) { const i = t.segments.slice(0, n.length); return !(!yr(i, n) || e.hasChildren() || !wa(i, n, r)) } if (t.segments.length === n.length) { if (!yr(t.segments, n) || !wa(t.segments, n, r)) return !1; for (const i in e.children) if (!t.children[i] || !Fv(t.children[i], e.children[i], r)) return !1; return !0 } { const i = n.slice(0, t.segments.length), s = n.slice(t.segments.length); return !!(yr(t.segments, i) && wa(t.segments, i, r) && t.children[q]) && Pv(t.children[q], e, s, r) } } function wa(t, e, n) { return e.every((r, i) => Ov[n](t[i].parameters, r.parameters)) } class mr { constructor(e, n, r) { this.root = e, this.queryParams = n, this.fragment = r } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = yi(this.queryParams)), this._queryParamMap } toString() { return cx.serialize(this) } } class W { constructor(e, n) { this.segments = e, this.children = n, this.parent = null, Ve(n, (r, i) => r.parent = this) } hasChildren() { return this.numberOfChildren > 0 } get numberOfChildren() { return Object.keys(this.children).length } toString() { return Ma(this) } } class Os { constructor(e, n) { this.path = e, this.parameters = n } get parameterMap() { return this._parameterMap || (this._parameterMap = yi(this.parameters)), this._parameterMap } toString() { return Vv(this) } } function yr(t, e) { return t.length === e.length && t.every((n, r) => n.path === e[r].path) } class kv { } class Lv { parse(e) { const n = new vx(e); return new mr(n.parseRootSegment(), n.parseQueryParams(), n.parseFragment()) } serialize(e) { const n = `/${Ns(e.root, !0)}`, r = function hx(t) { const e = Object.keys(t).map(n => { const r = t[n]; return Array.isArray(r) ? r.map(i => `${Ta(n)}=${Ta(i)}`).join("&") : `${Ta(n)}=${Ta(r)}` }).filter(n => !!n); return e.length ? `?${e.join("&")}` : "" }(e.queryParams); return `${n}${r}${"string" == typeof e.fragment ? `#${function dx(t) { return encodeURI(t) }(e.fragment)}` : ""}` } } const cx = new Lv; function Ma(t) { return t.segments.map(e => Vv(e)).join("/") } function Ns(t, e) { if (!t.hasChildren()) return Ma(t); if (e) { const n = t.children[q] ? Ns(t.children[q], !1) : "", r = []; return Ve(t.children, (i, s) => { s !== q && r.push(`${s}:${Ns(i, !1)}`) }), r.length > 0 ? `${n}(${r.join("//")})` : n } { const n = function ux(t, e) { let n = []; return Ve(t.children, (r, i) => { i === q && (n = n.concat(e(r, i))) }), Ve(t.children, (r, i) => { i !== q && (n = n.concat(e(r, i))) }), n }(t, (r, i) => i === q ? [Ns(t.children[q], !1)] : [`${i}:${Ns(r, !1)}`]); return 1 === Object.keys(t.children).length && null != t.children[q] ? `${Ma(t)}/${n[0]}` : `${Ma(t)}/(${n.join("//")})` } } function jv(t) { return encodeURIComponent(t).replace(/%40/g, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",") } function Ta(t) { return jv(t).replace(/%3B/gi, ";") } function Id(t) { return jv(t).replace(/\(/g, "%28").replace(/\)/g, "%29").replace(/%26/gi, "&") } function Sa(t) { return decodeURIComponent(t) } function Bv(t) { return Sa(t.replace(/\+/g, "%20")) } function Vv(t) { return `${Id(t.path)}${function fx(t) { return Object.keys(t).map(e => `;${Id(e)}=${Id(t[e])}`).join("") }(t.parameters)}` } const px = /^[^\/()?;=#]+/; function Ia(t) { const e = t.match(px); return e ? e[0] : "" } const gx = /^[^=?&#]+/, yx = /^[^&#]+/; class vx { constructor(e) { this.url = e, this.remaining = e } parseRootSegment() { return this.consumeOptional("/"), "" === this.remaining || this.peekStartsWith("?") || this.peekStartsWith("#") ? new W([], {}) : new W([], this.parseChildren()) } parseQueryParams() { const e = {}; if (this.consumeOptional("?")) do { this.parseQueryParam(e) } while (this.consumeOptional("&")); return e } parseFragment() { return this.consumeOptional("#") ? decodeURIComponent(this.remaining) : null } parseChildren() { if ("" === this.remaining) return {}; this.consumeOptional("/"); const e = []; for (this.peekStartsWith("(") || e.push(this.parseSegment()); this.peekStartsWith("/") && !this.peekStartsWith("//") && !this.peekStartsWith("/(");)this.capture("/"), e.push(this.parseSegment()); let n = {}; this.peekStartsWith("/(") && (this.capture("/"), n = this.parseParens(!0)); let r = {}; return this.peekStartsWith("(") && (r = this.parseParens(!1)), (e.length > 0 || Object.keys(n).length > 0) && (r[q] = new W(e, n)), r } parseSegment() { const e = Ia(this.remaining); if ("" === e && this.peekStartsWith(";")) throw new Error(`Empty path url segment cannot have parameters: '${this.remaining}'.`); return this.capture(e), new Os(Sa(e), this.parseMatrixParams()) } parseMatrixParams() { const e = {}; for (; this.consumeOptional(";");)this.parseParam(e); return e } parseParam(e) { const n = Ia(this.remaining); if (!n) return; this.capture(n); let r = ""; if (this.consumeOptional("=")) { const i = Ia(this.remaining); i && (r = i, this.capture(r)) } e[Sa(n)] = Sa(r) } parseQueryParam(e) { const n = function mx(t) { const e = t.match(gx); return e ? e[0] : "" }(this.remaining); if (!n) return; this.capture(n); let r = ""; if (this.consumeOptional("=")) { const o = function _x(t) { const e = t.match(yx); return e ? e[0] : "" }(this.remaining); o && (r = o, this.capture(r)) } const i = Bv(n), s = Bv(r); if (e.hasOwnProperty(i)) { let o = e[i]; Array.isArray(o) || (o = [o], e[i] = o), o.push(s) } else e[i] = s } parseParens(e) { const n = {}; for (this.capture("("); !this.consumeOptional(")") && this.remaining.length > 0;) { const r = Ia(this.remaining), i = this.remaining[r.length]; if ("/" !== i && ")" !== i && ";" !== i) throw new Error(`Cannot parse url '${this.url}'`); let s; r.indexOf(":") > -1 ? (s = r.substr(0, r.indexOf(":")), this.capture(s), this.capture(":")) : e && (s = q); const o = this.parseChildren(); n[s] = 1 === Object.keys(o).length ? o[q] : new W([], o), this.consumeOptional("//") } return n } peekStartsWith(e) { return this.remaining.startsWith(e) } consumeOptional(e) { return !!this.peekStartsWith(e) && (this.remaining = this.remaining.substring(e.length), !0) } capture(e) { if (!this.consumeOptional(e)) throw new Error(`Expected "${e}".`) } } class Uv { constructor(e) { this._root = e } get root() { return this._root.value } parent(e) { const n = this.pathFromRoot(e); return n.length > 1 ? n[n.length - 2] : null } children(e) { const n = Ad(e, this._root); return n ? n.children.map(r => r.value) : [] } firstChild(e) { const n = Ad(e, this._root); return n && n.children.length > 0 ? n.children[0].value : null } siblings(e) { const n = Rd(e, this._root); return n.length < 2 ? [] : n[n.length - 2].children.map(i => i.value).filter(i => i !== e) } pathFromRoot(e) { return Rd(e, this._root).map(n => n.value) } } function Ad(t, e) { if (t === e.value) return e; for (const n of e.children) { const r = Ad(t, n); if (r) return r } return null } function Rd(t, e) { if (t === e.value) return [e]; for (const n of e.children) { const r = Rd(t, n); if (r.length) return r.unshift(e), r } return [] } class wn { constructor(e, n) { this.value = e, this.children = n } toString() { return `TreeNode(${this.value})` } } function _i(t) { const e = {}; return t && t.children.forEach(n => e[n.value.outlet] = n), e } class Hv extends Uv { constructor(e, n) { super(e), this.snapshot = n, Od(this, e) } toString() { return this.snapshot.toString() } } function $v(t, e) { const n = function Dx(t, e) { const o = new Aa([], {}, {}, "", {}, q, e, null, t.root, -1, {}); return new qv("", new wn(o, [])) }(t, e), r = new qt([new Os("", {})]), i = new qt({}), s = new qt({}), o = new qt({}), a = new qt(""), l = new vi(r, i, o, a, s, q, e, n.root); return l.snapshot = n.root, new Hv(new wn(l, []), n) } class vi { constructor(e, n, r, i, s, o, a, l) { this.url = e, this.params = n, this.queryParams = r, this.fragment = i, this.data = s, this.outlet = o, this.component = a, this._futureSnapshot = l } get routeConfig() { return this._futureSnapshot.routeConfig } get root() { return this._routerState.root } get parent() { return this._routerState.parent(this) } get firstChild() { return this._routerState.firstChild(this) } get children() { return this._routerState.children(this) } get pathFromRoot() { return this._routerState.pathFromRoot(this) } get paramMap() { return this._paramMap || (this._paramMap = this.params.pipe(J(e => yi(e)))), this._paramMap } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = this.queryParams.pipe(J(e => yi(e)))), this._queryParamMap } toString() { return this.snapshot ? this.snapshot.toString() : `Future(${this._futureSnapshot})` } } function zv(t, e = "emptyOnly") { const n = t.pathFromRoot; let r = 0; if ("always" !== e) for (r = n.length - 1; r >= 1;) { const i = n[r], s = n[r - 1]; if (i.routeConfig && "" === i.routeConfig.path) r--; else { if (s.component) break; r-- } } return function Ex(t) { return t.reduce((e, n) => ({ params: Object.assign(Object.assign({}, e.params), n.params), data: Object.assign(Object.assign({}, e.data), n.data), resolve: Object.assign(Object.assign({}, e.resolve), n._resolvedData) }), { params: {}, data: {}, resolve: {} }) }(n.slice(r)) } class Aa { constructor(e, n, r, i, s, o, a, l, u, c, d) { this.url = e, this.params = n, this.queryParams = r, this.fragment = i, this.data = s, this.outlet = o, this.component = a, this.routeConfig = l, this._urlSegment = u, this._lastPathIndex = c, this._resolve = d } get root() { return this._routerState.root } get parent() { return this._routerState.parent(this) } get firstChild() { return this._routerState.firstChild(this) } get children() { return this._routerState.children(this) } get pathFromRoot() { return this._routerState.pathFromRoot(this) } get paramMap() { return this._paramMap || (this._paramMap = yi(this.params)), this._paramMap } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = yi(this.queryParams)), this._queryParamMap } toString() { return `Route(url:'${this.url.map(r => r.toString()).join("/")}', path:'${this.routeConfig ? this.routeConfig.path : ""}')` } } class qv extends Uv { constructor(e, n) { super(n), this.url = e, Od(this, n) } toString() { return Gv(this._root) } } function Od(t, e) { e.value._routerState = t, e.children.forEach(n => Od(t, n)) } function Gv(t) { const e = t.children.length > 0 ? ` { ${t.children.map(Gv).join(", ")} } ` : ""; return `${t.value}${e}` } function Nd(t) { if (t.snapshot) { const e = t.snapshot, n = t._futureSnapshot; t.snapshot = n, rn(e.queryParams, n.queryParams) || t.queryParams.next(n.queryParams), e.fragment !== n.fragment && t.fragment.next(n.fragment), rn(e.params, n.params) || t.params.next(n.params), function rx(t, e) { if (t.length !== e.length) return !1; for (let n = 0; n < t.length; ++n)if (!rn(t[n], e[n])) return !1; return !0 }(e.url, n.url) || t.url.next(n.url), rn(e.data, n.data) || t.data.next(n.data) } else t.snapshot = t._futureSnapshot, t.data.next(t._futureSnapshot.data) } function xd(t, e) { const n = rn(t.params, e.params) && function lx(t, e) { return yr(t, e) && t.every((n, r) => rn(n.parameters, e[r].parameters)) }(t.url, e.url); return n && !(!t.parent != !e.parent) && (!t.parent || xd(t.parent, e.parent)) } function xs(t, e, n) { if (n && t.shouldReuseRoute(e.value, n.value.snapshot)) { const r = n.value; r._futureSnapshot = e.value; const i = function bx(t, e, n) { return e.children.map(r => { for (const i of n.children) if (t.shouldReuseRoute(r.value, i.value.snapshot)) return xs(t, r, i); return xs(t, r) }) }(t, e, n); return new wn(r, i) } { if (t.shouldAttach(e.value)) { const s = t.retrieve(e.value); if (null !== s) { const o = s.route; return o.value._futureSnapshot = e.value, o.children = e.children.map(a => xs(t, a)), o } } const r = function wx(t) { return new vi(new qt(t.url), new qt(t.params), new qt(t.queryParams), new qt(t.fragment), new qt(t.data), t.outlet, t.component, t) }(e.value), i = e.children.map(s => xs(t, s)); return new wn(r, i) } } function Ra(t) { return "object" == typeof t && null != t && !t.outlets && !t.segmentPath } function Fs(t) { return "object" == typeof t && null != t && t.outlets } function Fd(t, e, n, r, i) { let s = {}; if (r && Ve(r, (a, l) => { s[l] = Array.isArray(a) ? a.map(u => `${u}`) : `${a}` }), t === e) return new mr(n, s, i); const o = Wv(t, e, n); return new mr(o, s, i) } function Wv(t, e, n) { const r = {}; return Ve(t.children, (i, s) => { r[s] = i === e ? n : Wv(i, e, n) }), new W(t.segments, r) } class Kv { constructor(e, n, r) { if (this.isAbsolute = e, this.numberOfDoubleDots = n, this.commands = r, e && r.length > 0 && Ra(r[0])) throw new Error("Root segment cannot have matrix parameters"); const i = r.find(Fs); if (i && i !== Rv(r)) throw new Error("{outlets:{}} has to be the last command") } toRoot() { return this.isAbsolute && 1 === this.commands.length && "/" == this.commands[0] } } class Pd { constructor(e, n, r) { this.segmentGroup = e, this.processChildren = n, this.index = r } } function Qv(t, e, n) { if (t || (t = new W([], {})), 0 === t.segments.length && t.hasChildren()) return Oa(t, e, n); const r = function Rx(t, e, n) { let r = 0, i = e; const s = { match: !1, pathIndex: 0, commandIndex: 0 }; for (; i < t.segments.length;) { if (r >= n.length) return s; const o = t.segments[i], a = n[r]; if (Fs(a)) break; const l = `${a}`, u = r < n.length - 1 ? n[r + 1] : null; if (i > 0 && void 0 === l) break; if (l && u && "object" == typeof u && void 0 === u.outlets) { if (!Yv(l, u, o)) return s; r += 2 } else { if (!Yv(l, {}, o)) return s; r++ } i++ } return { match: !0, pathIndex: i, commandIndex: r } }(t, e, n), i = n.slice(r.commandIndex); if (r.match && r.pathIndex < t.segments.length) { const s = new W(t.segments.slice(0, r.pathIndex), {}); return s.children[q] = new W(t.segments.slice(r.pathIndex), t.children), Oa(s, 0, i) } return r.match && 0 === i.length ? new W(t.segments, {}) : r.match && !t.hasChildren() ? kd(t, e, n) : r.match ? Oa(t, 0, i) : kd(t, e, n) } function Oa(t, e, n) { if (0 === n.length) return new W(t.segments, {}); { const r = function Ax(t) { return Fs(t[0]) ? t[0].outlets : { [q]: t } }(n), i = {}; return Ve(r, (s, o) => { "string" == typeof s && (s = [s]), null !== s && (i[o] = Qv(t.children[o], e, s)) }), Ve(t.children, (s, o) => { void 0 === r[o] && (i[o] = s) }), new W(t.segments, i) } } function kd(t, e, n) { const r = t.segments.slice(0, e); let i = 0; for (; i < n.length;) { const s = n[i]; if (Fs(s)) { const l = Ox(s.outlets); return new W(r, l) } if (0 === i && Ra(n[0])) { r.push(new Os(t.segments[e].path, Zv(n[0]))), i++; continue } const o = Fs(s) ? s.outlets[q] : `${s}`, a = i < n.length - 1 ? n[i + 1] : null; o && a && Ra(a) ? (r.push(new Os(o, Zv(a))), i += 2) : (r.push(new Os(o, {})), i++) } return new W(r, {}) } function Ox(t) { const e = {}; return Ve(t, (n, r) => { "string" == typeof n && (n = [n]), null !== n && (e[r] = kd(new W([], {}), 0, n)) }), e } function Zv(t) { const e = {}; return Ve(t, (n, r) => e[r] = `${n}`), e } function Yv(t, e, n) { return t == n.path && rn(e, n.parameters) } class xx { constructor(e, n, r, i) { this.routeReuseStrategy = e, this.futureState = n, this.currState = r, this.forwardEvent = i } activate(e) { const n = this.futureState._root, r = this.currState ? this.currState._root : null; this.deactivateChildRoutes(n, r, e), Nd(this.futureState.root), this.activateChildRoutes(n, r, e) } deactivateChildRoutes(e, n, r) { const i = _i(n); e.children.forEach(s => { const o = s.value.outlet; this.deactivateRoutes(s, i[o], r), delete i[o] }), Ve(i, (s, o) => { this.deactivateRouteAndItsChildren(s, r) }) } deactivateRoutes(e, n, r) { const i = e.value, s = n ? n.value : null; if (i === s) if (i.component) { const o = r.getContext(i.outlet); o && this.deactivateChildRoutes(e, n, o.children) } else this.deactivateChildRoutes(e, n, r); else s && this.deactivateRouteAndItsChildren(n, r) } deactivateRouteAndItsChildren(e, n) { e.value.component && this.routeReuseStrategy.shouldDetach(e.value.snapshot) ? this.detachAndStoreRouteSubtree(e, n) : this.deactivateRouteAndOutlet(e, n) } detachAndStoreRouteSubtree(e, n) { const r = n.getContext(e.value.outlet), i = r && e.value.component ? r.children : n, s = _i(e); for (const o of Object.keys(s)) this.deactivateRouteAndItsChildren(s[o], i); if (r && r.outlet) { const o = r.outlet.detach(), a = r.children.onOutletDeactivated(); this.routeReuseStrategy.store(e.value.snapshot, { componentRef: o, route: e, contexts: a }) } } deactivateRouteAndOutlet(e, n) { const r = n.getContext(e.value.outlet), i = r && e.value.component ? r.children : n, s = _i(e); for (const o of Object.keys(s)) this.deactivateRouteAndItsChildren(s[o], i); r && r.outlet && (r.outlet.deactivate(), r.children.onOutletDeactivated(), r.attachRef = null, r.resolver = null, r.route = null) } activateChildRoutes(e, n, r) { const i = _i(n); e.children.forEach(s => { this.activateRoutes(s, i[s.value.outlet], r), this.forwardEvent(new XN(s.value.snapshot)) }), e.children.length && this.forwardEvent(new YN(e.value.snapshot)) } activateRoutes(e, n, r) { const i = e.value, s = n ? n.value : null; if (Nd(i), i === s) if (i.component) { const o = r.getOrCreateContext(i.outlet); this.activateChildRoutes(e, n, o.children) } else this.activateChildRoutes(e, n, r); else if (i.component) { const o = r.getOrCreateContext(i.outlet); if (this.routeReuseStrategy.shouldAttach(i.snapshot)) { const a = this.routeReuseStrategy.retrieve(i.snapshot); this.routeReuseStrategy.store(i.snapshot, null), o.children.onOutletReAttached(a.contexts), o.attachRef = a.componentRef, o.route = a.route.value, o.outlet && o.outlet.attach(a.componentRef, a.route.value), Nd(a.route.value), this.activateChildRoutes(e, null, o.children) } else { const a = function Fx(t) { for (let e = t.parent; e; e = e.parent) { const n = e.routeConfig; if (n && n._loadedConfig) return n._loadedConfig; if (n && n.component) return null } return null }(i.snapshot), l = a ? a.module.componentFactoryResolver : null; o.attachRef = null, o.route = i, o.resolver = l, o.outlet && o.outlet.activateWith(i, l), this.activateChildRoutes(e, null, o.children) } } else this.activateChildRoutes(e, null, r) } } class Ld { constructor(e, n) { this.routes = e, this.module = n } } function Gn(t) { return "function" == typeof t } function _r(t) { return t instanceof mr } const Ps = Symbol("INITIAL_VALUE"); function ks() { return pr(t => PN(t.map(e => e.pipe(wd(1), function BN(...t) { const e = Oi(t); return ke((n, r) => { (e ? bd(t, n, e) : bd(t, n)).subscribe(r) }) }(Ps)))).pipe(Dv((e, n) => { let r = !1; return n.reduce((i, s, o) => i !== Ps ? i : (s === Ps && (r = !0), r || !1 !== s && o !== n.length - 1 && !_r(s) ? i : s), e) }, Ps), gr(e => e !== Ps), J(e => _r(e) ? e : !0 === e), wd(1))) } class Vx { constructor() { this.outlet = null, this.route = null, this.resolver = null, this.children = new Ls, this.attachRef = null } } class Ls { constructor() { this.contexts = new Map } onChildOutletCreated(e, n) { const r = this.getOrCreateContext(e); r.outlet = n, this.contexts.set(e, r) } onChildOutletDestroyed(e) { const n = this.getContext(e); n && (n.outlet = null, n.attachRef = null) } onOutletDeactivated() { const e = this.contexts; return this.contexts = new Map, e } onOutletReAttached(e) { this.contexts = e } getOrCreateContext(e) { let n = this.getContext(e); return n || (n = new Vx, this.contexts.set(e, n)), n } getContext(e) { return this.contexts.get(e) || null } } let jd = (() => { class t { constructor(n, r, i, s, o) { this.parentContexts = n, this.location = r, this.resolver = i, this.changeDetector = o, this.activated = null, this._activatedRoute = null, this.activateEvents = new xe, this.deactivateEvents = new xe, this.attachEvents = new xe, this.detachEvents = new xe, this.name = s || q, n.onChildOutletCreated(this.name, this) } ngOnDestroy() { this.parentContexts.onChildOutletDestroyed(this.name) } ngOnInit() { if (!this.activated) { const n = this.parentContexts.getContext(this.name); n && n.route && (n.attachRef ? this.attach(n.attachRef, n.route) : this.activateWith(n.route, n.resolver || null)) } } get isActivated() { return !!this.activated } get component() { if (!this.activated) throw new Error("Outlet is not activated"); return this.activated.instance } get activatedRoute() { if (!this.activated) throw new Error("Outlet is not activated"); return this._activatedRoute } get activatedRouteData() { return this._activatedRoute ? this._activatedRoute.snapshot.data : {} } detach() { if (!this.activated) throw new Error("Outlet is not activated"); this.location.detach(); const n = this.activated; return this.activated = null, this._activatedRoute = null, this.detachEvents.emit(n.instance), n } attach(n, r) { this.activated = n, this._activatedRoute = r, this.location.insert(n.hostView), this.attachEvents.emit(n.instance) } deactivate() { if (this.activated) { const n = this.component; this.activated.destroy(), this.activated = null, this._activatedRoute = null, this.deactivateEvents.emit(n) } } activateWith(n, r) { if (this.isActivated) throw new Error("Cannot activate an already activated outlet"); this._activatedRoute = n; const o = (r = r || this.resolver).resolveComponentFactory(n._futureSnapshot.routeConfig.component), a = this.parentContexts.getOrCreateContext(this.name).children, l = new Ux(n, a, this.location.injector); this.activated = this.location.createComponent(o, this.location.length, l), this.changeDetector.markForCheck(), this.activateEvents.emit(this.activated.instance) } } return t.\u0275fac = function (n) { return new (n || t)(S(Ls), S(Ht), S(_s), function Hi(t) { return function Wb(t, e) { if ("class" === e) return t.classes; if ("style" === e) return t.styles; const n = t.attrs; if (n) { const r = n.length; let i = 0; for (; i < r;) { const s = n[i]; if (Fh(s)) break; if (0 === s) i += 2; else if ("number" == typeof s) for (i++; i < r && "string" == typeof n[i];)i++; else { if (s === e) return n[i + 1]; i += 2 } } } return null }(be(), t) }("name"), S(ra)) }, t.\u0275dir = Ae({ type: t, selectors: [["router-outlet"]], outputs: { activateEvents: "activate", deactivateEvents: "deactivate", attachEvents: "attach", detachEvents: "detach" }, exportAs: ["outlet"] }), t })(); class Ux { constructor(e, n, r) { this.route = e, this.childContexts = n, this.parent = r } get(e, n) { return e === vi ? this.route : e === Ls ? this.childContexts : this.parent.get(e, n) } } let Jv = (() => { class t { } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275cmp = xt({ type: t, selectors: [["ng-component"]], decls: 1, vars: 0, template: function (n, r) { 1 & n && Bn(0, "router-outlet") }, directives: [jd], encapsulation: 2 }), t })(); function Xv(t, e = "") { for (let n = 0; n < t.length; n++) { const r = t[n]; Hx(r, $x(e, r)) } } function Hx(t, e) { t.children && Xv(t.children, e) } function $x(t, e) { return e ? t || e.path ? t && !e.path ? `${t}/` : !t && e.path ? e.path : `${t}/${e.path}` : "" : t } function Bd(t) { const e = t.children && t.children.map(Bd), n = e ? Object.assign(Object.assign({}, t), { children: e }) : Object.assign({}, t); return !n.component && (e || n.loadChildren) && n.outlet && n.outlet !== q && (n.component = Jv), n } function It(t) { return t.outlet || q } function eD(t, e) { const n = t.filter(r => It(r) === e); return n.push(...t.filter(r => It(r) !== e)), n } const tD = { matched: !1, consumedSegments: [], remainingSegments: [], parameters: {}, positionalParamSegments: {} }; function Na(t, e, n) { var r; if ("" === e.path) return "full" === e.pathMatch && (t.hasChildren() || n.length > 0) ? Object.assign({}, tD) : { matched: !0, consumedSegments: [], remainingSegments: n, parameters: {}, positionalParamSegments: {} }; const s = (e.matcher || nx)(n, t, e); if (!s) return Object.assign({}, tD); const o = {}; Ve(s.posParams, (l, u) => { o[u] = l.path }); const a = s.consumed.length > 0 ? Object.assign(Object.assign({}, o), s.consumed[s.consumed.length - 1].parameters) : o; return { matched: !0, consumedSegments: s.consumed, remainingSegments: n.slice(s.consumed.length), parameters: a, positionalParamSegments: null !== (r = s.posParams) && void 0 !== r ? r : {} } } function xa(t, e, n, r, i = "corrected") { if (n.length > 0 && function Gx(t, e, n) { return n.some(r => Fa(t, e, r) && It(r) !== q) }(t, n, r)) { const o = new W(e, function qx(t, e, n, r) { const i = {}; i[q] = r, r._sourceSegment = t, r._segmentIndexShift = e.length; for (const s of n) if ("" === s.path && It(s) !== q) { const o = new W([], {}); o._sourceSegment = t, o._segmentIndexShift = e.length, i[It(s)] = o } return i }(t, e, r, new W(n, t.children))); return o._sourceSegment = t, o._segmentIndexShift = e.length, { segmentGroup: o, slicedSegments: [] } } if (0 === n.length && function Wx(t, e, n) { return n.some(r => Fa(t, e, r)) }(t, n, r)) { const o = new W(t.segments, function zx(t, e, n, r, i, s) { const o = {}; for (const a of r) if (Fa(t, n, a) && !i[It(a)]) { const l = new W([], {}); l._sourceSegment = t, l._segmentIndexShift = "legacy" === s ? t.segments.length : e.length, o[It(a)] = l } return Object.assign(Object.assign({}, i), o) }(t, e, n, r, t.children, i)); return o._sourceSegment = t, o._segmentIndexShift = e.length, { segmentGroup: o, slicedSegments: n } } const s = new W(t.segments, t.children); return s._sourceSegment = t, s._segmentIndexShift = e.length, { segmentGroup: s, slicedSegments: n } } function Fa(t, e, n) { return (!(t.hasChildren() || e.length > 0) || "full" !== n.pathMatch) && "" === n.path } function nD(t, e, n, r) { return !!(It(t) === r || r !== q && Fa(e, n, t)) && ("**" === t.path || Na(e, t, n).matched) } function rD(t, e, n) { return 0 === e.length && !t.children[n] } class Pa { constructor(e) { this.segmentGroup = e || null } } class iD { constructor(e) { this.urlTree = e } } function js(t) { return Ca(new Pa(t)) } function sD(t) { return Ca(new iD(t)) } class Yx { constructor(e, n, r, i, s) { this.configLoader = n, this.urlSerializer = r, this.urlTree = i, this.config = s, this.allowRedirects = !0, this.ngModule = e.get(_n) } apply() { const e = xa(this.urlTree.root, [], [], this.config).segmentGroup, n = new W(e.segments, e.children); return this.expandSegmentGroup(this.ngModule, this.config, n, q).pipe(J(s => this.createUrlTree(Vd(s), this.urlTree.queryParams, this.urlTree.fragment))).pipe(qn(s => { if (s instanceof iD) return this.allowRedirects = !1, this.match(s.urlTree); throw s instanceof Pa ? this.noMatchError(s) : s })) } match(e) { return this.expandSegmentGroup(this.ngModule, this.config, e.root, q).pipe(J(i => this.createUrlTree(Vd(i), e.queryParams, e.fragment))).pipe(qn(i => { throw i instanceof Pa ? this.noMatchError(i) : i })) } noMatchError(e) { return new Error(`Cannot match any routes. URL Segment: '${e.segmentGroup}'`) } createUrlTree(e, n, r) { const i = e.segments.length > 0 ? new W([], { [q]: e }) : e; return new mr(i, n, r) } expandSegmentGroup(e, n, r, i) { return 0 === r.segments.length && r.hasChildren() ? this.expandChildren(e, n, r).pipe(J(s => new W([], s))) : this.expandSegment(e, r, n, r.segments, i, !0) } expandChildren(e, n, r) { const i = []; for (const s of Object.keys(r.children)) "primary" === s ? i.unshift(s) : i.push(s); return Ue(i).pipe(gi(s => { const o = r.children[s], a = eD(n, s); return this.expandSegmentGroup(e, a, o, s).pipe(J(l => ({ segment: l, outlet: s }))) }), Dv((s, o) => (s[o.outlet] = o.segment, s), {}), function HN(t, e) { const n = arguments.length >= 2; return r => r.pipe(t ? gr((i, s) => t(i, s, r)) : er, Md(1), n ? Cv(e) : Ev(() => new ba)) }()) } expandSegment(e, n, r, i, s, o) { return Ue(r).pipe(gi(a => this.expandSegmentAgainstRoute(e, n, r, a, i, s, o).pipe(qn(u => { if (u instanceof Pa) return V(null); throw u }))), mi(a => !!a), qn((a, l) => { if (a instanceof ba || "EmptyError" === a.name) return rD(n, i, s) ? V(new W([], {})) : js(n); throw a })) } expandSegmentAgainstRoute(e, n, r, i, s, o, a) { return nD(i, n, s, o) ? void 0 === i.redirectTo ? this.matchSegmentAgainstRoute(e, n, i, s, o) : a && this.allowRedirects ? this.expandSegmentAgainstRouteUsingRedirect(e, n, r, i, s, o) : js(n) : js(n) } expandSegmentAgainstRouteUsingRedirect(e, n, r, i, s, o) { return "**" === i.path ? this.expandWildCardWithParamsAgainstRouteUsingRedirect(e, r, i, o) : this.expandRegularSegmentAgainstRouteUsingRedirect(e, n, r, i, s, o) } expandWildCardWithParamsAgainstRouteUsingRedirect(e, n, r, i) { const s = this.applyRedirectCommands([], r.redirectTo, {}); return r.redirectTo.startsWith("/") ? sD(s) : this.lineralizeSegments(r, s).pipe(Ie(o => { const a = new W(o, {}); return this.expandSegment(e, a, n, o, i, !1) })) } expandRegularSegmentAgainstRouteUsingRedirect(e, n, r, i, s, o) { const { matched: a, consumedSegments: l, remainingSegments: u, positionalParamSegments: c } = Na(n, i, s); if (!a) return js(n); const d = this.applyRedirectCommands(l, i.redirectTo, c); return i.redirectTo.startsWith("/") ? sD(d) : this.lineralizeSegments(i, d).pipe(Ie(f => this.expandSegment(e, n, r, f.concat(u), o, !1))) } matchSegmentAgainstRoute(e, n, r, i, s) { if ("**" === r.path) return r.loadChildren ? (r._loadedConfig ? V(r._loadedConfig) : this.configLoader.load(e.injector, r)).pipe(J(d => (r._loadedConfig = d, new W(i, {})))) : V(new W(i, {})); const { matched: o, consumedSegments: a, remainingSegments: l } = Na(n, r, i); return o ? this.getChildConfig(e, r, i).pipe(Ie(c => { const d = c.module, f = c.routes, { segmentGroup: h, slicedSegments: p } = xa(n, a, l, f), g = new W(h.segments, h.children); if (0 === p.length && g.hasChildren()) return this.expandChildren(d, f, g).pipe(J(D => new W(a, D))); if (0 === f.length && 0 === p.length) return V(new W(a, {})); const y = It(r) === s; return this.expandSegment(d, g, f, p, y ? q : s, !0).pipe(J(m => new W(a.concat(m.segments), m.children))) })) : js(n) } getChildConfig(e, n, r) { return n.children ? V(new Ld(n.children, e)) : n.loadChildren ? void 0 !== n._loadedConfig ? V(n._loadedConfig) : this.runCanLoadGuards(e.injector, n, r).pipe(Ie(i => i ? this.configLoader.load(e.injector, n).pipe(J(s => (n._loadedConfig = s, s))) : function Qx(t) { return Ca(Sd(`Cannot load children because the guard of the route "path: '${t.path}'" returned false`)) }(n))) : V(new Ld([], e)) } runCanLoadGuards(e, n, r) { const i = n.canLoad; return i && 0 !== i.length ? V(i.map(o => { const a = e.get(o); let l; if (function kx(t) { return t && Gn(t.canLoad) }(a)) l = a.canLoad(n, r); else { if (!Gn(a)) throw new Error("Invalid CanLoad guard"); l = a(n, r) } return sn(l) })).pipe(ks(), ft(o => { if (!_r(o)) return; const a = Sd(`Redirecting to "${this.urlSerializer.serialize(o)}"`); throw a.url = o, a }), J(o => !0 === o)) : V(!0) } lineralizeSegments(e, n) { let r = [], i = n.root; for (; ;) { if (r = r.concat(i.segments), 0 === i.numberOfChildren) return V(r); if (i.numberOfChildren > 1 || !i.children[q]) return Ca(new Error(`Only absolute redirects can have named outlets. redirectTo: '${e.redirectTo}'`)); i = i.children[q] } } applyRedirectCommands(e, n, r) { return this.applyRedirectCreatreUrlTree(n, this.urlSerializer.parse(n), e, r) } applyRedirectCreatreUrlTree(e, n, r, i) { const s = this.createSegmentGroup(e, n.root, r, i); return new mr(s, this.createQueryParams(n.queryParams, this.urlTree.queryParams), n.fragment) } createQueryParams(e, n) { const r = {}; return Ve(e, (i, s) => { if ("string" == typeof i && i.startsWith(":")) { const a = i.substring(1); r[s] = n[a] } else r[s] = i }), r } createSegmentGroup(e, n, r, i) { const s = this.createSegments(e, n.segments, r, i); let o = {}; return Ve(n.children, (a, l) => { o[l] = this.createSegmentGroup(e, a, r, i) }), new W(s, o) } createSegments(e, n, r, i) { return n.map(s => s.path.startsWith(":") ? this.findPosParam(e, s, i) : this.findOrReturn(s, r)) } findPosParam(e, n, r) { const i = r[n.path.substring(1)]; if (!i) throw new Error(`Cannot redirect to '${e}'. Cannot find '${n.path}'.`); return i } findOrReturn(e, n) { let r = 0; for (const i of n) { if (i.path === e.path) return n.splice(r), i; r++ } return e } } function Vd(t) { const e = {}; for (const r of Object.keys(t.children)) { const s = Vd(t.children[r]); (s.segments.length > 0 || s.hasChildren()) && (e[r] = s) } return function Jx(t) { if (1 === t.numberOfChildren && t.children[q]) { const e = t.children[q]; return new W(t.segments.concat(e.segments), e.children) } return t }(new W(t.segments, e)) } class oD { constructor(e) { this.path = e, this.route = this.path[this.path.length - 1] } } class ka { constructor(e, n) { this.component = e, this.route = n } } function eF(t, e, n) { const r = t._root; return Bs(r, e ? e._root : null, n, [r.value]) } function La(t, e, n) { const r = function nF(t) { if (!t) return null; for (let e = t.parent; e; e = e.parent) { const n = e.routeConfig; if (n && n._loadedConfig) return n._loadedConfig } return null }(e); return (r ? r.module.injector : n).get(t) } function Bs(t, e, n, r, i = { canDeactivateChecks: [], canActivateChecks: [] }) { const s = _i(e); return t.children.forEach(o => { (function rF(t, e, n, r, i = { canDeactivateChecks: [], canActivateChecks: [] }) { const s = t.value, o = e ? e.value : null, a = n ? n.getContext(t.value.outlet) : null; if (o && s.routeConfig === o.routeConfig) { const l = function iF(t, e, n) { if ("function" == typeof n) return n(t, e); switch (n) { case "pathParamsChange": return !yr(t.url, e.url); case "pathParamsOrQueryParamsChange": return !yr(t.url, e.url) || !rn(t.queryParams, e.queryParams); case "always": return !0; case "paramsOrQueryParamsChange": return !xd(t, e) || !rn(t.queryParams, e.queryParams); default: return !xd(t, e) } }(o, s, s.routeConfig.runGuardsAndResolvers); l ? i.canActivateChecks.push(new oD(r)) : (s.data = o.data, s._resolvedData = o._resolvedData), Bs(t, e, s.component ? a ? a.children : null : n, r, i), l && a && a.outlet && a.outlet.isActivated && i.canDeactivateChecks.push(new ka(a.outlet.component, o)) } else o && Vs(e, a, i), i.canActivateChecks.push(new oD(r)), Bs(t, null, s.component ? a ? a.children : null : n, r, i) })(o, s[o.value.outlet], n, r.concat([o.value]), i), delete s[o.value.outlet] }), Ve(s, (o, a) => Vs(o, n.getContext(a), i)), i } function Vs(t, e, n) { const r = _i(t), i = t.value; Ve(r, (s, o) => { Vs(s, i.component ? e ? e.children.getContext(o) : null : e, n) }), n.canDeactivateChecks.push(new ka(i.component && e && e.outlet && e.outlet.isActivated ? e.outlet.component : null, i)) } class hF { } function aD(t) { return new ye(e => e.error(t)) } class gF { constructor(e, n, r, i, s, o) { this.rootComponentType = e, this.config = n, this.urlTree = r, this.url = i, this.paramsInheritanceStrategy = s, this.relativeLinkResolution = o } recognize() { const e = xa(this.urlTree.root, [], [], this.config.filter(o => void 0 === o.redirectTo), this.relativeLinkResolution).segmentGroup, n = this.processSegmentGroup(this.config, e, q); if (null === n) return null; const r = new Aa([], Object.freeze({}), Object.freeze(Object.assign({}, this.urlTree.queryParams)), this.urlTree.fragment, {}, q, this.rootComponentType, null, this.urlTree.root, -1, {}), i = new wn(r, n), s = new qv(this.url, i); return this.inheritParamsAndData(s._root), s } inheritParamsAndData(e) { const n = e.value, r = zv(n, this.paramsInheritanceStrategy); n.params = Object.freeze(r.params), n.data = Object.freeze(r.data), e.children.forEach(i => this.inheritParamsAndData(i)) } processSegmentGroup(e, n, r) { return 0 === n.segments.length && n.hasChildren() ? this.processChildren(e, n) : this.processSegment(e, n, n.segments, r) } processChildren(e, n) { const r = []; for (const s of Object.keys(n.children)) { const o = n.children[s], a = eD(e, s), l = this.processSegmentGroup(a, o, s); if (null === l) return null; r.push(...l) } const i = lD(r); return function mF(t) { t.sort((e, n) => e.value.outlet === q ? -1 : n.value.outlet === q ? 1 : e.value.outlet.localeCompare(n.value.outlet)) }(i), i } processSegment(e, n, r, i) { for (const s of e) { const o = this.processSegmentAgainstRoute(s, n, r, i); if (null !== o) return o } return rD(n, r, i) ? [] : null } processSegmentAgainstRoute(e, n, r, i) { if (e.redirectTo || !nD(e, n, r, i)) return null; let s, o = [], a = []; if ("**" === e.path) { const h = r.length > 0 ? Rv(r).parameters : {}; s = new Aa(r, h, Object.freeze(Object.assign({}, this.urlTree.queryParams)), this.urlTree.fragment, dD(e), It(e), e.component, e, uD(n), cD(n) + r.length, fD(e)) } else { const h = Na(n, e, r); if (!h.matched) return null; o = h.consumedSegments, a = h.remainingSegments, s = new Aa(o, h.parameters, Object.freeze(Object.assign({}, this.urlTree.queryParams)), this.urlTree.fragment, dD(e), It(e), e.component, e, uD(n), cD(n) + o.length, fD(e)) } const l = function yF(t) { return t.children ? t.children : t.loadChildren ? t._loadedConfig.routes : [] }(e), { segmentGroup: u, slicedSegments: c } = xa(n, o, a, l.filter(h => void 0 === h.redirectTo), this.relativeLinkResolution); if (0 === c.length && u.hasChildren()) { const h = this.processChildren(l, u); return null === h ? null : [new wn(s, h)] } if (0 === l.length && 0 === c.length) return [new wn(s, [])]; const d = It(e) === i, f = this.processSegment(l, u, c, d ? q : i); return null === f ? null : [new wn(s, f)] } } function _F(t) { const e = t.value.routeConfig; return e && "" === e.path && void 0 === e.redirectTo } function lD(t) { const e = [], n = new Set; for (const r of t) { if (!_F(r)) { e.push(r); continue } const i = e.find(s => r.value.routeConfig === s.value.routeConfig); void 0 !== i ? (i.children.push(...r.children), n.add(i)) : e.push(r) } for (const r of n) { const i = lD(r.children); e.push(new wn(r.value, i)) } return e.filter(r => !n.has(r)) } function uD(t) { let e = t; for (; e._sourceSegment;)e = e._sourceSegment; return e } function cD(t) { let e = t, n = e._segmentIndexShift ? e._segmentIndexShift : 0; for (; e._sourceSegment;)e = e._sourceSegment, n += e._segmentIndexShift ? e._segmentIndexShift : 0; return n - 1 } function dD(t) { return t.data || {} } function fD(t) { return t.resolve || {} } function hD(t) { return [...Object.keys(t), ...Object.getOwnPropertySymbols(t)] } function Ud(t) { return pr(e => { const n = t(e); return n ? Ue(n).pipe(J(() => e)) : V(e) }) } class TF extends class MF { shouldDetach(e) { return !1 } store(e, n) { } shouldAttach(e) { return !1 } retrieve(e) { return null } shouldReuseRoute(e, n) { return e.routeConfig === n.routeConfig } }{ } const Hd = new O("ROUTES"); class pD { constructor(e, n, r, i) { this.injector = e, this.compiler = n, this.onLoadStartListener = r, this.onLoadEndListener = i } load(e, n) { if (n._loader$) return n._loader$; this.onLoadStartListener && this.onLoadStartListener(n); const i = this.loadModuleFactory(n.loadChildren).pipe(J(s => { this.onLoadEndListener && this.onLoadEndListener(n); const o = s.create(e); return new Ld(Av(o.injector.get(Hd, void 0, P.Self | P.Optional)).map(Bd), o) }), qn(s => { throw n._loader$ = void 0, s })); return n._loader$ = new jN(i, () => new ln).pipe(vv()), n._loader$ } loadModuleFactory(e) { return sn(e()).pipe(Ie(n => n instanceof xy ? V(n) : Ue(this.compiler.compileModuleAsync(n)))) } } class IF { shouldProcessUrl(e) { return !0 } extract(e) { return e } merge(e, n) { return e } } function AF(t) { throw t } function RF(t, e, n) { return e.parse("/") } function gD(t, e) { return V(null) } const OF = { paths: "exact", fragment: "ignored", matrixParams: "ignored", queryParams: "exact" }, NF = { paths: "subset", fragment: "ignored", matrixParams: "ignored", queryParams: "subset" }; let Ye = (() => { class t { constructor(n, r, i, s, o, a, l) { this.rootComponentType = n, this.urlSerializer = r, this.rootContexts = i, this.location = s, this.config = l, this.lastSuccessfulNavigation = null, this.currentNavigation = null, this.disposed = !1, this.navigationId = 0, this.currentPageId = 0, this.isNgZoneEnabled = !1, this.events = new ln, this.errorHandler = AF, this.malformedUriErrorHandler = RF, this.navigated = !1, this.lastSuccessfulId = -1, this.hooks = { beforePreactivation: gD, afterPreactivation: gD }, this.urlHandlingStrategy = new IF, this.routeReuseStrategy = new TF, this.onSameUrlNavigation = "ignore", this.paramsInheritanceStrategy = "emptyOnly", this.urlUpdateStrategy = "deferred", this.relativeLinkResolution = "corrected", this.canceledNavigationResolution = "replace", this.ngModule = o.get(_n), this.console = o.get(AA); const d = o.get(Te); this.isNgZoneEnabled = d instanceof Te && Te.isInAngularZone(), this.resetConfig(l), this.currentUrlTree = function ix() { return new mr(new W([], {}), {}, null) }(), this.rawUrlTree = this.currentUrlTree, this.browserUrlTree = this.currentUrlTree, this.configLoader = new pD(o, a, f => this.triggerEvent(new wv(f)), f => this.triggerEvent(new Mv(f))), this.routerState = $v(this.currentUrlTree, this.rootComponentType), this.transitions = new qt({ id: 0, targetPageId: 0, currentUrlTree: this.currentUrlTree, currentRawUrl: this.currentUrlTree, extractedUrl: this.urlHandlingStrategy.extract(this.currentUrlTree), urlAfterRedirects: this.urlHandlingStrategy.extract(this.currentUrlTree), rawUrl: this.currentUrlTree, extras: {}, resolve: null, reject: null, promise: Promise.resolve(!0), source: "imperative", restoredState: null, currentSnapshot: this.routerState.snapshot, targetSnapshot: null, currentRouterState: this.routerState, targetRouterState: null, guards: { canActivateChecks: [], canDeactivateChecks: [] }, guardsResult: null }), this.navigations = this.setupNavigations(this.transitions), this.processNavigations() } get browserPageId() { var n; return null === (n = this.location.getState()) || void 0 === n ? void 0 : n.\u0275routerPageId } setupNavigations(n) { const r = this.events; return n.pipe(gr(i => 0 !== i.id), J(i => Object.assign(Object.assign({}, i), { extractedUrl: this.urlHandlingStrategy.extract(i.rawUrl) })), pr(i => { let s = !1, o = !1; return V(i).pipe(ft(a => { this.currentNavigation = { id: a.id, initialUrl: a.currentRawUrl, extractedUrl: a.extractedUrl, trigger: a.source, extras: a.extras, previousNavigation: this.lastSuccessfulNavigation ? Object.assign(Object.assign({}, this.lastSuccessfulNavigation), { previousNavigation: null }) : null } }), pr(a => { const l = this.browserUrlTree.toString(), u = !this.navigated || a.extractedUrl.toString() !== l || l !== this.currentUrlTree.toString(); if (("reload" === this.onSameUrlNavigation || u) && this.urlHandlingStrategy.shouldProcessUrl(a.rawUrl)) return mD(a.source) && (this.browserUrlTree = a.extractedUrl), V(a).pipe(pr(d => { const f = this.transitions.getValue(); return r.next(new Td(d.id, this.serializeUrl(d.extractedUrl), d.source, d.restoredState)), f !== this.transitions.getValue() ? cn : Promise.resolve(d) }), function Xx(t, e, n, r) { return pr(i => function Zx(t, e, n, r, i) { return new Yx(t, e, n, r, i).apply() }(t, e, n, i.extractedUrl, r).pipe(J(s => Object.assign(Object.assign({}, i), { urlAfterRedirects: s })))) }(this.ngModule.injector, this.configLoader, this.urlSerializer, this.config), ft(d => { this.currentNavigation = Object.assign(Object.assign({}, this.currentNavigation), { finalUrl: d.urlAfterRedirects }) }), function vF(t, e, n, r, i) { return Ie(s => function pF(t, e, n, r, i = "emptyOnly", s = "legacy") { try { const o = new gF(t, e, n, r, i, s).recognize(); return null === o ? aD(new hF) : V(o) } catch (o) { return aD(o) } }(t, e, s.urlAfterRedirects, n(s.urlAfterRedirects), r, i).pipe(J(o => Object.assign(Object.assign({}, s), { targetSnapshot: o })))) }(this.rootComponentType, this.config, d => this.serializeUrl(d), this.paramsInheritanceStrategy, this.relativeLinkResolution), ft(d => { if ("eager" === this.urlUpdateStrategy) { if (!d.extras.skipLocationChange) { const h = this.urlHandlingStrategy.merge(d.urlAfterRedirects, d.rawUrl); this.setBrowserUrl(h, d) } this.browserUrlTree = d.urlAfterRedirects } const f = new qN(d.id, this.serializeUrl(d.extractedUrl), this.serializeUrl(d.urlAfterRedirects), d.targetSnapshot); r.next(f) })); if (u && this.rawUrlTree && this.urlHandlingStrategy.shouldProcessUrl(this.rawUrlTree)) { const { id: f, extractedUrl: h, source: p, restoredState: g, extras: y } = a, _ = new Td(f, this.serializeUrl(h), p, g); r.next(_); const m = $v(h, this.rootComponentType).snapshot; return V(Object.assign(Object.assign({}, a), { targetSnapshot: m, urlAfterRedirects: h, extras: Object.assign(Object.assign({}, y), { skipLocationChange: !1, replaceUrl: !1 }) })) } return this.rawUrlTree = a.rawUrl, a.resolve(null), cn }), Ud(a => { const { targetSnapshot: l, id: u, extractedUrl: c, rawUrl: d, extras: { skipLocationChange: f, replaceUrl: h } } = a; return this.hooks.beforePreactivation(l, { navigationId: u, appliedUrlTree: c, rawUrlTree: d, skipLocationChange: !!f, replaceUrl: !!h }) }), ft(a => { const l = new GN(a.id, this.serializeUrl(a.extractedUrl), this.serializeUrl(a.urlAfterRedirects), a.targetSnapshot); this.triggerEvent(l) }), J(a => Object.assign(Object.assign({}, a), { guards: eF(a.targetSnapshot, a.currentSnapshot, this.rootContexts) })), function sF(t, e) { return Ie(n => { const { targetSnapshot: r, currentSnapshot: i, guards: { canActivateChecks: s, canDeactivateChecks: o } } = n; return 0 === o.length && 0 === s.length ? V(Object.assign(Object.assign({}, n), { guardsResult: !0 })) : function oF(t, e, n, r) { return Ue(t).pipe(Ie(i => function fF(t, e, n, r, i) { const s = e && e.routeConfig ? e.routeConfig.canDeactivate : null; return s && 0 !== s.length ? V(s.map(a => { const l = La(a, e, i); let u; if (function Bx(t) { return t && Gn(t.canDeactivate) }(l)) u = sn(l.canDeactivate(t, e, n, r)); else { if (!Gn(l)) throw new Error("Invalid CanDeactivate guard"); u = sn(l(t, e, n, r)) } return u.pipe(mi()) })).pipe(ks()) : V(!0) }(i.component, i.route, n, e, r)), mi(i => !0 !== i, !0)) }(o, r, i, t).pipe(Ie(a => a && function Px(t) { return "boolean" == typeof t }(a) ? function aF(t, e, n, r) { return Ue(e).pipe(gi(i => bd(function uF(t, e) { return null !== t && e && e(new ZN(t)), V(!0) }(i.route.parent, r), function lF(t, e) { return null !== t && e && e(new JN(t)), V(!0) }(i.route, r), function dF(t, e, n) { const r = e[e.length - 1], s = e.slice(0, e.length - 1).reverse().map(o => function tF(t) { const e = t.routeConfig ? t.routeConfig.canActivateChild : null; return e && 0 !== e.length ? { node: t, guards: e } : null }(o)).filter(o => null !== o).map(o => _v(() => V(o.guards.map(l => { const u = La(l, o.node, n); let c; if (function jx(t) { return t && Gn(t.canActivateChild) }(u)) c = sn(u.canActivateChild(r, t)); else { if (!Gn(u)) throw new Error("Invalid CanActivateChild guard"); c = sn(u(r, t)) } return c.pipe(mi()) })).pipe(ks()))); return V(s).pipe(ks()) }(t, i.path, n), function cF(t, e, n) { const r = e.routeConfig ? e.routeConfig.canActivate : null; if (!r || 0 === r.length) return V(!0); const i = r.map(s => _v(() => { const o = La(s, e, n); let a; if (function Lx(t) { return t && Gn(t.canActivate) }(o)) a = sn(o.canActivate(e, t)); else { if (!Gn(o)) throw new Error("Invalid CanActivate guard"); a = sn(o(e, t)) } return a.pipe(mi()) })); return V(i).pipe(ks()) }(t, i.route, n))), mi(i => !0 !== i, !0)) }(r, s, t, e) : V(a)), J(a => Object.assign(Object.assign({}, n), { guardsResult: a }))) }) }(this.ngModule.injector, a => this.triggerEvent(a)), ft(a => { if (_r(a.guardsResult)) { const u = Sd(`Redirecting to "${this.serializeUrl(a.guardsResult)}"`); throw u.url = a.guardsResult, u } const l = new WN(a.id, this.serializeUrl(a.extractedUrl), this.serializeUrl(a.urlAfterRedirects), a.targetSnapshot, !!a.guardsResult); this.triggerEvent(l) }), gr(a => !!a.guardsResult || (this.restoreHistory(a), this.cancelNavigationTransition(a, ""), !1)), Ud(a => { if (a.guards.canActivateChecks.length) return V(a).pipe(ft(l => { const u = new KN(l.id, this.serializeUrl(l.extractedUrl), this.serializeUrl(l.urlAfterRedirects), l.targetSnapshot); this.triggerEvent(u) }), pr(l => { let u = !1; return V(l).pipe(function DF(t, e) { return Ie(n => { const { targetSnapshot: r, guards: { canActivateChecks: i } } = n; if (!i.length) return V(n); let s = 0; return Ue(i).pipe(gi(o => function EF(t, e, n, r) { return function CF(t, e, n, r) { const i = hD(t); if (0 === i.length) return V({}); const s = {}; return Ue(i).pipe(Ie(o => function bF(t, e, n, r) { const i = La(t, e, r); return sn(i.resolve ? i.resolve(e, n) : i(e, n)) }(t[o], e, n, r).pipe(ft(a => { s[o] = a }))), Md(1), Ie(() => hD(s).length === i.length ? V(s) : cn)) }(t._resolve, t, e, r).pipe(J(s => (t._resolvedData = s, t.data = Object.assign(Object.assign({}, t.data), zv(t, n).resolve), null))) }(o.route, r, t, e)), ft(() => s++), Md(1), Ie(o => s === i.length ? V(n) : cn)) }) }(this.paramsInheritanceStrategy, this.ngModule.injector), ft({ next: () => u = !0, complete: () => { u || (this.restoreHistory(l), this.cancelNavigationTransition(l, "At least one route resolver didn't emit any value.")) } })) }), ft(l => { const u = new QN(l.id, this.serializeUrl(l.extractedUrl), this.serializeUrl(l.urlAfterRedirects), l.targetSnapshot); this.triggerEvent(u) })) }), Ud(a => { const { targetSnapshot: l, id: u, extractedUrl: c, rawUrl: d, extras: { skipLocationChange: f, replaceUrl: h } } = a; return this.hooks.afterPreactivation(l, { navigationId: u, appliedUrlTree: c, rawUrlTree: d, skipLocationChange: !!f, replaceUrl: !!h }) }), J(a => { const l = function Cx(t, e, n) { const r = xs(t, e._root, n ? n._root : void 0); return new Hv(r, e) }(this.routeReuseStrategy, a.targetSnapshot, a.currentRouterState); return Object.assign(Object.assign({}, a), { targetRouterState: l }) }), ft(a => { this.currentUrlTree = a.urlAfterRedirects, this.rawUrlTree = this.urlHandlingStrategy.merge(a.urlAfterRedirects, a.rawUrl), this.routerState = a.targetRouterState, "deferred" === this.urlUpdateStrategy && (a.extras.skipLocationChange || this.setBrowserUrl(this.rawUrlTree, a), this.browserUrlTree = a.urlAfterRedirects) }), ((t, e, n) => J(r => (new xx(e, r.targetRouterState, r.currentRouterState, n).activate(t), r)))(this.rootContexts, this.routeReuseStrategy, a => this.triggerEvent(a)), ft({ next() { s = !0 }, complete() { s = !0 } }), function $N(t) { return ke((e, n) => { try { e.subscribe(n) } finally { n.add(t) } }) }(() => { var a; s || o || this.cancelNavigationTransition(i, `Navigation ID ${i.id} is not equal to the current navigation id ${this.navigationId}`), (null === (a = this.currentNavigation) || void 0 === a ? void 0 : a.id) === i.id && (this.currentNavigation = null) }), qn(a => { if (o = !0, function tx(t) { return t && t[Sv] }(a)) { const l = _r(a.url); l || (this.navigated = !0, this.restoreHistory(i, !0)); const u = new bv(i.id, this.serializeUrl(i.extractedUrl), a.message); r.next(u), l ? setTimeout(() => { const c = this.urlHandlingStrategy.merge(a.url, this.rawUrlTree), d = { skipLocationChange: i.extras.skipLocationChange, replaceUrl: "eager" === this.urlUpdateStrategy || mD(i.source) }; this.scheduleNavigation(c, "imperative", null, d, { resolve: i.resolve, reject: i.reject, promise: i.promise }) }, 0) : i.resolve(!1) } else { this.restoreHistory(i, !0); const l = new zN(i.id, this.serializeUrl(i.extractedUrl), a); r.next(l); try { i.resolve(this.errorHandler(a)) } catch (u) { i.reject(u) } } return cn })) })) } resetRootComponentType(n) { this.rootComponentType = n, this.routerState.root.component = this.rootComponentType } setTransition(n) { this.transitions.next(Object.assign(Object.assign({}, this.transitions.value), n)) } initialNavigation() { this.setUpLocationChangeListener(), 0 === this.navigationId && this.navigateByUrl(this.location.path(!0), { replaceUrl: !0 }) } setUpLocationChangeListener() { this.locationSubscription || (this.locationSubscription = this.location.subscribe(n => { const r = "popstate" === n.type ? "popstate" : "hashchange"; "popstate" === r && setTimeout(() => { var i; const s = { replaceUrl: !0 }, o = (null === (i = n.state) || void 0 === i ? void 0 : i.navigationId) ? n.state : null; if (o) { const l = Object.assign({}, o); delete l.navigationId, delete l.\u0275routerPageId, 0 !== Object.keys(l).length && (s.state = l) } const a = this.parseUrl(n.url); this.scheduleNavigation(a, r, o, s) }, 0) })) } get url() { return this.serializeUrl(this.currentUrlTree) } getCurrentNavigation() { return this.currentNavigation } triggerEvent(n) { this.events.next(n) } resetConfig(n) { Xv(n), this.config = n.map(Bd), this.navigated = !1, this.lastSuccessfulId = -1 } ngOnDestroy() { this.dispose() } dispose() { this.transitions.complete(), this.locationSubscription && (this.locationSubscription.unsubscribe(), this.locationSubscription = void 0), this.disposed = !0 } createUrlTree(n, r = {}) { const { relativeTo: i, queryParams: s, fragment: o, queryParamsHandling: a, preserveFragment: l } = r, u = i || this.routerState.root, c = l ? this.currentUrlTree.fragment : o; let d = null; switch (a) { case "merge": d = Object.assign(Object.assign({}, this.currentUrlTree.queryParams), s); break; case "preserve": d = this.currentUrlTree.queryParams; break; default: d = s || null }return null !== d && (d = this.removeEmptyProps(d)), function Mx(t, e, n, r, i) { if (0 === n.length) return Fd(e.root, e.root, e.root, r, i); const s = function Tx(t) { if ("string" == typeof t[0] && 1 === t.length && "/" === t[0]) return new Kv(!0, 0, t); let e = 0, n = !1; const r = t.reduce((i, s, o) => { if ("object" == typeof s && null != s) { if (s.outlets) { const a = {}; return Ve(s.outlets, (l, u) => { a[u] = "string" == typeof l ? l.split("/") : l }), [...i, { outlets: a }] } if (s.segmentPath) return [...i, s.segmentPath] } return "string" != typeof s ? [...i, s] : 0 === o ? (s.split("/").forEach((a, l) => { 0 == l && "." === a || (0 == l && "" === a ? n = !0 : ".." === a ? e++ : "" != a && i.push(a)) }), i) : [...i, s] }, []); return new Kv(n, e, r) }(n); if (s.toRoot()) return Fd(e.root, e.root, new W([], {}), r, i); const o = function Sx(t, e, n) { if (t.isAbsolute) return new Pd(e.root, !0, 0); if (-1 === n.snapshot._lastPathIndex) { const s = n.snapshot._urlSegment; return new Pd(s, s === e.root, 0) } const r = Ra(t.commands[0]) ? 0 : 1; return function Ix(t, e, n) { let r = t, i = e, s = n; for (; s > i;) { if (s -= i, r = r.parent, !r) throw new Error("Invalid number of '../'"); i = r.segments.length } return new Pd(r, !1, i - s) }(n.snapshot._urlSegment, n.snapshot._lastPathIndex + r, t.numberOfDoubleDots) }(s, e, t), a = o.processChildren ? Oa(o.segmentGroup, o.index, s.commands) : Qv(o.segmentGroup, o.index, s.commands); return Fd(e.root, o.segmentGroup, a, r, i) }(u, this.currentUrlTree, n, d, null != c ? c : null) } navigateByUrl(n, r = { skipLocationChange: !1 }) { const i = _r(n) ? n : this.parseUrl(n), s = this.urlHandlingStrategy.merge(i, this.rawUrlTree); return this.scheduleNavigation(s, "imperative", null, r) } navigate(n, r = { skipLocationChange: !1 }) { return function xF(t) { for (let e = 0; e < t.length; e++) { const n = t[e]; if (null == n) throw new Error(`The requested path contains ${n} segment at index ${e}`) } }(n), this.navigateByUrl(this.createUrlTree(n, r), r) } serializeUrl(n) { return this.urlSerializer.serialize(n) } parseUrl(n) { let r; try { r = this.urlSerializer.parse(n) } catch (i) { r = this.malformedUriErrorHandler(i, this.urlSerializer, n) } return r } isActive(n, r) { let i; if (i = !0 === r ? Object.assign({}, OF) : !1 === r ? Object.assign({}, NF) : r, _r(n)) return Nv(this.currentUrlTree, n, i); const s = this.parseUrl(n); return Nv(this.currentUrlTree, s, i) } removeEmptyProps(n) { return Object.keys(n).reduce((r, i) => { const s = n[i]; return null != s && (r[i] = s), r }, {}) } processNavigations() { this.navigations.subscribe(n => { this.navigated = !0, this.lastSuccessfulId = n.id, this.currentPageId = n.targetPageId, this.events.next(new Rs(n.id, this.serializeUrl(n.extractedUrl), this.serializeUrl(this.currentUrlTree))), this.lastSuccessfulNavigation = this.currentNavigation, n.resolve(!0) }, n => { this.console.warn(`Unhandled Navigation Error: ${n}`) }) } scheduleNavigation(n, r, i, s, o) { var a, l; if (this.disposed) return Promise.resolve(!1); let u, c, d; o ? (u = o.resolve, c = o.reject, d = o.promise) : d = new Promise((p, g) => { u = p, c = g }); const f = ++this.navigationId; let h; return "computed" === this.canceledNavigationResolution ? (0 === this.currentPageId && (i = this.location.getState()), h = i && i.\u0275routerPageId ? i.\u0275routerPageId : s.replaceUrl || s.skipLocationChange ? null !== (a = this.browserPageId) && void 0 !== a ? a : 0 : (null !== (l = this.browserPageId) && void 0 !== l ? l : 0) + 1) : h = 0, this.setTransition({ id: f, targetPageId: h, source: r, restoredState: i, currentUrlTree: this.currentUrlTree, currentRawUrl: this.rawUrlTree, rawUrl: n, extras: s, resolve: u, reject: c, promise: d, currentSnapshot: this.routerState.snapshot, currentRouterState: this.routerState }), d.catch(p => Promise.reject(p)) } setBrowserUrl(n, r) { const i = this.urlSerializer.serialize(n), s = Object.assign(Object.assign({}, r.extras.state), this.generateNgRouterState(r.id, r.targetPageId)); this.location.isCurrentPathEqualTo(i) || r.extras.replaceUrl ? this.location.replaceState(i, "", s) : this.location.go(i, "", s) } restoreHistory(n, r = !1) { var i, s; if ("computed" === this.canceledNavigationResolution) { const o = this.currentPageId - n.targetPageId; "popstate" !== n.source && "eager" !== this.urlUpdateStrategy && this.currentUrlTree !== (null === (i = this.currentNavigation) || void 0 === i ? void 0 : i.finalUrl) || 0 === o ? this.currentUrlTree === (null === (s = this.currentNavigation) || void 0 === s ? void 0 : s.finalUrl) && 0 === o && (this.resetState(n), this.browserUrlTree = n.currentUrlTree, this.resetUrlToCurrentUrlTree()) : this.location.historyGo(o) } else "replace" === this.canceledNavigationResolution && (r && this.resetState(n), this.resetUrlToCurrentUrlTree()) } resetState(n) { this.routerState = n.currentRouterState, this.currentUrlTree = n.currentUrlTree, this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, n.rawUrl) } resetUrlToCurrentUrlTree() { this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree), "", this.generateNgRouterState(this.lastSuccessfulId, this.currentPageId)) } cancelNavigationTransition(n, r) { const i = new bv(n.id, this.serializeUrl(n.extractedUrl), r); this.triggerEvent(i), n.resolve(!1) } generateNgRouterState(n, r) { return "computed" === this.canceledNavigationResolution ? { navigationId: n, \u0275routerPageId: r } : { navigationId: n } } } return t.\u0275fac = function (n) { ac() }, t.\u0275prov = F({ token: t, factory: t.\u0275fac }), t })(); function mD(t) { return "imperative" !== t } class yD { } class _D { preload(e, n) { return V(null) } } let vD = (() => { class t { constructor(n, r, i, s) { this.router = n, this.injector = i, this.preloadingStrategy = s, this.loader = new pD(i, r, l => n.triggerEvent(new wv(l)), l => n.triggerEvent(new Mv(l))) } setUpPreloading() { this.subscription = this.router.events.pipe(gr(n => n instanceof Rs), gi(() => this.preload())).subscribe(() => { }) } preload() { const n = this.injector.get(_n); return this.processRoutes(n, this.router.config) } ngOnDestroy() { this.subscription && this.subscription.unsubscribe() } processRoutes(n, r) { const i = []; for (const s of r) if (s.loadChildren && !s.canLoad && s._loadedConfig) { const o = s._loadedConfig; i.push(this.processRoutes(o.module, o.routes)) } else s.loadChildren && !s.canLoad ? i.push(this.preloadConfig(n, s)) : s.children && i.push(this.processRoutes(n, s.children)); return Ue(i).pipe(Ri(), J(s => { })) } preloadConfig(n, r) { return this.preloadingStrategy.preload(r, () => (r._loadedConfig ? V(r._loadedConfig) : this.loader.load(n.injector, r)).pipe(Ie(s => (r._loadedConfig = s, this.processRoutes(s.module, s.routes))))) } } return t.\u0275fac = function (n) { return new (n || t)(C(Ye), C(g_), C(tt), C(yD)) }, t.\u0275prov = F({ token: t, factory: t.\u0275fac }), t })(), qd = (() => { class t { constructor(n, r, i = {}) { this.router = n, this.viewportScroller = r, this.options = i, this.lastId = 0, this.lastSource = "imperative", this.restoredId = 0, this.store = {}, i.scrollPositionRestoration = i.scrollPositionRestoration || "disabled", i.anchorScrolling = i.anchorScrolling || "disabled" } init() { "disabled" !== this.options.scrollPositionRestoration && this.viewportScroller.setHistoryScrollRestoration("manual"), this.routerEventsSubscription = this.createScrollEvents(), this.scrollEventsSubscription = this.consumeScrollEvents() } createScrollEvents() { return this.router.events.subscribe(n => { n instanceof Td ? (this.store[this.lastId] = this.viewportScroller.getScrollPosition(), this.lastSource = n.navigationTrigger, this.restoredId = n.restoredState ? n.restoredState.navigationId : 0) : n instanceof Rs && (this.lastId = n.id, this.scheduleScrollEvent(n, this.router.parseUrl(n.urlAfterRedirects).fragment)) }) } consumeScrollEvents() { return this.router.events.subscribe(n => { n instanceof Tv && (n.position ? "top" === this.options.scrollPositionRestoration ? this.viewportScroller.scrollToPosition([0, 0]) : "enabled" === this.options.scrollPositionRestoration && this.viewportScroller.scrollToPosition(n.position) : n.anchor && "enabled" === this.options.anchorScrolling ? this.viewportScroller.scrollToAnchor(n.anchor) : "disabled" !== this.options.scrollPositionRestoration && this.viewportScroller.scrollToPosition([0, 0])) }) } scheduleScrollEvent(n, r) { this.router.triggerEvent(new Tv(n, "popstate" === this.lastSource ? this.store[this.restoredId] : null, r)) } ngOnDestroy() { this.routerEventsSubscription && this.routerEventsSubscription.unsubscribe(), this.scrollEventsSubscription && this.scrollEventsSubscription.unsubscribe() } } return t.\u0275fac = function (n) { ac() }, t.\u0275prov = F({ token: t, factory: t.\u0275fac }), t })(); const vr = new O("ROUTER_CONFIGURATION"), DD = new O("ROUTER_FORROOT_GUARD"), LF = [rd, { provide: kv, useClass: Lv }, { provide: Ye, useFactory: function HF(t, e, n, r, i, s, o = {}, a, l) { const u = new Ye(null, t, e, n, r, i, Av(s)); return a && (u.urlHandlingStrategy = a), l && (u.routeReuseStrategy = l), function $F(t, e) { t.errorHandler && (e.errorHandler = t.errorHandler), t.malformedUriErrorHandler && (e.malformedUriErrorHandler = t.malformedUriErrorHandler), t.onSameUrlNavigation && (e.onSameUrlNavigation = t.onSameUrlNavigation), t.paramsInheritanceStrategy && (e.paramsInheritanceStrategy = t.paramsInheritanceStrategy), t.relativeLinkResolution && (e.relativeLinkResolution = t.relativeLinkResolution), t.urlUpdateStrategy && (e.urlUpdateStrategy = t.urlUpdateStrategy), t.canceledNavigationResolution && (e.canceledNavigationResolution = t.canceledNavigationResolution) }(o, u), o.enableTracing && u.events.subscribe(c => { var d, f; null === (d = console.group) || void 0 === d || d.call(console, `Router Event: ${c.constructor.name}`), console.log(c.toString()), console.log(c), null === (f = console.groupEnd) || void 0 === f || f.call(console) }), u }, deps: [kv, Ls, rd, tt, g_, Hd, vr, [class SF { }, new Pn], [class wF { }, new Pn]] }, Ls, { provide: vi, useFactory: function zF(t) { return t.routerState.root }, deps: [Ye] }, vD, _D, class kF { preload(e, n) { return n().pipe(qn(() => V(null))) } }, { provide: vr, useValue: { enableTracing: !1 } }]; function jF() { return new D_("Router", Ye) } let ED = (() => { class t { constructor(n, r) { } static forRoot(n, r) { return { ngModule: t, providers: [LF, CD(n), { provide: DD, useFactory: UF, deps: [[Ye, new Pn, new Qi]] }, { provide: vr, useValue: r || {} }, { provide: pi, useFactory: VF, deps: [hr, [new Co(nd), new Pn], vr] }, { provide: qd, useFactory: BF, deps: [Ye, HO, vr] }, { provide: yD, useExisting: r && r.preloadingStrategy ? r.preloadingStrategy : _D }, { provide: D_, multi: !0, useFactory: jF }, [Gd, { provide: Vc, multi: !0, useFactory: qF, deps: [Gd] }, { provide: bD, useFactory: GF, deps: [Gd] }, { provide: p_, multi: !0, useExisting: bD }]] } } static forChild(n) { return { ngModule: t, providers: [CD(n)] } } } return t.\u0275fac = function (n) { return new (n || t)(C(DD, 8), C(Ye, 8)) }, t.\u0275mod = st({ type: t }), t.\u0275inj = Xe({}), t })(); function BF(t, e, n) { return n.scrollOffset && e.setOffset(n.scrollOffset), new qd(t, e, n) } function VF(t, e, n = {}) { return n.useHash ? new ER(t, e) : new B_(t, e) } function UF(t) { return "guarded" } function CD(t) { return [{ provide: Xb, multi: !0, useValue: t }, { provide: Hd, multi: !0, useValue: t }] } let Gd = (() => { class t { constructor(n) { this.injector = n, this.initNavigation = !1, this.destroyed = !1, this.resultOfPreactivationDone = new ln } appInitializer() { return this.injector.get(_R, Promise.resolve(null)).then(() => { if (this.destroyed) return Promise.resolve(!0); let r = null; const i = new Promise(a => r = a), s = this.injector.get(Ye), o = this.injector.get(vr); return "disabled" === o.initialNavigation ? (s.setUpLocationChangeListener(), r(!0)) : "enabled" === o.initialNavigation || "enabledBlocking" === o.initialNavigation ? (s.hooks.afterPreactivation = () => this.initNavigation ? V(null) : (this.initNavigation = !0, r(!0), this.resultOfPreactivationDone), s.initialNavigation()) : r(!0), i }) } bootstrapListener(n) { const r = this.injector.get(vr), i = this.injector.get(vD), s = this.injector.get(qd), o = this.injector.get(Ye), a = this.injector.get(Qc); n === a.components[0] && (("enabledNonBlocking" === r.initialNavigation || void 0 === r.initialNavigation) && o.initialNavigation(), i.setUpPreloading(), s.init(), o.resetRootComponentType(a.componentTypes[0]), this.resultOfPreactivationDone.next(null), this.resultOfPreactivationDone.complete()) } ngOnDestroy() { this.destroyed = !0 } } return t.\u0275fac = function (n) { return new (n || t)(C(tt)) }, t.\u0275prov = F({ token: t, factory: t.\u0275fac }), t })(); function qF(t) { return t.appInitializer.bind(t) } function GF(t) { return t.bootstrapListener.bind(t) } const bD = new O("Router Initializer"); class wD { } const Mn = "*"; function MD(t, e = null) { return { type: 2, steps: t, options: e } } function TD(t) { return { type: 6, styles: t, offset: null } } function SD(t) { Promise.resolve(null).then(t) } class Us { constructor(e = 0, n = 0) { this._onDoneFns = [], this._onStartFns = [], this._onDestroyFns = [], this._started = !1, this._destroyed = !1, this._finished = !1, this._position = 0, this.parentPlayer = null, this.totalTime = e + n } _onFinish() { this._finished || (this._finished = !0, this._onDoneFns.forEach(e => e()), this._onDoneFns = []) } onStart(e) { this._onStartFns.push(e) } onDone(e) { this._onDoneFns.push(e) } onDestroy(e) { this._onDestroyFns.push(e) } hasStarted() { return this._started } init() { } play() { this.hasStarted() || (this._onStart(), this.triggerMicrotask()), this._started = !0 } triggerMicrotask() { SD(() => this._onFinish()) } _onStart() { this._onStartFns.forEach(e => e()), this._onStartFns = [] } pause() { } restart() { } finish() { this._onFinish() } destroy() { this._destroyed || (this._destroyed = !0, this.hasStarted() || this._onStart(), this.finish(), this._onDestroyFns.forEach(e => e()), this._onDestroyFns = []) } reset() { this._started = !1 } setPosition(e) { this._position = this.totalTime ? e * this.totalTime : 1 } getPosition() { return this.totalTime ? this._position / this.totalTime : 1 } triggerCallback(e) { const n = "start" == e ? this._onStartFns : this._onDoneFns; n.forEach(r => r()), n.length = 0 } } class ID { constructor(e) { this._onDoneFns = [], this._onStartFns = [], this._finished = !1, this._started = !1, this._destroyed = !1, this._onDestroyFns = [], this.parentPlayer = null, this.totalTime = 0, this.players = e; let n = 0, r = 0, i = 0; const s = this.players.length; 0 == s ? SD(() => this._onFinish()) : this.players.forEach(o => { o.onDone(() => { ++n == s && this._onFinish() }), o.onDestroy(() => { ++r == s && this._onDestroy() }), o.onStart(() => { ++i == s && this._onStart() }) }), this.totalTime = this.players.reduce((o, a) => Math.max(o, a.totalTime), 0) } _onFinish() { this._finished || (this._finished = !0, this._onDoneFns.forEach(e => e()), this._onDoneFns = []) } init() { this.players.forEach(e => e.init()) } onStart(e) { this._onStartFns.push(e) } _onStart() { this.hasStarted() || (this._started = !0, this._onStartFns.forEach(e => e()), this._onStartFns = []) } onDone(e) { this._onDoneFns.push(e) } onDestroy(e) { this._onDestroyFns.push(e) } hasStarted() { return this._started } play() { this.parentPlayer || this.init(), this._onStart(), this.players.forEach(e => e.play()) } pause() { this.players.forEach(e => e.pause()) } restart() { this.players.forEach(e => e.restart()) } finish() { this._onFinish(), this.players.forEach(e => e.finish()) } destroy() { this._onDestroy() } _onDestroy() { this._destroyed || (this._destroyed = !0, this._onFinish(), this.players.forEach(e => e.destroy()), this._onDestroyFns.forEach(e => e()), this._onDestroyFns = []) } reset() { this.players.forEach(e => e.reset()), this._destroyed = !1, this._finished = !1, this._started = !1 } setPosition(e) { const n = e * this.totalTime; this.players.forEach(r => { const i = r.totalTime ? Math.min(1, n / r.totalTime) : 1; r.setPosition(i) }) } getPosition() { const e = this.players.reduce((n, r) => null === n || r.totalTime > n.totalTime ? r : n, null); return null != e ? e.getPosition() : 0 } beforeDestroy() { this.players.forEach(e => { e.beforeDestroy && e.beforeDestroy() }) } triggerCallback(e) { const n = "start" == e ? this._onStartFns : this._onDoneFns; n.forEach(r => r()), n.length = 0 } } const K = !1; function AD(t) { return new M(3e3, K) } function IP() { return "undefined" != typeof window && void 0 !== window.document } function Kd() { return "undefined" != typeof process && "[object process]" === {}.toString.call(process) } function Wn(t) { switch (t.length) { case 0: return new Us; case 1: return t[0]; default: return new ID(t) } } function RD(t, e, n, r, i = {}, s = {}) { const o = [], a = []; let l = -1, u = null; if (r.forEach(c => { const d = c.offset, f = d == l, h = f && u || {}; Object.keys(c).forEach(p => { let g = p, y = c[p]; if ("offset" !== p) switch (g = e.normalizePropertyName(g, o), y) { case "!": y = i[p]; break; case Mn: y = s[p]; break; default: y = e.normalizeStyleValue(p, g, y, o) }h[g] = y }), f || a.push(h), u = h, l = d }), o.length) throw function yP(t) { return new M(3502, K) }(); return a } function Qd(t, e, n, r) { switch (e) { case "start": t.onStart(() => r(n && Zd(n, "start", t))); break; case "done": t.onDone(() => r(n && Zd(n, "done", t))); break; case "destroy": t.onDestroy(() => r(n && Zd(n, "destroy", t))) } } function Zd(t, e, n) { const r = n.totalTime, s = Yd(t.element, t.triggerName, t.fromState, t.toState, e || t.phaseName, null == r ? t.totalTime : r, !!n.disabled), o = t._data; return null != o && (s._data = o), s } function Yd(t, e, n, r, i = "", s = 0, o) { return { element: t, triggerName: e, fromState: n, toState: r, phaseName: i, totalTime: s, disabled: !!o } } function ht(t, e, n) { let r; return t instanceof Map ? (r = t.get(e), r || t.set(e, r = n)) : (r = t[e], r || (r = t[e] = n)), r } function OD(t) { const e = t.indexOf(":"); return [t.substring(1, e), t.substr(e + 1)] } let Jd = (t, e) => !1, ND = (t, e, n) => [], xD = null; function Xd(t) { const e = t.parentNode || t.host; return e === xD ? null : e } (Kd() || "undefined" != typeof Element) && (IP() ? (xD = (() => document.documentElement)(), Jd = (t, e) => { for (; e;) { if (e === t) return !0; e = Xd(e) } return !1 }) : Jd = (t, e) => t.contains(e), ND = (t, e, n) => { if (n) return Array.from(t.querySelectorAll(e)); const r = t.querySelector(e); return r ? [r] : [] }); let Dr = null, FD = !1; function PD(t) { Dr || (Dr = function RP() { return "undefined" != typeof document ? document.body : null }() || {}, FD = !!Dr.style && "WebkitAppearance" in Dr.style); let e = !0; return Dr.style && !function AP(t) { return "ebkit" == t.substring(1, 6) }(t) && (e = t in Dr.style, !e && FD && (e = "Webkit" + t.charAt(0).toUpperCase() + t.substr(1) in Dr.style)), e } const kD = Jd, LD = ND; let jD = (() => { class t { validateStyleProperty(n) { return PD(n) } matchesElement(n, r) { return !1 } containsElement(n, r) { return kD(n, r) } getParentElement(n) { return Xd(n) } query(n, r, i) { return LD(n, r, i) } computeStyle(n, r, i) { return i || "" } animate(n, r, i, s, o, a = [], l) { return new Us(i, s) } } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275prov = F({ token: t, factory: t.\u0275fac }), t })(), ef = (() => { class t { } return t.NOOP = new jD, t })(); const tf = "ng-enter", Ba = "ng-leave", Va = "ng-trigger", Ua = ".ng-trigger", VD = "ng-animating", nf = ".ng-animating"; function Er(t) { if ("number" == typeof t) return t; const e = t.match(/^(-?[\.\d]+)(m?s)/); return !e || e.length < 2 ? 0 : rf(parseFloat(e[1]), e[2]) } function rf(t, e) { return "s" === e ? 1e3 * t : t } function Ha(t, e, n) { return t.hasOwnProperty("duration") ? t : function xP(t, e, n) { let i, s = 0, o = ""; if ("string" == typeof t) { const a = t.match(/^(-?[\.\d]+)(m?s)(?:\s+(-?[\.\d]+)(m?s))?(?:\s+([-a-z]+(?:\(.+?\))?))?$/i); if (null === a) return e.push(AD()), { duration: 0, delay: 0, easing: "" }; i = rf(parseFloat(a[1]), a[2]); const l = a[3]; null != l && (s = rf(parseFloat(l), a[4])); const u = a[5]; u && (o = u) } else i = t; if (!n) { let a = !1, l = e.length; i < 0 && (e.push(function QF() { return new M(3100, K) }()), a = !0), s < 0 && (e.push(function ZF() { return new M(3101, K) }()), a = !0), a && e.splice(l, 0, AD()) } return { duration: i, delay: s, easing: o } }(t, e, n) } function Ei(t, e = {}) { return Object.keys(t).forEach(n => { e[n] = t[n] }), e } function Kn(t, e, n = {}) { if (e) for (let r in t) n[r] = t[r]; else Ei(t, n); return n } function HD(t, e, n) { return n ? e + ":" + n + ";" : "" } function $D(t) { let e = ""; for (let n = 0; n < t.style.length; n++) { const r = t.style.item(n); e += HD(0, r, t.style.getPropertyValue(r)) } for (const n in t.style) t.style.hasOwnProperty(n) && !n.startsWith("_") && (e += HD(0, kP(n), t.style[n])); t.setAttribute("style", e) } function on(t, e, n) { t.style && (Object.keys(e).forEach(r => { const i = af(r); n && !n.hasOwnProperty(r) && (n[r] = t.style[i]), t.style[i] = e[r] }), Kd() && $D(t)) } function Cr(t, e) { t.style && (Object.keys(e).forEach(n => { const r = af(n); t.style[r] = "" }), Kd() && $D(t)) } function Hs(t) { return Array.isArray(t) ? 1 == t.length ? t[0] : MD(t) : t } const sf = new RegExp("{{\\s*(.+?)\\s*}}", "g"); function zD(t) { let e = []; if ("string" == typeof t) { let n; for (; n = sf.exec(t);)e.push(n[1]); sf.lastIndex = 0 } return e } function $a(t, e, n) { const r = t.toString(), i = r.replace(sf, (s, o) => { let a = e[o]; return e.hasOwnProperty(o) || (n.push(function JF(t) { return new M(3003, K) }()), a = ""), a.toString() }); return i == r ? t : i } function za(t) { const e = []; let n = t.next(); for (; !n.done;)e.push(n.value), n = t.next(); return e } const PP = /-+([a-z0-9])/g; function af(t) { return t.replace(PP, (...e) => e[1].toUpperCase()) } function kP(t) { return t.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase() } function pt(t, e, n) { switch (e.type) { case 7: return t.visitTrigger(e, n); case 0: return t.visitState(e, n); case 1: return t.visitTransition(e, n); case 2: return t.visitSequence(e, n); case 3: return t.visitGroup(e, n); case 4: return t.visitAnimate(e, n); case 5: return t.visitKeyframes(e, n); case 6: return t.visitStyle(e, n); case 8: return t.visitReference(e, n); case 9: return t.visitAnimateChild(e, n); case 10: return t.visitAnimateRef(e, n); case 11: return t.visitQuery(e, n); case 12: return t.visitStagger(e, n); default: throw function XF(t) { return new M(3004, K) }() } } function qD(t, e) { return window.getComputedStyle(t)[e] } function HP(t, e) { const n = []; return "string" == typeof t ? t.split(/\s*,\s*/).forEach(r => function $P(t, e, n) { if (":" == t[0]) { const l = function zP(t, e) { switch (t) { case ":enter": return "void => *"; case ":leave": return "* => void"; case ":increment": return (n, r) => parseFloat(r) > parseFloat(n); case ":decrement": return (n, r) => parseFloat(r) < parseFloat(n); default: return e.push(function hP(t) { return new M(3016, K) }()), "* => *" } }(t, n); if ("function" == typeof l) return void e.push(l); t = l } const r = t.match(/^(\*|[-\w]+)\s*(<?[=-]>)\s*(\*|[-\w]+)$/); if (null == r || r.length < 4) return n.push(function fP(t) { return new M(3015, K) }()), e; const i = r[1], s = r[2], o = r[3]; e.push(GD(i, o)); "<" == s[0] && !("*" == i && "*" == o) && e.push(GD(o, i)) }(r, n, e)) : n.push(t), n } const Ka = new Set(["true", "1"]), Qa = new Set(["false", "0"]); function GD(t, e) { const n = Ka.has(t) || Qa.has(t), r = Ka.has(e) || Qa.has(e); return (i, s) => { let o = "*" == t || t == i, a = "*" == e || e == s; return !o && n && "boolean" == typeof i && (o = i ? Ka.has(t) : Qa.has(t)), !a && r && "boolean" == typeof s && (a = s ? Ka.has(e) : Qa.has(e)), o && a } } const qP = new RegExp("s*:selfs*,?", "g"); function lf(t, e, n, r) { return new GP(t).build(e, n, r) } class GP { constructor(e) { this._driver = e } build(e, n, r) { const i = new QP(n); this._resetContextStyleTimingState(i); const s = pt(this, Hs(e), i); return i.unsupportedCSSPropertiesFound.size && i.unsupportedCSSPropertiesFound.keys(), s } _resetContextStyleTimingState(e) { e.currentQuerySelector = "", e.collectedStyles = {}, e.collectedStyles[""] = {}, e.currentTime = 0 } visitTrigger(e, n) { let r = n.queryCount = 0, i = n.depCount = 0; const s = [], o = []; return "@" == e.name.charAt(0) && n.errors.push(function tP() { return new M(3006, K) }()), e.definitions.forEach(a => { if (this._resetContextStyleTimingState(n), 0 == a.type) { const l = a, u = l.name; u.toString().split(/\s*,\s*/).forEach(c => { l.name = c, s.push(this.visitState(l, n)) }), l.name = u } else if (1 == a.type) { const l = this.visitTransition(a, n); r += l.queryCount, i += l.depCount, o.push(l) } else n.errors.push(function nP() { return new M(3007, K) }()) }), { type: 7, name: e.name, states: s, transitions: o, queryCount: r, depCount: i, options: null } } visitState(e, n) { const r = this.visitStyle(e.styles, n), i = e.options && e.options.params || null; if (r.containsDynamicStyles) { const s = new Set, o = i || {}; r.styles.forEach(a => { if (Za(a)) { const l = a; Object.keys(l).forEach(u => { zD(l[u]).forEach(c => { o.hasOwnProperty(c) || s.add(c) }) }) } }), s.size && (za(s.values()), n.errors.push(function rP(t, e) { return new M(3008, K) }())) } return { type: 0, name: e.name, style: r, options: i ? { params: i } : null } } visitTransition(e, n) { n.queryCount = 0, n.depCount = 0; const r = pt(this, Hs(e.animation), n); return { type: 1, matchers: HP(e.expr, n.errors), animation: r, queryCount: n.queryCount, depCount: n.depCount, options: br(e.options) } } visitSequence(e, n) { return { type: 2, steps: e.steps.map(r => pt(this, r, n)), options: br(e.options) } } visitGroup(e, n) { const r = n.currentTime; let i = 0; const s = e.steps.map(o => { n.currentTime = r; const a = pt(this, o, n); return i = Math.max(i, n.currentTime), a }); return n.currentTime = i, { type: 3, steps: s, options: br(e.options) } } visitAnimate(e, n) { const r = function YP(t, e) { if (t.hasOwnProperty("duration")) return t; if ("number" == typeof t) return uf(Ha(t, e).duration, 0, ""); const n = t; if (n.split(/\s+/).some(s => "{" == s.charAt(0) && "{" == s.charAt(1))) { const s = uf(0, 0, ""); return s.dynamic = !0, s.strValue = n, s } const i = Ha(n, e); return uf(i.duration, i.delay, i.easing) }(e.timings, n.errors); n.currentAnimateTimings = r; let i, s = e.styles ? e.styles : TD({}); if (5 == s.type) i = this.visitKeyframes(s, n); else { let o = e.styles, a = !1; if (!o) { a = !0; const u = {}; r.easing && (u.easing = r.easing), o = TD(u) } n.currentTime += r.duration + r.delay; const l = this.visitStyle(o, n); l.isEmptyStep = a, i = l } return n.currentAnimateTimings = null, { type: 4, timings: r, style: i, options: null } } visitStyle(e, n) { const r = this._makeStyleAst(e, n); return this._validateStyleAst(r, n), r } _makeStyleAst(e, n) { const r = []; Array.isArray(e.styles) ? e.styles.forEach(o => { "string" == typeof o ? o == Mn ? r.push(o) : n.errors.push(function iP(t) { return new M(3002, K) }()) : r.push(o) }) : r.push(e.styles); let i = !1, s = null; return r.forEach(o => { if (Za(o)) { const a = o, l = a.easing; if (l && (s = l, delete a.easing), !i) for (let u in a) if (a[u].toString().indexOf("{{") >= 0) { i = !0; break } } }), { type: 6, styles: r, easing: s, offset: e.offset, containsDynamicStyles: i, options: null } } _validateStyleAst(e, n) { const r = n.currentAnimateTimings; let i = n.currentTime, s = n.currentTime; r && s > 0 && (s -= r.duration + r.delay), e.styles.forEach(o => { "string" != typeof o && Object.keys(o).forEach(a => { if (!this._driver.validateStyleProperty(a)) return delete o[a], void n.unsupportedCSSPropertiesFound.add(a); const l = n.collectedStyles[n.currentQuerySelector], u = l[a]; let c = !0; u && (s != i && s >= u.startTime && i <= u.endTime && (n.errors.push(function sP(t, e, n, r, i) { return new M(3010, K) }()), c = !1), s = u.startTime), c && (l[a] = { startTime: s, endTime: i }), n.options && function FP(t, e, n) { const r = e.params || {}, i = zD(t); i.length && i.forEach(s => { r.hasOwnProperty(s) || n.push(function YF(t) { return new M(3001, K) }()) }) }(o[a], n.options, n.errors) }) }) } visitKeyframes(e, n) { const r = { type: 5, styles: [], options: null }; if (!n.currentAnimateTimings) return n.errors.push(function oP() { return new M(3011, K) }()), r; let s = 0; const o = []; let a = !1, l = !1, u = 0; const c = e.steps.map(_ => { const m = this._makeStyleAst(_, n); let D = null != m.offset ? m.offset : function ZP(t) { if ("string" == typeof t) return null; let e = null; if (Array.isArray(t)) t.forEach(n => { if (Za(n) && n.hasOwnProperty("offset")) { const r = n; e = parseFloat(r.offset), delete r.offset } }); else if (Za(t) && t.hasOwnProperty("offset")) { const n = t; e = parseFloat(n.offset), delete n.offset } return e }(m.styles), T = 0; return null != D && (s++, T = m.offset = D), l = l || T < 0 || T > 1, a = a || T < u, u = T, o.push(T), m }); l && n.errors.push(function aP() { return new M(3012, K) }()), a && n.errors.push(function lP() { return new M(3200, K) }()); const d = e.steps.length; let f = 0; s > 0 && s < d ? n.errors.push(function uP() { return new M(3202, K) }()) : 0 == s && (f = 1 / (d - 1)); const h = d - 1, p = n.currentTime, g = n.currentAnimateTimings, y = g.duration; return c.forEach((_, m) => { const D = f > 0 ? m == h ? 1 : f * m : o[m], T = D * y; n.currentTime = p + g.delay + T, g.duration = T, this._validateStyleAst(_, n), _.offset = D, r.styles.push(_) }), r } visitReference(e, n) { return { type: 8, animation: pt(this, Hs(e.animation), n), options: br(e.options) } } visitAnimateChild(e, n) { return n.depCount++, { type: 9, options: br(e.options) } } visitAnimateRef(e, n) { return { type: 10, animation: this.visitReference(e.animation, n), options: br(e.options) } } visitQuery(e, n) { const r = n.currentQuerySelector, i = e.options || {}; n.queryCount++, n.currentQuery = e; const [s, o] = function WP(t) { const e = !!t.split(/\s*,\s*/).find(n => ":self" == n); return e && (t = t.replace(qP, "")), t = t.replace(/@\*/g, Ua).replace(/@\w+/g, n => Ua + "-" + n.substr(1)).replace(/:animating/g, nf), [t, e] }(e.selector); n.currentQuerySelector = r.length ? r + " " + s : s, ht(n.collectedStyles, n.currentQuerySelector, {}); const a = pt(this, Hs(e.animation), n); return n.currentQuery = null, n.currentQuerySelector = r, { type: 11, selector: s, limit: i.limit || 0, optional: !!i.optional, includeSelf: o, animation: a, originalSelector: e.selector, options: br(e.options) } } visitStagger(e, n) { n.currentQuery || n.errors.push(function cP() { return new M(3013, K) }()); const r = "full" === e.timings ? { duration: 0, delay: 0, easing: "full" } : Ha(e.timings, n.errors, !0); return { type: 12, animation: pt(this, Hs(e.animation), n), timings: r, options: null } } } class QP { constructor(e) { this.errors = e, this.queryCount = 0, this.depCount = 0, this.currentTransition = null, this.currentQuery = null, this.currentQuerySelector = null, this.currentAnimateTimings = null, this.currentTime = 0, this.collectedStyles = {}, this.options = null, this.unsupportedCSSPropertiesFound = new Set } } function Za(t) { return !Array.isArray(t) && "object" == typeof t } function br(t) { return t ? (t = Ei(t)).params && (t.params = function KP(t) { return t ? Ei(t) : null }(t.params)) : t = {}, t } function uf(t, e, n) { return { duration: t, delay: e, easing: n } } function cf(t, e, n, r, i, s, o = null, a = !1) { return { type: 1, element: t, keyframes: e, preStyleProps: n, postStyleProps: r, duration: i, delay: s, totalTime: i + s, easing: o, subTimeline: a } } class Ya { constructor() { this._map = new Map } get(e) { return this._map.get(e) || [] } append(e, n) { let r = this._map.get(e); r || this._map.set(e, r = []), r.push(...n) } has(e) { return this._map.has(e) } clear() { this._map.clear() } } const e1 = new RegExp(":enter", "g"), n1 = new RegExp(":leave", "g"); function df(t, e, n, r, i, s = {}, o = {}, a, l, u = []) { return (new r1).buildKeyframes(t, e, n, r, i, s, o, a, l, u) } class r1 { buildKeyframes(e, n, r, i, s, o, a, l, u, c = []) { u = u || new Ya; const d = new ff(e, n, u, i, s, c, []); d.options = l, d.currentTimeline.setStyles([o], null, d.errors, l), pt(this, r, d); const f = d.timelines.filter(h => h.containsAnimation()); if (Object.keys(a).length) { let h; for (let p = f.length - 1; p >= 0; p--) { const g = f[p]; if (g.element === n) { h = g; break } } h && !h.allowOnlyTimelineStyles() && h.setStyles([a], null, d.errors, l) } return f.length ? f.map(h => h.buildKeyframes()) : [cf(n, [], [], [], 0, 0, "", !1)] } visitTrigger(e, n) { } visitState(e, n) { } visitTransition(e, n) { } visitAnimateChild(e, n) { const r = n.subInstructions.get(n.element); if (r) { const i = n.createSubContext(e.options), s = n.currentTimeline.currentTime, o = this._visitSubInstructions(r, i, i.options); s != o && n.transformIntoNewTimeline(o) } n.previousNode = e } visitAnimateRef(e, n) { const r = n.createSubContext(e.options); r.transformIntoNewTimeline(), this.visitReference(e.animation, r), n.transformIntoNewTimeline(r.currentTimeline.currentTime), n.previousNode = e } _visitSubInstructions(e, n, r) { let s = n.currentTimeline.currentTime; const o = null != r.duration ? Er(r.duration) : null, a = null != r.delay ? Er(r.delay) : null; return 0 !== o && e.forEach(l => { const u = n.appendInstructionToTimeline(l, o, a); s = Math.max(s, u.duration + u.delay) }), s } visitReference(e, n) { n.updateOptions(e.options, !0), pt(this, e.animation, n), n.previousNode = e } visitSequence(e, n) { const r = n.subContextCount; let i = n; const s = e.options; if (s && (s.params || s.delay) && (i = n.createSubContext(s), i.transformIntoNewTimeline(), null != s.delay)) { 6 == i.previousNode.type && (i.currentTimeline.snapshotCurrentStyles(), i.previousNode = Ja); const o = Er(s.delay); i.delayNextStep(o) } e.steps.length && (e.steps.forEach(o => pt(this, o, i)), i.currentTimeline.applyStylesToKeyframe(), i.subContextCount > r && i.transformIntoNewTimeline()), n.previousNode = e } visitGroup(e, n) { const r = []; let i = n.currentTimeline.currentTime; const s = e.options && e.options.delay ? Er(e.options.delay) : 0; e.steps.forEach(o => { const a = n.createSubContext(e.options); s && a.delayNextStep(s), pt(this, o, a), i = Math.max(i, a.currentTimeline.currentTime), r.push(a.currentTimeline) }), r.forEach(o => n.currentTimeline.mergeTimelineCollectedStyles(o)), n.transformIntoNewTimeline(i), n.previousNode = e } _visitTiming(e, n) { if (e.dynamic) { const r = e.strValue; return Ha(n.params ? $a(r, n.params, n.errors) : r, n.errors) } return { duration: e.duration, delay: e.delay, easing: e.easing } } visitAnimate(e, n) { const r = n.currentAnimateTimings = this._visitTiming(e.timings, n), i = n.currentTimeline; r.delay && (n.incrementTime(r.delay), i.snapshotCurrentStyles()); const s = e.style; 5 == s.type ? this.visitKeyframes(s, n) : (n.incrementTime(r.duration), this.visitStyle(s, n), i.applyStylesToKeyframe()), n.currentAnimateTimings = null, n.previousNode = e } visitStyle(e, n) { const r = n.currentTimeline, i = n.currentAnimateTimings; !i && r.getCurrentStyleProperties().length && r.forwardFrame(); const s = i && i.easing || e.easing; e.isEmptyStep ? r.applyEmptyStep(s) : r.setStyles(e.styles, s, n.errors, n.options), n.previousNode = e } visitKeyframes(e, n) { const r = n.currentAnimateTimings, i = n.currentTimeline.duration, s = r.duration, a = n.createSubContext().currentTimeline; a.easing = r.easing, e.styles.forEach(l => { a.forwardTime((l.offset || 0) * s), a.setStyles(l.styles, l.easing, n.errors, n.options), a.applyStylesToKeyframe() }), n.currentTimeline.mergeTimelineCollectedStyles(a), n.transformIntoNewTimeline(i + s), n.previousNode = e } visitQuery(e, n) { const r = n.currentTimeline.currentTime, i = e.options || {}, s = i.delay ? Er(i.delay) : 0; s && (6 === n.previousNode.type || 0 == r && n.currentTimeline.getCurrentStyleProperties().length) && (n.currentTimeline.snapshotCurrentStyles(), n.previousNode = Ja); let o = r; const a = n.invokeQuery(e.selector, e.originalSelector, e.limit, e.includeSelf, !!i.optional, n.errors); n.currentQueryTotal = a.length; let l = null; a.forEach((u, c) => { n.currentQueryIndex = c; const d = n.createSubContext(e.options, u); s && d.delayNextStep(s), u === n.element && (l = d.currentTimeline), pt(this, e.animation, d), d.currentTimeline.applyStylesToKeyframe(), o = Math.max(o, d.currentTimeline.currentTime) }), n.currentQueryIndex = 0, n.currentQueryTotal = 0, n.transformIntoNewTimeline(o), l && (n.currentTimeline.mergeTimelineCollectedStyles(l), n.currentTimeline.snapshotCurrentStyles()), n.previousNode = e } visitStagger(e, n) { const r = n.parentContext, i = n.currentTimeline, s = e.timings, o = Math.abs(s.duration), a = o * (n.currentQueryTotal - 1); let l = o * n.currentQueryIndex; switch (s.duration < 0 ? "reverse" : s.easing) { case "reverse": l = a - l; break; case "full": l = r.currentStaggerTime }const c = n.currentTimeline; l && c.delayNextStep(l); const d = c.currentTime; pt(this, e.animation, n), n.previousNode = e, r.currentStaggerTime = i.currentTime - d + (i.startTime - r.currentTimeline.startTime) } } const Ja = {}; class ff { constructor(e, n, r, i, s, o, a, l) { this._driver = e, this.element = n, this.subInstructions = r, this._enterClassName = i, this._leaveClassName = s, this.errors = o, this.timelines = a, this.parentContext = null, this.currentAnimateTimings = null, this.previousNode = Ja, this.subContextCount = 0, this.options = {}, this.currentQueryIndex = 0, this.currentQueryTotal = 0, this.currentStaggerTime = 0, this.currentTimeline = l || new Xa(this._driver, n, 0), a.push(this.currentTimeline) } get params() { return this.options.params } updateOptions(e, n) { if (!e) return; const r = e; let i = this.options; null != r.duration && (i.duration = Er(r.duration)), null != r.delay && (i.delay = Er(r.delay)); const s = r.params; if (s) { let o = i.params; o || (o = this.options.params = {}), Object.keys(s).forEach(a => { (!n || !o.hasOwnProperty(a)) && (o[a] = $a(s[a], o, this.errors)) }) } } _copyOptions() { const e = {}; if (this.options) { const n = this.options.params; if (n) { const r = e.params = {}; Object.keys(n).forEach(i => { r[i] = n[i] }) } } return e } createSubContext(e = null, n, r) { const i = n || this.element, s = new ff(this._driver, i, this.subInstructions, this._enterClassName, this._leaveClassName, this.errors, this.timelines, this.currentTimeline.fork(i, r || 0)); return s.previousNode = this.previousNode, s.currentAnimateTimings = this.currentAnimateTimings, s.options = this._copyOptions(), s.updateOptions(e), s.currentQueryIndex = this.currentQueryIndex, s.currentQueryTotal = this.currentQueryTotal, s.parentContext = this, this.subContextCount++, s } transformIntoNewTimeline(e) { return this.previousNode = Ja, this.currentTimeline = this.currentTimeline.fork(this.element, e), this.timelines.push(this.currentTimeline), this.currentTimeline } appendInstructionToTimeline(e, n, r) { const i = { duration: null != n ? n : e.duration, delay: this.currentTimeline.currentTime + (null != r ? r : 0) + e.delay, easing: "" }, s = new s1(this._driver, e.element, e.keyframes, e.preStyleProps, e.postStyleProps, i, e.stretchStartingKeyframe); return this.timelines.push(s), i } incrementTime(e) { this.currentTimeline.forwardTime(this.currentTimeline.duration + e) } delayNextStep(e) { e > 0 && this.currentTimeline.delayNextStep(e) } invokeQuery(e, n, r, i, s, o) { let a = []; if (i && a.push(this.element), e.length > 0) { e = (e = e.replace(e1, "." + this._enterClassName)).replace(n1, "." + this._leaveClassName); let u = this._driver.query(this.element, e, 1 != r); 0 !== r && (u = r < 0 ? u.slice(u.length + r, u.length) : u.slice(0, r)), a.push(...u) } return !s && 0 == a.length && o.push(function dP(t) { return new M(3014, K) }()), a } } class Xa { constructor(e, n, r, i) { this._driver = e, this.element = n, this.startTime = r, this._elementTimelineStylesLookup = i, this.duration = 0, this._previousKeyframe = {}, this._currentKeyframe = {}, this._keyframes = new Map, this._styleSummary = {}, this._pendingStyles = {}, this._backFill = {}, this._currentEmptyStepKeyframe = null, this._elementTimelineStylesLookup || (this._elementTimelineStylesLookup = new Map), this._localTimelineStyles = Object.create(this._backFill, {}), this._globalTimelineStyles = this._elementTimelineStylesLookup.get(n), this._globalTimelineStyles || (this._globalTimelineStyles = this._localTimelineStyles, this._elementTimelineStylesLookup.set(n, this._localTimelineStyles)), this._loadKeyframe() } containsAnimation() { switch (this._keyframes.size) { case 0: return !1; case 1: return this.getCurrentStyleProperties().length > 0; default: return !0 } } getCurrentStyleProperties() { return Object.keys(this._currentKeyframe) } get currentTime() { return this.startTime + this.duration } delayNextStep(e) { const n = 1 == this._keyframes.size && Object.keys(this._pendingStyles).length; this.duration || n ? (this.forwardTime(this.currentTime + e), n && this.snapshotCurrentStyles()) : this.startTime += e } fork(e, n) { return this.applyStylesToKeyframe(), new Xa(this._driver, e, n || this.currentTime, this._elementTimelineStylesLookup) } _loadKeyframe() { this._currentKeyframe && (this._previousKeyframe = this._currentKeyframe), this._currentKeyframe = this._keyframes.get(this.duration), this._currentKeyframe || (this._currentKeyframe = Object.create(this._backFill, {}), this._keyframes.set(this.duration, this._currentKeyframe)) } forwardFrame() { this.duration += 1, this._loadKeyframe() } forwardTime(e) { this.applyStylesToKeyframe(), this.duration = e, this._loadKeyframe() } _updateStyle(e, n) { this._localTimelineStyles[e] = n, this._globalTimelineStyles[e] = n, this._styleSummary[e] = { time: this.currentTime, value: n } } allowOnlyTimelineStyles() { return this._currentEmptyStepKeyframe !== this._currentKeyframe } applyEmptyStep(e) { e && (this._previousKeyframe.easing = e), Object.keys(this._globalTimelineStyles).forEach(n => { this._backFill[n] = this._globalTimelineStyles[n] || Mn, this._currentKeyframe[n] = Mn }), this._currentEmptyStepKeyframe = this._currentKeyframe } setStyles(e, n, r, i) { n && (this._previousKeyframe.easing = n); const s = i && i.params || {}, o = function o1(t, e) { const n = {}; let r; return t.forEach(i => { "*" === i ? (r = r || Object.keys(e), r.forEach(s => { n[s] = Mn })) : Kn(i, !1, n) }), n }(e, this._globalTimelineStyles); Object.keys(o).forEach(a => { const l = $a(o[a], s, r); this._pendingStyles[a] = l, this._localTimelineStyles.hasOwnProperty(a) || (this._backFill[a] = this._globalTimelineStyles.hasOwnProperty(a) ? this._globalTimelineStyles[a] : Mn), this._updateStyle(a, l) }) } applyStylesToKeyframe() { const e = this._pendingStyles, n = Object.keys(e); 0 != n.length && (this._pendingStyles = {}, n.forEach(r => { this._currentKeyframe[r] = e[r] }), Object.keys(this._localTimelineStyles).forEach(r => { this._currentKeyframe.hasOwnProperty(r) || (this._currentKeyframe[r] = this._localTimelineStyles[r]) })) } snapshotCurrentStyles() { Object.keys(this._localTimelineStyles).forEach(e => { const n = this._localTimelineStyles[e]; this._pendingStyles[e] = n, this._updateStyle(e, n) }) } getFinalKeyframe() { return this._keyframes.get(this.duration) } get properties() { const e = []; for (let n in this._currentKeyframe) e.push(n); return e } mergeTimelineCollectedStyles(e) { Object.keys(e._styleSummary).forEach(n => { const r = this._styleSummary[n], i = e._styleSummary[n]; (!r || i.time > r.time) && this._updateStyle(n, i.value) }) } buildKeyframes() { this.applyStylesToKeyframe(); const e = new Set, n = new Set, r = 1 === this._keyframes.size && 0 === this.duration; let i = []; this._keyframes.forEach((a, l) => { const u = Kn(a, !0); Object.keys(u).forEach(c => { const d = u[c]; "!" == d ? e.add(c) : d == Mn && n.add(c) }), r || (u.offset = l / this.duration), i.push(u) }); const s = e.size ? za(e.values()) : [], o = n.size ? za(n.values()) : []; if (r) { const a = i[0], l = Ei(a); a.offset = 0, l.offset = 1, i = [a, l] } return cf(this.element, i, s, o, this.duration, this.startTime, this.easing, !1) } } class s1 extends Xa { constructor(e, n, r, i, s, o, a = !1) { super(e, n, o.delay), this.keyframes = r, this.preStyleProps = i, this.postStyleProps = s, this._stretchStartingKeyframe = a, this.timings = { duration: o.duration, delay: o.delay, easing: o.easing } } containsAnimation() { return this.keyframes.length > 1 } buildKeyframes() { let e = this.keyframes, { delay: n, duration: r, easing: i } = this.timings; if (this._stretchStartingKeyframe && n) { const s = [], o = r + n, a = n / o, l = Kn(e[0], !1); l.offset = 0, s.push(l); const u = Kn(e[0], !1); u.offset = QD(a), s.push(u); const c = e.length - 1; for (let d = 1; d <= c; d++) { let f = Kn(e[d], !1); f.offset = QD((n + f.offset * r) / o), s.push(f) } r = o, n = 0, i = "", e = s } return cf(this.element, e, this.preStyleProps, this.postStyleProps, r, n, i, !0) } } function QD(t, e = 3) { const n = Math.pow(10, e - 1); return Math.round(t * n) / n } class hf { } class a1 extends hf { normalizePropertyName(e, n) { return af(e) } normalizeStyleValue(e, n, r, i) { let s = ""; const o = r.toString().trim(); if (l1[n] && 0 !== r && "0" !== r) if ("number" == typeof r) s = "px"; else { const a = r.match(/^[+-]?[\d\.]+([a-z]*)$/); a && 0 == a[1].length && i.push(function eP(t, e) { return new M(3005, K) }()) } return o + s } } const l1 = (() => function u1(t) { const e = {}; return t.forEach(n => e[n] = !0), e }("width,height,minWidth,minHeight,maxWidth,maxHeight,left,top,bottom,right,fontSize,outlineWidth,outlineOffset,paddingTop,paddingLeft,paddingBottom,paddingRight,marginTop,marginLeft,marginBottom,marginRight,borderRadius,borderWidth,borderTopWidth,borderLeftWidth,borderRightWidth,borderBottomWidth,textIndent,perspective".split(",")))(); function ZD(t, e, n, r, i, s, o, a, l, u, c, d, f) { return { type: 0, element: t, triggerName: e, isRemovalTransition: i, fromState: n, fromStyles: s, toState: r, toStyles: o, timelines: a, queriedElements: l, preStyleProps: u, postStyleProps: c, totalTime: d, errors: f } } const pf = {}; class YD { constructor(e, n, r) { this._triggerName = e, this.ast = n, this._stateStyles = r } match(e, n, r, i) { return function c1(t, e, n, r, i) { return t.some(s => s(e, n, r, i)) }(this.ast.matchers, e, n, r, i) } buildStyles(e, n, r) { const i = this._stateStyles["*"], s = this._stateStyles[e], o = i ? i.buildStyles(n, r) : {}; return s ? s.buildStyles(n, r) : o } build(e, n, r, i, s, o, a, l, u, c) { const d = [], f = this.ast.options && this.ast.options.params || pf, p = this.buildStyles(r, a && a.params || pf, d), g = l && l.params || pf, y = this.buildStyles(i, g, d), _ = new Set, m = new Map, D = new Map, T = "void" === i, $ = { params: Object.assign(Object.assign({}, f), g) }, le = c ? [] : df(e, n, this.ast.animation, s, o, p, y, $, u, d); let de = 0; if (le.forEach(mt => { de = Math.max(mt.duration + mt.delay, de) }), d.length) return ZD(n, this._triggerName, r, i, T, p, y, [], [], m, D, de, d); le.forEach(mt => { const yt = mt.element, wi = ht(m, yt, {}); mt.preStyleProps.forEach(Gt => wi[Gt] = !0); const Sn = ht(D, yt, {}); mt.postStyleProps.forEach(Gt => Sn[Gt] = !0), yt !== n && _.add(yt) }); const gt = za(_.values()); return ZD(n, this._triggerName, r, i, T, p, y, le, gt, m, D, de) } } class d1 { constructor(e, n, r) { this.styles = e, this.defaultParams = n, this.normalizer = r } buildStyles(e, n) { const r = {}, i = Ei(this.defaultParams); return Object.keys(e).forEach(s => { const o = e[s]; null != o && (i[s] = o) }), this.styles.styles.forEach(s => { if ("string" != typeof s) { const o = s; Object.keys(o).forEach(a => { let l = o[a]; l.length > 1 && (l = $a(l, i, n)); const u = this.normalizer.normalizePropertyName(a, n); l = this.normalizer.normalizeStyleValue(a, u, l, n), r[u] = l }) } }), r } } class h1 { constructor(e, n, r) { this.name = e, this.ast = n, this._normalizer = r, this.transitionFactories = [], this.states = {}, n.states.forEach(i => { this.states[i.name] = new d1(i.style, i.options && i.options.params || {}, r) }), JD(this.states, "true", "1"), JD(this.states, "false", "0"), n.transitions.forEach(i => { this.transitionFactories.push(new YD(e, i, this.states)) }), this.fallbackTransition = function p1(t, e, n) { return new YD(t, { type: 1, animation: { type: 2, steps: [], options: null }, matchers: [(o, a) => !0], options: null, queryCount: 0, depCount: 0 }, e) }(e, this.states) } get containsQueries() { return this.ast.queryCount > 0 } matchTransition(e, n, r, i) { return this.transitionFactories.find(o => o.match(e, n, r, i)) || null } matchStyles(e, n, r) { return this.fallbackTransition.buildStyles(e, n, r) } } function JD(t, e, n) { t.hasOwnProperty(e) ? t.hasOwnProperty(n) || (t[n] = t[e]) : t.hasOwnProperty(n) && (t[e] = t[n]) } const g1 = new Ya; class m1 { constructor(e, n, r) { this.bodyNode = e, this._driver = n, this._normalizer = r, this._animations = {}, this._playersById = {}, this.players = [] } register(e, n) { const r = [], s = lf(this._driver, n, r, []); if (r.length) throw function _P(t) { return new M(3503, K) }(); this._animations[e] = s } _buildPlayer(e, n, r) { const i = e.element, s = RD(0, this._normalizer, 0, e.keyframes, n, r); return this._driver.animate(i, s, e.duration, e.delay, e.easing, [], !0) } create(e, n, r = {}) { const i = [], s = this._animations[e]; let o; const a = new Map; if (s ? (o = df(this._driver, n, s, tf, Ba, {}, {}, r, g1, i), o.forEach(c => { const d = ht(a, c.element, {}); c.postStyleProps.forEach(f => d[f] = null) })) : (i.push(function vP() { return new M(3300, K) }()), o = []), i.length) throw function DP(t) { return new M(3504, K) }(); a.forEach((c, d) => { Object.keys(c).forEach(f => { c[f] = this._driver.computeStyle(d, f, Mn) }) }); const u = Wn(o.map(c => { const d = a.get(c.element); return this._buildPlayer(c, {}, d) })); return this._playersById[e] = u, u.onDestroy(() => this.destroy(e)), this.players.push(u), u } destroy(e) { const n = this._getPlayer(e); n.destroy(), delete this._playersById[e]; const r = this.players.indexOf(n); r >= 0 && this.players.splice(r, 1) } _getPlayer(e) { const n = this._playersById[e]; if (!n) throw function EP(t) { return new M(3301, K) }(); return n } listen(e, n, r, i) { const s = Yd(n, "", "", ""); return Qd(this._getPlayer(e), r, s, i), () => { } } command(e, n, r, i) { if ("register" == r) return void this.register(e, i[0]); if ("create" == r) return void this.create(e, n, i[0] || {}); const s = this._getPlayer(e); switch (r) { case "play": s.play(); break; case "pause": s.pause(); break; case "reset": s.reset(); break; case "restart": s.restart(); break; case "finish": s.finish(); break; case "init": s.init(); break; case "setPosition": s.setPosition(parseFloat(i[0])); break; case "destroy": this.destroy(e) } } } const XD = "ng-animate-queued", gf = "ng-animate-disabled", E1 = [], eE = { namespaceId: "", setForRemoval: !1, setForMove: !1, hasAnimation: !1, removedBeforeQueried: !1 }, C1 = { namespaceId: "", setForMove: !1, setForRemoval: !1, hasAnimation: !1, removedBeforeQueried: !0 }, At = "__ng_removed"; class mf { constructor(e, n = "") { this.namespaceId = n; const r = e && e.hasOwnProperty("value"); if (this.value = function T1(t) { return null != t ? t : null }(r ? e.value : e), r) { const s = Ei(e); delete s.value, this.options = s } else this.options = {}; this.options.params || (this.options.params = {}) } get params() { return this.options.params } absorbOptions(e) { const n = e.params; if (n) { const r = this.options.params; Object.keys(n).forEach(i => { null == r[i] && (r[i] = n[i]) }) } } } const $s = "void", yf = new mf($s); class b1 { constructor(e, n, r) { this.id = e, this.hostElement = n, this._engine = r, this.players = [], this._triggers = {}, this._queue = [], this._elementListeners = new Map, this._hostClassName = "ng-tns-" + e, Rt(n, this._hostClassName) } listen(e, n, r, i) { if (!this._triggers.hasOwnProperty(n)) throw function CP(t, e) { return new M(3302, K) }(); if (null == r || 0 == r.length) throw function bP(t) { return new M(3303, K) }(); if (!function S1(t) { return "start" == t || "done" == t }(r)) throw function wP(t, e) { return new M(3400, K) }(); const s = ht(this._elementListeners, e, []), o = { name: n, phase: r, callback: i }; s.push(o); const a = ht(this._engine.statesByElement, e, {}); return a.hasOwnProperty(n) || (Rt(e, Va), Rt(e, Va + "-" + n), a[n] = yf), () => { this._engine.afterFlush(() => { const l = s.indexOf(o); l >= 0 && s.splice(l, 1), this._triggers[n] || delete a[n] }) } } register(e, n) { return !this._triggers[e] && (this._triggers[e] = n, !0) } _getTrigger(e) { const n = this._triggers[e]; if (!n) throw function MP(t) { return new M(3401, K) }(); return n } trigger(e, n, r, i = !0) { const s = this._getTrigger(n), o = new _f(this.id, n, e); let a = this._engine.statesByElement.get(e); a || (Rt(e, Va), Rt(e, Va + "-" + n), this._engine.statesByElement.set(e, a = {})); let l = a[n]; const u = new mf(r, this.id); if (!(r && r.hasOwnProperty("value")) && l && u.absorbOptions(l.options), a[n] = u, l || (l = yf), u.value !== $s && l.value === u.value) { if (!function R1(t, e) { const n = Object.keys(t), r = Object.keys(e); if (n.length != r.length) return !1; for (let i = 0; i < n.length; i++) { const s = n[i]; if (!e.hasOwnProperty(s) || t[s] !== e[s]) return !1 } return !0 }(l.params, u.params)) { const g = [], y = s.matchStyles(l.value, l.params, g), _ = s.matchStyles(u.value, u.params, g); g.length ? this._engine.reportError(g) : this._engine.afterFlush(() => { Cr(e, y), on(e, _) }) } return } const f = ht(this._engine.playersByElement, e, []); f.forEach(g => { g.namespaceId == this.id && g.triggerName == n && g.queued && g.destroy() }); let h = s.matchTransition(l.value, u.value, e, u.params), p = !1; if (!h) { if (!i) return; h = s.fallbackTransition, p = !0 } return this._engine.totalQueuedPlayers++, this._queue.push({ element: e, triggerName: n, transition: h, fromState: l, toState: u, player: o, isFallbackTransition: p }), p || (Rt(e, XD), o.onStart(() => { Ci(e, XD) })), o.onDone(() => { let g = this.players.indexOf(o); g >= 0 && this.players.splice(g, 1); const y = this._engine.playersByElement.get(e); if (y) { let _ = y.indexOf(o); _ >= 0 && y.splice(_, 1) } }), this.players.push(o), f.push(o), o } deregister(e) { delete this._triggers[e], this._engine.statesByElement.forEach((n, r) => { delete n[e] }), this._elementListeners.forEach((n, r) => { this._elementListeners.set(r, n.filter(i => i.name != e)) }) } clearElementCache(e) { this._engine.statesByElement.delete(e), this._elementListeners.delete(e); const n = this._engine.playersByElement.get(e); n && (n.forEach(r => r.destroy()), this._engine.playersByElement.delete(e)) } _signalRemovalForInnerTriggers(e, n) { const r = this._engine.driver.query(e, Ua, !0); r.forEach(i => { if (i[At]) return; const s = this._engine.fetchNamespacesByElement(i); s.size ? s.forEach(o => o.triggerLeaveAnimation(i, n, !1, !0)) : this.clearElementCache(i) }), this._engine.afterFlushAnimationsDone(() => r.forEach(i => this.clearElementCache(i))) } triggerLeaveAnimation(e, n, r, i) { const s = this._engine.statesByElement.get(e), o = new Map; if (s) { const a = []; if (Object.keys(s).forEach(l => { if (o.set(l, s[l].value), this._triggers[l]) { const u = this.trigger(e, l, $s, i); u && a.push(u) } }), a.length) return this._engine.markElementAsRemoved(this.id, e, !0, n, o), r && Wn(a).onDone(() => this._engine.processLeaveNode(e)), !0 } return !1 } prepareLeaveAnimationListeners(e) { const n = this._elementListeners.get(e), r = this._engine.statesByElement.get(e); if (n && r) { const i = new Set; n.forEach(s => { const o = s.name; if (i.has(o)) return; i.add(o); const l = this._triggers[o].fallbackTransition, u = r[o] || yf, c = new mf($s), d = new _f(this.id, o, e); this._engine.totalQueuedPlayers++, this._queue.push({ element: e, triggerName: o, transition: l, fromState: u, toState: c, player: d, isFallbackTransition: !0 }) }) } } removeNode(e, n) { const r = this._engine; if (e.childElementCount && this._signalRemovalForInnerTriggers(e, n), this.triggerLeaveAnimation(e, n, !0)) return; let i = !1; if (r.totalAnimations) { const s = r.players.length ? r.playersByQueriedElement.get(e) : []; if (s && s.length) i = !0; else { let o = e; for (; o = o.parentNode;)if (r.statesByElement.get(o)) { i = !0; break } } } if (this.prepareLeaveAnimationListeners(e), i) r.markElementAsRemoved(this.id, e, !1, n); else { const s = e[At]; (!s || s === eE) && (r.afterFlush(() => this.clearElementCache(e)), r.destroyInnerAnimations(e), r._onRemovalComplete(e, n)) } } insertNode(e, n) { Rt(e, this._hostClassName) } drainQueuedTransitions(e) { const n = []; return this._queue.forEach(r => { const i = r.player; if (i.destroyed) return; const s = r.element, o = this._elementListeners.get(s); o && o.forEach(a => { if (a.name == r.triggerName) { const l = Yd(s, r.triggerName, r.fromState.value, r.toState.value); l._data = e, Qd(r.player, a.phase, l, a.callback) } }), i.markedForDestroy ? this._engine.afterFlush(() => { i.destroy() }) : n.push(r) }), this._queue = [], n.sort((r, i) => { const s = r.transition.ast.depCount, o = i.transition.ast.depCount; return 0 == s || 0 == o ? s - o : this._engine.driver.containsElement(r.element, i.element) ? 1 : -1 }) } destroy(e) { this.players.forEach(n => n.destroy()), this._signalRemovalForInnerTriggers(this.hostElement, e) } elementContainsData(e) { let n = !1; return this._elementListeners.has(e) && (n = !0), n = !!this._queue.find(r => r.element === e) || n, n } } class w1 { constructor(e, n, r) { this.bodyNode = e, this.driver = n, this._normalizer = r, this.players = [], this.newHostElements = new Map, this.playersByElement = new Map, this.playersByQueriedElement = new Map, this.statesByElement = new Map, this.disabledNodes = new Set, this.totalAnimations = 0, this.totalQueuedPlayers = 0, this._namespaceLookup = {}, this._namespaceList = [], this._flushFns = [], this._whenQuietFns = [], this.namespacesByHostElement = new Map, this.collectedEnterElements = [], this.collectedLeaveElements = [], this.onRemovalComplete = (i, s) => { } } _onRemovalComplete(e, n) { this.onRemovalComplete(e, n) } get queuedPlayers() { const e = []; return this._namespaceList.forEach(n => { n.players.forEach(r => { r.queued && e.push(r) }) }), e } createNamespace(e, n) { const r = new b1(e, n, this); return this.bodyNode && this.driver.containsElement(this.bodyNode, n) ? this._balanceNamespaceList(r, n) : (this.newHostElements.set(n, r), this.collectEnterElement(n)), this._namespaceLookup[e] = r } _balanceNamespaceList(e, n) { const r = this._namespaceList, i = this.namespacesByHostElement, s = r.length - 1; if (s >= 0) { let o = !1; if (void 0 !== this.driver.getParentElement) { let a = this.driver.getParentElement(n); for (; a;) { const l = i.get(a); if (l) { const u = r.indexOf(l); r.splice(u + 1, 0, e), o = !0; break } a = this.driver.getParentElement(a) } } else for (let a = s; a >= 0; a--)if (this.driver.containsElement(r[a].hostElement, n)) { r.splice(a + 1, 0, e), o = !0; break } o || r.unshift(e) } else r.push(e); return i.set(n, e), e } register(e, n) { let r = this._namespaceLookup[e]; return r || (r = this.createNamespace(e, n)), r } registerTrigger(e, n, r) { let i = this._namespaceLookup[e]; i && i.register(n, r) && this.totalAnimations++ } destroy(e, n) { if (!e) return; const r = this._fetchNamespace(e); this.afterFlush(() => { this.namespacesByHostElement.delete(r.hostElement), delete this._namespaceLookup[e]; const i = this._namespaceList.indexOf(r); i >= 0 && this._namespaceList.splice(i, 1) }), this.afterFlushAnimationsDone(() => r.destroy(n)) } _fetchNamespace(e) { return this._namespaceLookup[e] } fetchNamespacesByElement(e) { const n = new Set, r = this.statesByElement.get(e); if (r) { const i = Object.keys(r); for (let s = 0; s < i.length; s++) { const o = r[i[s]].namespaceId; if (o) { const a = this._fetchNamespace(o); a && n.add(a) } } } return n } trigger(e, n, r, i) { if (el(n)) { const s = this._fetchNamespace(e); if (s) return s.trigger(n, r, i), !0 } return !1 } insertNode(e, n, r, i) { if (!el(n)) return; const s = n[At]; if (s && s.setForRemoval) { s.setForRemoval = !1, s.setForMove = !0; const o = this.collectedLeaveElements.indexOf(n); o >= 0 && this.collectedLeaveElements.splice(o, 1) } if (e) { const o = this._fetchNamespace(e); o && o.insertNode(n, r) } i && this.collectEnterElement(n) } collectEnterElement(e) { this.collectedEnterElements.push(e) } markElementAsDisabled(e, n) { n ? this.disabledNodes.has(e) || (this.disabledNodes.add(e), Rt(e, gf)) : this.disabledNodes.has(e) && (this.disabledNodes.delete(e), Ci(e, gf)) } removeNode(e, n, r, i) { if (el(n)) { const s = e ? this._fetchNamespace(e) : null; if (s ? s.removeNode(n, i) : this.markElementAsRemoved(e, n, !1, i), r) { const o = this.namespacesByHostElement.get(n); o && o.id !== e && o.removeNode(n, i) } } else this._onRemovalComplete(n, i) } markElementAsRemoved(e, n, r, i, s) { this.collectedLeaveElements.push(n), n[At] = { namespaceId: e, setForRemoval: i, hasAnimation: r, removedBeforeQueried: !1, previousTriggersValues: s } } listen(e, n, r, i, s) { return el(n) ? this._fetchNamespace(e).listen(n, r, i, s) : () => { } } _buildInstruction(e, n, r, i, s) { return e.transition.build(this.driver, e.element, e.fromState.value, e.toState.value, r, i, e.fromState.options, e.toState.options, n, s) } destroyInnerAnimations(e) { let n = this.driver.query(e, Ua, !0); n.forEach(r => this.destroyActiveAnimationsForElement(r)), 0 != this.playersByQueriedElement.size && (n = this.driver.query(e, nf, !0), n.forEach(r => this.finishActiveQueriedAnimationOnElement(r))) } destroyActiveAnimationsForElement(e) { const n = this.playersByElement.get(e); n && n.forEach(r => { r.queued ? r.markedForDestroy = !0 : r.destroy() }) } finishActiveQueriedAnimationOnElement(e) { const n = this.playersByQueriedElement.get(e); n && n.forEach(r => r.finish()) } whenRenderingDone() { return new Promise(e => { if (this.players.length) return Wn(this.players).onDone(() => e()); e() }) } processLeaveNode(e) { var n; const r = e[At]; if (r && r.setForRemoval) { if (e[At] = eE, r.namespaceId) { this.destroyInnerAnimations(e); const i = this._fetchNamespace(r.namespaceId); i && i.clearElementCache(e) } this._onRemovalComplete(e, r.setForRemoval) } (null === (n = e.classList) || void 0 === n ? void 0 : n.contains(gf)) && this.markElementAsDisabled(e, !1), this.driver.query(e, ".ng-animate-disabled", !0).forEach(i => { this.markElementAsDisabled(i, !1) }) } flush(e = -1) { let n = []; if (this.newHostElements.size && (this.newHostElements.forEach((r, i) => this._balanceNamespaceList(r, i)), this.newHostElements.clear()), this.totalAnimations && this.collectedEnterElements.length) for (let r = 0; r < this.collectedEnterElements.length; r++)Rt(this.collectedEnterElements[r], "ng-star-inserted"); if (this._namespaceList.length && (this.totalQueuedPlayers || this.collectedLeaveElements.length)) { const r = []; try { n = this._flushAnimations(r, e) } finally { for (let i = 0; i < r.length; i++)r[i]() } } else for (let r = 0; r < this.collectedLeaveElements.length; r++)this.processLeaveNode(this.collectedLeaveElements[r]); if (this.totalQueuedPlayers = 0, this.collectedEnterElements.length = 0, this.collectedLeaveElements.length = 0, this._flushFns.forEach(r => r()), this._flushFns = [], this._whenQuietFns.length) { const r = this._whenQuietFns; this._whenQuietFns = [], n.length ? Wn(n).onDone(() => { r.forEach(i => i()) }) : r.forEach(i => i()) } } reportError(e) { throw function TP(t) { return new M(3402, K) }() } _flushAnimations(e, n) { const r = new Ya, i = [], s = new Map, o = [], a = new Map, l = new Map, u = new Map, c = new Set; this.disabledNodes.forEach(w => { c.add(w); const I = this.driver.query(w, ".ng-animate-queued", !0); for (let x = 0; x < I.length; x++)c.add(I[x]) }); const d = this.bodyNode, f = Array.from(this.statesByElement.keys()), h = rE(f, this.collectedEnterElements), p = new Map; let g = 0; h.forEach((w, I) => { const x = tf + g++; p.set(I, x), w.forEach(Y => Rt(Y, x)) }); const y = [], _ = new Set, m = new Set; for (let w = 0; w < this.collectedLeaveElements.length; w++) { const I = this.collectedLeaveElements[w], x = I[At]; x && x.setForRemoval && (y.push(I), _.add(I), x.hasAnimation ? this.driver.query(I, ".ng-star-inserted", !0).forEach(Y => _.add(Y)) : m.add(I)) } const D = new Map, T = rE(f, Array.from(_)); T.forEach((w, I) => { const x = Ba + g++; D.set(I, x), w.forEach(Y => Rt(Y, x)) }), e.push(() => { h.forEach((w, I) => { const x = p.get(I); w.forEach(Y => Ci(Y, x)) }), T.forEach((w, I) => { const x = D.get(I); w.forEach(Y => Ci(Y, x)) }), y.forEach(w => { this.processLeaveNode(w) }) }); const $ = [], le = []; for (let w = this._namespaceList.length - 1; w >= 0; w--)this._namespaceList[w].drainQueuedTransitions(n).forEach(x => { const Y = x.player, Pe = x.element; if ($.push(Y), this.collectedEnterElements.length) { const Je = Pe[At]; if (Je && Je.setForMove) { if (Je.previousTriggersValues && Je.previousTriggersValues.has(x.triggerName)) { const Mr = Je.previousTriggersValues.get(x.triggerName), Yn = this.statesByElement.get(x.element); Yn && Yn[x.triggerName] && (Yn[x.triggerName].value = Mr) } return void Y.destroy() } } const an = !d || !this.driver.containsElement(d, Pe), _t = D.get(Pe), Zn = p.get(Pe), fe = this._buildInstruction(x, r, Zn, _t, an); if (fe.errors && fe.errors.length) return void le.push(fe); if (an) return Y.onStart(() => Cr(Pe, fe.fromStyles)), Y.onDestroy(() => on(Pe, fe.toStyles)), void i.push(Y); if (x.isFallbackTransition) return Y.onStart(() => Cr(Pe, fe.fromStyles)), Y.onDestroy(() => on(Pe, fe.toStyles)), void i.push(Y); const UE = []; fe.timelines.forEach(Je => { Je.stretchStartingKeyframe = !0, this.disabledNodes.has(Je.element) || UE.push(Je) }), fe.timelines = UE, r.append(Pe, fe.timelines), o.push({ instruction: fe, player: Y, element: Pe }), fe.queriedElements.forEach(Je => ht(a, Je, []).push(Y)), fe.preStyleProps.forEach((Je, Mr) => { const Yn = Object.keys(Je); if (Yn.length) { let Tr = l.get(Mr); Tr || l.set(Mr, Tr = new Set), Yn.forEach(Nf => Tr.add(Nf)) } }), fe.postStyleProps.forEach((Je, Mr) => { const Yn = Object.keys(Je); let Tr = u.get(Mr); Tr || u.set(Mr, Tr = new Set), Yn.forEach(Nf => Tr.add(Nf)) }) }); if (le.length) { const w = []; le.forEach(I => { w.push(function SP(t, e) { return new M(3505, K) }()) }), $.forEach(I => I.destroy()), this.reportError(w) } const de = new Map, gt = new Map; o.forEach(w => { const I = w.element; r.has(I) && (gt.set(I, I), this._beforeAnimationBuild(w.player.namespaceId, w.instruction, de)) }), i.forEach(w => { const I = w.element; this._getPreviousPlayers(I, !1, w.namespaceId, w.triggerName, null).forEach(Y => { ht(de, I, []).push(Y), Y.destroy() }) }); const mt = y.filter(w => sE(w, l, u)), yt = new Map; nE(yt, this.driver, m, u, Mn).forEach(w => { sE(w, l, u) && mt.push(w) }); const Sn = new Map; h.forEach((w, I) => { nE(Sn, this.driver, new Set(w), l, "!") }), mt.forEach(w => { const I = yt.get(w), x = Sn.get(w); yt.set(w, Object.assign(Object.assign({}, I), x)) }); const Gt = [], Mi = [], Ti = {}; o.forEach(w => { const { element: I, player: x, instruction: Y } = w; if (r.has(I)) { if (c.has(I)) return x.onDestroy(() => on(I, Y.toStyles)), x.disabled = !0, x.overrideTotalTime(Y.totalTime), void i.push(x); let Pe = Ti; if (gt.size > 1) { let _t = I; const Zn = []; for (; _t = _t.parentNode;) { const fe = gt.get(_t); if (fe) { Pe = fe; break } Zn.push(_t) } Zn.forEach(fe => gt.set(fe, Pe)) } const an = this._buildAnimation(x.namespaceId, Y, de, s, Sn, yt); if (x.setRealPlayer(an), Pe === Ti) Gt.push(x); else { const _t = this.playersByElement.get(Pe); _t && _t.length && (x.parentPlayer = Wn(_t)), i.push(x) } } else Cr(I, Y.fromStyles), x.onDestroy(() => on(I, Y.toStyles)), Mi.push(x), c.has(I) && i.push(x) }), Mi.forEach(w => { const I = s.get(w.element); if (I && I.length) { const x = Wn(I); w.setRealPlayer(x) } }), i.forEach(w => { w.parentPlayer ? w.syncPlayerEvents(w.parentPlayer) : w.destroy() }); for (let w = 0; w < y.length; w++) { const I = y[w], x = I[At]; if (Ci(I, Ba), x && x.hasAnimation) continue; let Y = []; if (a.size) { let an = a.get(I); an && an.length && Y.push(...an); let _t = this.driver.query(I, nf, !0); for (let Zn = 0; Zn < _t.length; Zn++) { let fe = a.get(_t[Zn]); fe && fe.length && Y.push(...fe) } } const Pe = Y.filter(an => !an.destroyed); Pe.length ? I1(this, I, Pe) : this.processLeaveNode(I) } return y.length = 0, Gt.forEach(w => { this.players.push(w), w.onDone(() => { w.destroy(); const I = this.players.indexOf(w); this.players.splice(I, 1) }), w.play() }), Gt } elementContainsData(e, n) { let r = !1; const i = n[At]; return i && i.setForRemoval && (r = !0), this.playersByElement.has(n) && (r = !0), this.playersByQueriedElement.has(n) && (r = !0), this.statesByElement.has(n) && (r = !0), this._fetchNamespace(e).elementContainsData(n) || r } afterFlush(e) { this._flushFns.push(e) } afterFlushAnimationsDone(e) { this._whenQuietFns.push(e) } _getPreviousPlayers(e, n, r, i, s) { let o = []; if (n) { const a = this.playersByQueriedElement.get(e); a && (o = a) } else { const a = this.playersByElement.get(e); if (a) { const l = !s || s == $s; a.forEach(u => { u.queued || !l && u.triggerName != i || o.push(u) }) } } return (r || i) && (o = o.filter(a => !(r && r != a.namespaceId || i && i != a.triggerName))), o } _beforeAnimationBuild(e, n, r) { const s = n.element, o = n.isRemovalTransition ? void 0 : e, a = n.isRemovalTransition ? void 0 : n.triggerName; for (const l of n.timelines) { const u = l.element, c = u !== s, d = ht(r, u, []); this._getPreviousPlayers(u, c, o, a, n.toState).forEach(h => { const p = h.getRealPlayer(); p.beforeDestroy && p.beforeDestroy(), h.destroy(), d.push(h) }) } Cr(s, n.fromStyles) } _buildAnimation(e, n, r, i, s, o) { const a = n.triggerName, l = n.element, u = [], c = new Set, d = new Set, f = n.timelines.map(p => { const g = p.element; c.add(g); const y = g[At]; if (y && y.removedBeforeQueried) return new Us(p.duration, p.delay); const _ = g !== l, m = function A1(t) { const e = []; return iE(t, e), e }((r.get(g) || E1).map(de => de.getRealPlayer())).filter(de => !!de.element && de.element === g), D = s.get(g), T = o.get(g), $ = RD(0, this._normalizer, 0, p.keyframes, D, T), le = this._buildPlayer(p, $, m); if (p.subTimeline && i && d.add(g), _) { const de = new _f(e, a, g); de.setRealPlayer(le), u.push(de) } return le }); u.forEach(p => { ht(this.playersByQueriedElement, p.element, []).push(p), p.onDone(() => function M1(t, e, n) { let r; if (t instanceof Map) { if (r = t.get(e), r) { if (r.length) { const i = r.indexOf(n); r.splice(i, 1) } 0 == r.length && t.delete(e) } } else if (r = t[e], r) { if (r.length) { const i = r.indexOf(n); r.splice(i, 1) } 0 == r.length && delete t[e] } return r }(this.playersByQueriedElement, p.element, p)) }), c.forEach(p => Rt(p, VD)); const h = Wn(f); return h.onDestroy(() => { c.forEach(p => Ci(p, VD)), on(l, n.toStyles) }), d.forEach(p => { ht(i, p, []).push(h) }), h } _buildPlayer(e, n, r) { return n.length > 0 ? this.driver.animate(e.element, n, e.duration, e.delay, e.easing, r) : new Us(e.duration, e.delay) } } class _f { constructor(e, n, r) { this.namespaceId = e, this.triggerName = n, this.element = r, this._player = new Us, this._containsRealPlayer = !1, this._queuedCallbacks = {}, this.destroyed = !1, this.markedForDestroy = !1, this.disabled = !1, this.queued = !0, this.totalTime = 0 } setRealPlayer(e) { this._containsRealPlayer || (this._player = e, Object.keys(this._queuedCallbacks).forEach(n => { this._queuedCallbacks[n].forEach(r => Qd(e, n, void 0, r)) }), this._queuedCallbacks = {}, this._containsRealPlayer = !0, this.overrideTotalTime(e.totalTime), this.queued = !1) } getRealPlayer() { return this._player } overrideTotalTime(e) { this.totalTime = e } syncPlayerEvents(e) { const n = this._player; n.triggerCallback && e.onStart(() => n.triggerCallback("start")), e.onDone(() => this.finish()), e.onDestroy(() => this.destroy()) } _queueEvent(e, n) { ht(this._queuedCallbacks, e, []).push(n) } onDone(e) { this.queued && this._queueEvent("done", e), this._player.onDone(e) } onStart(e) { this.queued && this._queueEvent("start", e), this._player.onStart(e) } onDestroy(e) { this.queued && this._queueEvent("destroy", e), this._player.onDestroy(e) } init() { this._player.init() } hasStarted() { return !this.queued && this._player.hasStarted() } play() { !this.queued && this._player.play() } pause() { !this.queued && this._player.pause() } restart() { !this.queued && this._player.restart() } finish() { this._player.finish() } destroy() { this.destroyed = !0, this._player.destroy() } reset() { !this.queued && this._player.reset() } setPosition(e) { this.queued || this._player.setPosition(e) } getPosition() { return this.queued ? 0 : this._player.getPosition() } triggerCallback(e) { const n = this._player; n.triggerCallback && n.triggerCallback(e) } } function el(t) { return t && 1 === t.nodeType } function tE(t, e) { const n = t.style.display; return t.style.display = null != e ? e : "none", n } function nE(t, e, n, r, i) { const s = []; n.forEach(l => s.push(tE(l))); const o = []; r.forEach((l, u) => { const c = {}; l.forEach(d => { const f = c[d] = e.computeStyle(u, d, i); (!f || 0 == f.length) && (u[At] = C1, o.push(u)) }), t.set(u, c) }); let a = 0; return n.forEach(l => tE(l, s[a++])), o } function rE(t, e) { const n = new Map; if (t.forEach(a => n.set(a, [])), 0 == e.length) return n; const i = new Set(e), s = new Map; function o(a) { if (!a) return 1; let l = s.get(a); if (l) return l; const u = a.parentNode; return l = n.has(u) ? u : i.has(u) ? 1 : o(u), s.set(a, l), l } return e.forEach(a => { const l = o(a); 1 !== l && n.get(l).push(a) }), n } function Rt(t, e) { var n; null === (n = t.classList) || void 0 === n || n.add(e) } function Ci(t, e) { var n; null === (n = t.classList) || void 0 === n || n.remove(e) } function I1(t, e, n) { Wn(n).onDone(() => t.processLeaveNode(e)) } function iE(t, e) { for (let n = 0; n < t.length; n++) { const r = t[n]; r instanceof ID ? iE(r.players, e) : e.push(r) } } function sE(t, e, n) { const r = n.get(t); if (!r) return !1; let i = e.get(t); return i ? r.forEach(s => i.add(s)) : e.set(t, r), n.delete(t), !0 } class tl { constructor(e, n, r) { this.bodyNode = e, this._driver = n, this._normalizer = r, this._triggerCache = {}, this.onRemovalComplete = (i, s) => { }, this._transitionEngine = new w1(e, n, r), this._timelineEngine = new m1(e, n, r), this._transitionEngine.onRemovalComplete = (i, s) => this.onRemovalComplete(i, s) } registerTrigger(e, n, r, i, s) { const o = e + "-" + i; let a = this._triggerCache[o]; if (!a) { const l = [], c = lf(this._driver, s, l, []); if (l.length) throw function mP(t, e) { return new M(3404, K) }(); a = function f1(t, e, n) { return new h1(t, e, n) }(i, c, this._normalizer), this._triggerCache[o] = a } this._transitionEngine.registerTrigger(n, i, a) } register(e, n) { this._transitionEngine.register(e, n) } destroy(e, n) { this._transitionEngine.destroy(e, n) } onInsert(e, n, r, i) { this._transitionEngine.insertNode(e, n, r, i) } onRemove(e, n, r, i) { this._transitionEngine.removeNode(e, n, i || !1, r) } disableAnimations(e, n) { this._transitionEngine.markElementAsDisabled(e, n) } process(e, n, r, i) { if ("@" == r.charAt(0)) { const [s, o] = OD(r); this._timelineEngine.command(s, n, o, i) } else this._transitionEngine.trigger(e, n, r, i) } listen(e, n, r, i, s) { if ("@" == r.charAt(0)) { const [o, a] = OD(r); return this._timelineEngine.listen(o, n, a, s) } return this._transitionEngine.listen(e, n, r, i, s) } flush(e = -1) { this._transitionEngine.flush(e) } get players() { return this._transitionEngine.players.concat(this._timelineEngine.players) } whenRenderingDone() { return this._transitionEngine.whenRenderingDone() } } let N1 = (() => { class t { constructor(n, r, i) { this._element = n, this._startStyles = r, this._endStyles = i, this._state = 0; let s = t.initialStylesByElement.get(n); s || t.initialStylesByElement.set(n, s = {}), this._initialStyles = s } start() { this._state < 1 && (this._startStyles && on(this._element, this._startStyles, this._initialStyles), this._state = 1) } finish() { this.start(), this._state < 2 && (on(this._element, this._initialStyles), this._endStyles && (on(this._element, this._endStyles), this._endStyles = null), this._state = 1) } destroy() { this.finish(), this._state < 3 && (t.initialStylesByElement.delete(this._element), this._startStyles && (Cr(this._element, this._startStyles), this._endStyles = null), this._endStyles && (Cr(this._element, this._endStyles), this._endStyles = null), on(this._element, this._initialStyles), this._state = 3) } } return t.initialStylesByElement = new WeakMap, t })(); function vf(t) { let e = null; const n = Object.keys(t); for (let r = 0; r < n.length; r++) { const i = n[r]; x1(i) && (e = e || {}, e[i] = t[i]) } return e } function x1(t) { return "display" === t || "position" === t } class oE { constructor(e, n, r, i) { this.element = e, this.keyframes = n, this.options = r, this._specialStyles = i, this._onDoneFns = [], this._onStartFns = [], this._onDestroyFns = [], this._initialized = !1, this._finished = !1, this._started = !1, this._destroyed = !1, this.time = 0, this.parentPlayer = null, this.currentSnapshot = {}, this._duration = r.duration, this._delay = r.delay || 0, this.time = this._duration + this._delay } _onFinish() { this._finished || (this._finished = !0, this._onDoneFns.forEach(e => e()), this._onDoneFns = []) } init() { this._buildPlayer(), this._preparePlayerBeforeStart() } _buildPlayer() { if (this._initialized) return; this._initialized = !0; const e = this.keyframes; this.domPlayer = this._triggerWebAnimation(this.element, e, this.options), this._finalKeyframe = e.length ? e[e.length - 1] : {}, this.domPlayer.addEventListener("finish", () => this._onFinish()) } _preparePlayerBeforeStart() { this._delay ? this._resetDomPlayerState() : this.domPlayer.pause() } _triggerWebAnimation(e, n, r) { return e.animate(n, r) } onStart(e) { this._onStartFns.push(e) } onDone(e) { this._onDoneFns.push(e) } onDestroy(e) { this._onDestroyFns.push(e) } play() { this._buildPlayer(), this.hasStarted() || (this._onStartFns.forEach(e => e()), this._onStartFns = [], this._started = !0, this._specialStyles && this._specialStyles.start()), this.domPlayer.play() } pause() { this.init(), this.domPlayer.pause() } finish() { this.init(), this._specialStyles && this._specialStyles.finish(), this._onFinish(), this.domPlayer.finish() } reset() { this._resetDomPlayerState(), this._destroyed = !1, this._finished = !1, this._started = !1 } _resetDomPlayerState() { this.domPlayer && this.domPlayer.cancel() } restart() { this.reset(), this.play() } hasStarted() { return this._started } destroy() { this._destroyed || (this._destroyed = !0, this._resetDomPlayerState(), this._onFinish(), this._specialStyles && this._specialStyles.destroy(), this._onDestroyFns.forEach(e => e()), this._onDestroyFns = []) } setPosition(e) { void 0 === this.domPlayer && this.init(), this.domPlayer.currentTime = e * this.time } getPosition() { return this.domPlayer.currentTime / this.time } get totalTime() { return this._delay + this._duration } beforeDestroy() { const e = {}; if (this.hasStarted()) { const n = this._finalKeyframe; Object.keys(n).forEach(r => { "offset" != r && (e[r] = this._finished ? n[r] : qD(this.element, r)) }) } this.currentSnapshot = e } triggerCallback(e) { const n = "start" == e ? this._onStartFns : this._onDoneFns; n.forEach(r => r()), n.length = 0 } } class F1 { validateStyleProperty(e) { return PD(e) } matchesElement(e, n) { return !1 } containsElement(e, n) { return kD(e, n) } getParentElement(e) { return Xd(e) } query(e, n, r) { return LD(e, n, r) } computeStyle(e, n, r) { return window.getComputedStyle(e)[n] } animate(e, n, r, i, s, o = []) { const l = { duration: r, delay: i, fill: 0 == i ? "both" : "forwards" }; s && (l.easing = s); const u = {}, c = o.filter(f => f instanceof oE); (function LP(t, e) { return 0 === t || 0 === e })(r, i) && c.forEach(f => { let h = f.currentSnapshot; Object.keys(h).forEach(p => u[p] = h[p]) }), n = function jP(t, e, n) { const r = Object.keys(n); if (r.length && e.length) { let s = e[0], o = []; if (r.forEach(a => { s.hasOwnProperty(a) || o.push(a), s[a] = n[a] }), o.length) for (var i = 1; i < e.length; i++) { let a = e[i]; o.forEach(function (l) { a[l] = qD(t, l) }) } } return e }(e, n = n.map(f => Kn(f, !1)), u); const d = function O1(t, e) { let n = null, r = null; return Array.isArray(e) && e.length ? (n = vf(e[0]), e.length > 1 && (r = vf(e[e.length - 1]))) : e && (n = vf(e)), n || r ? new N1(t, n, r) : null }(e, n); return new oE(e, n, l, d) } } let P1 = (() => { class t extends wD { constructor(n, r) { super(), this._nextAnimationId = 0, this._renderer = n.createRenderer(r.body, { id: "0", encapsulation: Nt.None, styles: [], data: { animation: [] } }) } build(n) { const r = this._nextAnimationId.toString(); this._nextAnimationId++; const i = Array.isArray(n) ? MD(n) : n; return aE(this._renderer, null, r, "register", [i]), new k1(r, this._renderer) } } return t.\u0275fac = function (n) { return new (n || t)(C(vs), C(Fe)) }, t.\u0275prov = F({ token: t, factory: t.\u0275fac }), t })(); class k1 extends class KF { }{ constructor(e, n) { super(), this._id = e, this._renderer = n } create(e, n) { return new L1(this._id, e, n || {}, this._renderer) } } class L1 { constructor(e, n, r, i) { this.id = e, this.element = n, this._renderer = i, this.parentPlayer = null, this._started = !1, this.totalTime = 0, this._command("create", r) } _listen(e, n) { return this._renderer.listen(this.element, `@@${this.id}:${e}`, n) } _command(e, ...n) { return aE(this._renderer, this.element, this.id, e, n) } onDone(e) { this._listen("done", e) } onStart(e) { this._listen("start", e) } onDestroy(e) { this._listen("destroy", e) } init() { this._command("init") } hasStarted() { return this._started } play() { this._command("play"), this._started = !0 } pause() { this._command("pause") } restart() { this._command("restart") } finish() { this._command("finish") } destroy() { this._command("destroy") } reset() { this._command("reset"), this._started = !1 } setPosition(e) { this._command("setPosition", e) } getPosition() { var e, n; return null !== (n = null === (e = this._renderer.engine.players[+this.id]) || void 0 === e ? void 0 : e.getPosition()) && void 0 !== n ? n : 0 } } function aE(t, e, n, r, i) { return t.setProperty(e, `@@${n}:${r}`, i) } const lE = "@.disabled"; let j1 = (() => { class t { constructor(n, r, i) { this.delegate = n, this.engine = r, this._zone = i, this._currentId = 0, this._microtaskId = 1, this._animationCallbacksBuffer = [], this._rendererCache = new Map, this._cdRecurDepth = 0, this.promise = Promise.resolve(0), r.onRemovalComplete = (s, o) => { const a = null == o ? void 0 : o.parentNode(s); a && o.removeChild(a, s) } } createRenderer(n, r) { const s = this.delegate.createRenderer(n, r); if (!(n && r && r.data && r.data.animation)) { let c = this._rendererCache.get(s); return c || (c = new uE("", s, this.engine), this._rendererCache.set(s, c)), c } const o = r.id, a = r.id + "-" + this._currentId; this._currentId++, this.engine.register(a, n); const l = c => { Array.isArray(c) ? c.forEach(l) : this.engine.registerTrigger(o, a, n, c.name, c) }; return r.data.animation.forEach(l), new B1(this, a, s, this.engine) } begin() { this._cdRecurDepth++, this.delegate.begin && this.delegate.begin() } _scheduleCountTask() { this.promise.then(() => { this._microtaskId++ }) } scheduleListenerCallback(n, r, i) { n >= 0 && n < this._microtaskId ? this._zone.run(() => r(i)) : (0 == this._animationCallbacksBuffer.length && Promise.resolve(null).then(() => { this._zone.run(() => { this._animationCallbacksBuffer.forEach(s => { const [o, a] = s; o(a) }), this._animationCallbacksBuffer = [] }) }), this._animationCallbacksBuffer.push([r, i])) } end() { this._cdRecurDepth--, 0 == this._cdRecurDepth && this._zone.runOutsideAngular(() => { this._scheduleCountTask(), this.engine.flush(this._microtaskId) }), this.delegate.end && this.delegate.end() } whenRenderingDone() { return this.engine.whenRenderingDone() } } return t.\u0275fac = function (n) { return new (n || t)(C(vs), C(tl), C(Te)) }, t.\u0275prov = F({ token: t, factory: t.\u0275fac }), t })(); class uE { constructor(e, n, r) { this.namespaceId = e, this.delegate = n, this.engine = r, this.destroyNode = this.delegate.destroyNode ? i => n.destroyNode(i) : null } get data() { return this.delegate.data } destroy() { this.engine.destroy(this.namespaceId, this.delegate), this.delegate.destroy() } createElement(e, n) { return this.delegate.createElement(e, n) } createComment(e) { return this.delegate.createComment(e) } createText(e) { return this.delegate.createText(e) } appendChild(e, n) { this.delegate.appendChild(e, n), this.engine.onInsert(this.namespaceId, n, e, !1) } insertBefore(e, n, r, i = !0) { this.delegate.insertBefore(e, n, r), this.engine.onInsert(this.namespaceId, n, e, i) } removeChild(e, n, r) { this.engine.onRemove(this.namespaceId, n, this.delegate, r) } selectRootElement(e, n) { return this.delegate.selectRootElement(e, n) } parentNode(e) { return this.delegate.parentNode(e) } nextSibling(e) { return this.delegate.nextSibling(e) } setAttribute(e, n, r, i) { this.delegate.setAttribute(e, n, r, i) } removeAttribute(e, n, r) { this.delegate.removeAttribute(e, n, r) } addClass(e, n) { this.delegate.addClass(e, n) } removeClass(e, n) { this.delegate.removeClass(e, n) } setStyle(e, n, r, i) { this.delegate.setStyle(e, n, r, i) } removeStyle(e, n, r) { this.delegate.removeStyle(e, n, r) } setProperty(e, n, r) { "@" == n.charAt(0) && n == lE ? this.disableAnimations(e, !!r) : this.delegate.setProperty(e, n, r) } setValue(e, n) { this.delegate.setValue(e, n) } listen(e, n, r) { return this.delegate.listen(e, n, r) } disableAnimations(e, n) { this.engine.disableAnimations(e, n) } } class B1 extends uE { constructor(e, n, r, i) { super(n, r, i), this.factory = e, this.namespaceId = n } setProperty(e, n, r) { "@" == n.charAt(0) ? "." == n.charAt(1) && n == lE ? this.disableAnimations(e, r = void 0 === r || !!r) : this.engine.process(this.namespaceId, e, n.substr(1), r) : this.delegate.setProperty(e, n, r) } listen(e, n, r) { if ("@" == n.charAt(0)) { const i = function V1(t) { switch (t) { case "body": return document.body; case "document": return document; case "window": return window; default: return t } }(e); let s = n.substr(1), o = ""; return "@" != s.charAt(0) && ([s, o] = function U1(t) { const e = t.indexOf("."); return [t.substring(0, e), t.substr(e + 1)] }(s)), this.engine.listen(this.namespaceId, i, s, o, a => { this.factory.scheduleListenerCallback(a._data || -1, r, a) }) } return this.delegate.listen(e, n, r) } } let H1 = (() => { class t extends tl { constructor(n, r, i) { super(n.body, r, i) } ngOnDestroy() { this.flush() } } return t.\u0275fac = function (n) { return new (n || t)(C(Fe), C(ef), C(hf)) }, t.\u0275prov = F({ token: t, factory: t.\u0275fac }), t })(); const Df = new O("AnimationModuleType"), cE = [{ provide: wD, useClass: P1 }, { provide: hf, useFactory: function $1() { return new a1 } }, { provide: tl, useClass: H1 }, { provide: vs, useFactory: function z1(t, e, n) { return new j1(t, e, n) }, deps: [Ea, tl, Te] }], dE = [{ provide: ef, useFactory: () => new F1 }, { provide: Df, useValue: "BrowserAnimations" }, ...cE], q1 = [{ provide: ef, useClass: jD }, { provide: Df, useValue: "NoopAnimations" }, ...cE]; let Ef, G1 = (() => { class t { static withConfig(n) { return { ngModule: t, providers: n.disableAnimations ? q1 : dE } } } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275mod = st({ type: t }), t.\u0275inj = Xe({ providers: dE, imports: [pv] }), t })(), fE = (() => { class t { } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275mod = st({ type: t }), t.\u0275inj = Xe({}), t })(); try { Ef = "undefined" != typeof Intl && Intl.v8BreakIterator } catch (t) { Ef = !1 } let Q1 = (() => { class t { constructor(n) { this._platformId = n, this.isBrowser = this._platformId ? function UO(t) { return t === tv }(this._platformId) : "object" == typeof document && !!document, this.EDGE = this.isBrowser && /(edge)/i.test(navigator.userAgent), this.TRIDENT = this.isBrowser && /(msie|trident)/i.test(navigator.userAgent), this.BLINK = this.isBrowser && !(!window.chrome && !Ef) && "undefined" != typeof CSS && !this.EDGE && !this.TRIDENT, this.WEBKIT = this.isBrowser && /AppleWebKit/i.test(navigator.userAgent) && !this.BLINK && !this.EDGE && !this.TRIDENT, this.IOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) && !("MSStream" in window), this.FIREFOX = this.isBrowser && /(firefox|minefield)/i.test(navigator.userAgent), this.ANDROID = this.isBrowser && /android/i.test(navigator.userAgent) && !this.TRIDENT, this.SAFARI = this.isBrowser && /safari/i.test(navigator.userAgent) && this.WEBKIT } } return t.\u0275fac = function (n) { return new (n || t)(C(na)) }, t.\u0275prov = F({ token: t, factory: t.\u0275fac, providedIn: "root" }), t })(); const _E = "cdk-high-contrast-black-on-white", vE = "cdk-high-contrast-white-on-black", wf = "cdk-high-contrast-active"; let fk = (() => { class t { constructor(n, r) { this._platform = n, this._document = r } getHighContrastMode() { if (!this._platform.isBrowser) return 0; const n = this._document.createElement("div"); n.style.backgroundColor = "rgb(1,2,3)", n.style.position = "absolute", this._document.body.appendChild(n); const r = this._document.defaultView || window, i = r && r.getComputedStyle ? r.getComputedStyle(n) : null, s = (i && i.backgroundColor || "").replace(/ /g, ""); switch (n.remove(), s) { case "rgb(0,0,0)": return 2; case "rgb(255,255,255)": return 1 }return 0 } _applyBodyHighContrastModeCssClasses() { if (!this._hasCheckedHighContrastMode && this._platform.isBrowser && this._document.body) { const n = this._document.body.classList; n.remove(wf), n.remove(_E), n.remove(vE), this._hasCheckedHighContrastMode = !0; const r = this.getHighContrastMode(); 1 === r ? (n.add(wf), n.add(_E)) : 2 === r && (n.add(wf), n.add(vE)) } } } return t.\u0275fac = function (n) { return new (n || t)(C(Q1), C(Fe)) }, t.\u0275prov = F({ token: t, factory: t.\u0275fac, providedIn: "root" }), t })(); const pk = new O("mat-sanity-checks", { providedIn: "root", factory: function hk() { return !0 } }); let EE = (() => { class t { constructor(n, r, i) { this._sanityChecks = r, this._document = i, this._hasDoneGlobalChecks = !1, n._applyBodyHighContrastModeCssClasses(), this._hasDoneGlobalChecks || (this._hasDoneGlobalChecks = !0) } _checkIsEnabled(n) { return !function J1() { return "undefined" != typeof __karma__ && !!__karma__ || "undefined" != typeof jasmine && !!jasmine || "undefined" != typeof jest && !!jest || "undefined" != typeof Mocha && !!Mocha }() && ("boolean" == typeof this._sanityChecks ? this._sanityChecks : !!this._sanityChecks[n]) } } return t.\u0275fac = function (n) { return new (n || t)(C(fk), C(pk, 8), C(Fe)) }, t.\u0275mod = st({ type: t }), t.\u0275inj = Xe({ imports: [[fE], fE] }), t })(); const Dk = ["*", [["mat-card-footer"]]], Ek = ["*", "mat-card-footer"]; let ME = (() => { class t { } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275dir = Ae({ type: t, selectors: [["mat-card-content"], ["", "mat-card-content", ""], ["", "matCardContent", ""]], hostAttrs: [1, "mat-card-content"] }), t })(), TE = (() => { class t { } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275dir = Ae({ type: t, selectors: [["mat-card-title"], ["", "mat-card-title", ""], ["", "matCardTitle", ""]], hostAttrs: [1, "mat-card-title"] }), t })(), SE = (() => { class t { constructor(n) { this._animationMode = n } } return t.\u0275fac = function (n) { return new (n || t)(S(Df, 8)) }, t.\u0275cmp = xt({ type: t, selectors: [["mat-card"]], hostAttrs: [1, "mat-card", "mat-focus-indicator"], hostVars: 2, hostBindings: function (n, r) { 2 & n && $o("_mat-animation-noopable", "NoopAnimations" === r._animationMode) }, exportAs: ["matCard"], ngContentSelectors: Ek, decls: 2, vars: 0, template: function (n, r) { 1 & n && (function pm(t) { const e = v()[16][6]; if (!e.projection) { const r = e.projection = qi(t ? t.length : 1, null), i = r.slice(); let s = e.child; for (; null !== s;) { const o = t ? NT(s, t) : 0; null !== o && (i[o] ? i[o].projectionNext = s : r[o] = s, i[o] = s), s = s.next } } }(Dk), dc(0), dc(1, 1)) }, styles: [".mat-card{transition:box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);display:block;position:relative;padding:16px;border-radius:4px}._mat-animation-noopable.mat-card{transition:none;animation:none}.mat-card .mat-divider-horizontal{position:absolute;left:0;width:100%}[dir=rtl] .mat-card .mat-divider-horizontal{left:auto;right:0}.mat-card .mat-divider-horizontal.mat-divider-inset{position:static;margin:0}[dir=rtl] .mat-card .mat-divider-horizontal.mat-divider-inset{margin-right:0}.cdk-high-contrast-active .mat-card{outline:solid 1px}.mat-card-actions,.mat-card-subtitle,.mat-card-content{display:block;margin-bottom:16px}.mat-card-title{display:block;margin-bottom:8px}.mat-card-actions{margin-left:-8px;margin-right:-8px;padding:8px 0}.mat-card-actions-align-end{display:flex;justify-content:flex-end}.mat-card-image{width:calc(100% + 32px);margin:0 -16px 16px -16px;display:block;overflow:hidden}.mat-card-image img{width:100%}.mat-card-footer{display:block;margin:0 -16px -16px -16px}.mat-card-actions .mat-button,.mat-card-actions .mat-raised-button,.mat-card-actions .mat-stroked-button{margin:0 8px}.mat-card-header{display:flex;flex-direction:row}.mat-card-header .mat-card-title{margin-bottom:12px}.mat-card-header-text{margin:0 16px}.mat-card-avatar{height:40px;width:40px;border-radius:50%;flex-shrink:0;object-fit:cover}.mat-card-title-group{display:flex;justify-content:space-between}.mat-card-sm-image{width:80px;height:80px}.mat-card-md-image{width:112px;height:112px}.mat-card-lg-image{width:152px;height:152px}.mat-card-xl-image{width:240px;height:240px;margin:-8px}.mat-card-title-group>.mat-card-xl-image{margin:-8px 0 8px}@media(max-width: 599px){.mat-card-title-group{margin:0}.mat-card-xl-image{margin-left:0;margin-right:0}}.mat-card>:first-child,.mat-card-content>:first-child{margin-top:0}.mat-card>:last-child:not(.mat-card-footer),.mat-card-content>:last-child:not(.mat-card-footer){margin-bottom:0}.mat-card-image:first-child{margin-top:-16px;border-top-left-radius:inherit;border-top-right-radius:inherit}.mat-card>.mat-card-actions:last-child{margin-bottom:-8px;padding-bottom:0}.mat-card-actions:not(.mat-card-actions-align-end) .mat-button:first-child,.mat-card-actions:not(.mat-card-actions-align-end) .mat-raised-button:first-child,.mat-card-actions:not(.mat-card-actions-align-end) .mat-stroked-button:first-child{margin-left:0;margin-right:0}.mat-card-actions-align-end .mat-button:last-child,.mat-card-actions-align-end .mat-raised-button:last-child,.mat-card-actions-align-end .mat-stroked-button:last-child{margin-left:0;margin-right:0}.mat-card-title:not(:first-child),.mat-card-subtitle:not(:first-child){margin-top:-4px}.mat-card-header .mat-card-subtitle:not(:first-child){margin-top:-8px}.mat-card>.mat-card-xl-image:first-child{margin-top:-8px}.mat-card>.mat-card-xl-image:last-child{margin-bottom:-8px}\n"], encapsulation: 2, changeDetection: 0 }), t })(), Ck = (() => { class t { } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275mod = st({ type: t }), t.\u0275inj = Xe({ imports: [[EE], EE] }), t })(), bk = (() => { class t { constructor(n) { this.router = n, this.menuCardClicked = new xe, this.headerText = "", this.infoText = "", this.url = "" } ngOnInit() { } onClick() { console.log("nav to , ", this.url), this.router.navigateByUrl(this.url) } } return t.\u0275fac = function (n) { return new (n || t)(S(Ye)) }, t.\u0275cmp = xt({ type: t, selectors: [["app-menu-card"]], inputs: { headerText: "headerText", infoText: "infoText", url: "url" }, outputs: { menuCardClicked: "menuCardClicked" }, decls: 8, vars: 2, consts: [[1, "menu-card", 3, "click"]], template: function (n, r) { 1 & n && (Oe(0, "div", 0), Vn("click", function () { return r.onClick() }), Oe(1, "mat-card")(2, "mat-card-title")(3, "h2"), Un(4), Ne()(), Oe(5, "mat-card-content")(6, "p"), Un(7), Ne()()()()), 2 & n && (wt(4), hs(r.headerText), wt(3), hs(r.infoText)) }, directives: [SE, TE, ME], styles: [".mat-card[_ngcontent-%COMP%]{background-color:#f2f2f2;padding:10px;border-radius:5px;width:70vw;min-height:15vh;text-align:center}.mat-card-header[_ngcontent-%COMP%]{font-size:20px;color:#333}"] }), t })(), wk = (() => { class t { constructor() { } ngOnInit() { } } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275cmp = xt({ type: t, selectors: [["app-home"]], decls: 7, vars: 9, consts: [[1, "home-page-container"], [1, "menu-card"], [3, "headerText", "infoText", "url"]], template: function (n, r) { 1 & n && (Oe(0, "div", 0)(1, "div", 1), Bn(2, "app-menu-card", 2), Ne(), Oe(3, "div", 1), Bn(4, "app-menu-card", 2), Ne(), Oe(5, "div", 1), Bn(6, "app-menu-card", 2), Ne()()), 2 & n && (wt(2), yn("headerText", "Stage List and Bans")("infoText", "Gateway Smash Rules")("url", "stage-list-bans"), wt(2), yn("headerText", "Power Rankings")("infoText", "Last updated: Jan 2024")("url", "power-rankings"), wt(2), yn("headerText", "Community")("infoText", "Resources and Links")("url", "community")) }, directives: [bk], styles: [".home-page-container[_ngcontent-%COMP%]{display:flex;flex-direction:column;align-items:center;gap:8px;margin-top:16px}"] }), t })(); class IE { } class AE { } class Tn { constructor(e) { this.normalizedNames = new Map, this.lazyUpdate = null, e ? this.lazyInit = "string" == typeof e ? () => { this.headers = new Map, e.split("\n").forEach(n => { const r = n.indexOf(":"); if (r > 0) { const i = n.slice(0, r), s = i.toLowerCase(), o = n.slice(r + 1).trim(); this.maybeSetNormalizedName(i, s), this.headers.has(s) ? this.headers.get(s).push(o) : this.headers.set(s, [o]) } }) } : () => { this.headers = new Map, Object.keys(e).forEach(n => { let r = e[n]; const i = n.toLowerCase(); "string" == typeof r && (r = [r]), r.length > 0 && (this.headers.set(i, r), this.maybeSetNormalizedName(n, i)) }) } : this.headers = new Map } has(e) { return this.init(), this.headers.has(e.toLowerCase()) } get(e) { this.init(); const n = this.headers.get(e.toLowerCase()); return n && n.length > 0 ? n[0] : null } keys() { return this.init(), Array.from(this.normalizedNames.values()) } getAll(e) { return this.init(), this.headers.get(e.toLowerCase()) || null } append(e, n) { return this.clone({ name: e, value: n, op: "a" }) } set(e, n) { return this.clone({ name: e, value: n, op: "s" }) } delete(e, n) { return this.clone({ name: e, value: n, op: "d" }) } maybeSetNormalizedName(e, n) { this.normalizedNames.has(n) || this.normalizedNames.set(n, e) } init() { this.lazyInit && (this.lazyInit instanceof Tn ? this.copyFrom(this.lazyInit) : this.lazyInit(), this.lazyInit = null, this.lazyUpdate && (this.lazyUpdate.forEach(e => this.applyUpdate(e)), this.lazyUpdate = null)) } copyFrom(e) { e.init(), Array.from(e.headers.keys()).forEach(n => { this.headers.set(n, e.headers.get(n)), this.normalizedNames.set(n, e.normalizedNames.get(n)) }) } clone(e) { const n = new Tn; return n.lazyInit = this.lazyInit && this.lazyInit instanceof Tn ? this.lazyInit : this, n.lazyUpdate = (this.lazyUpdate || []).concat([e]), n } applyUpdate(e) { const n = e.name.toLowerCase(); switch (e.op) { case "a": case "s": let r = e.value; if ("string" == typeof r && (r = [r]), 0 === r.length) return; this.maybeSetNormalizedName(e.name, n); const i = ("a" === e.op ? this.headers.get(n) : void 0) || []; i.push(...r), this.headers.set(n, i); break; case "d": const s = e.value; if (s) { let o = this.headers.get(n); if (!o) return; o = o.filter(a => -1 === s.indexOf(a)), 0 === o.length ? (this.headers.delete(n), this.normalizedNames.delete(n)) : this.headers.set(n, o) } else this.headers.delete(n), this.normalizedNames.delete(n) } } forEach(e) { this.init(), Array.from(this.normalizedNames.keys()).forEach(n => e(this.normalizedNames.get(n), this.headers.get(n))) } } class Mk { encodeKey(e) { return RE(e) } encodeValue(e) { return RE(e) } decodeKey(e) { return decodeURIComponent(e) } decodeValue(e) { return decodeURIComponent(e) } } const Sk = /%(\d[a-f0-9])/gi, Ik = { 40: "@", "3A": ":", 24: "$", "2C": ",", "3B": ";", "2B": "+", "3D": "=", "3F": "?", "2F": "/" }; function RE(t) { return encodeURIComponent(t).replace(Sk, (e, n) => { var r; return null !== (r = Ik[n]) && void 0 !== r ? r : e }) } function OE(t) { return `${t}` } class Qn { constructor(e = {}) { if (this.updates = null, this.cloneFrom = null, this.encoder = e.encoder || new Mk, e.fromString) { if (e.fromObject) throw new Error("Cannot specify both fromString and fromObject."); this.map = function Tk(t, e) { const n = new Map; return t.length > 0 && t.replace(/^\?/, "").split("&").forEach(i => { const s = i.indexOf("="), [o, a] = -1 == s ? [e.decodeKey(i), ""] : [e.decodeKey(i.slice(0, s)), e.decodeValue(i.slice(s + 1))], l = n.get(o) || []; l.push(a), n.set(o, l) }), n }(e.fromString, this.encoder) } else e.fromObject ? (this.map = new Map, Object.keys(e.fromObject).forEach(n => { const r = e.fromObject[n]; this.map.set(n, Array.isArray(r) ? r : [r]) })) : this.map = null } has(e) { return this.init(), this.map.has(e) } get(e) { this.init(); const n = this.map.get(e); return n ? n[0] : null } getAll(e) { return this.init(), this.map.get(e) || null } keys() { return this.init(), Array.from(this.map.keys()) } append(e, n) { return this.clone({ param: e, value: n, op: "a" }) } appendAll(e) { const n = []; return Object.keys(e).forEach(r => { const i = e[r]; Array.isArray(i) ? i.forEach(s => { n.push({ param: r, value: s, op: "a" }) }) : n.push({ param: r, value: i, op: "a" }) }), this.clone(n) } set(e, n) { return this.clone({ param: e, value: n, op: "s" }) } delete(e, n) { return this.clone({ param: e, value: n, op: "d" }) } toString() { return this.init(), this.keys().map(e => { const n = this.encoder.encodeKey(e); return this.map.get(e).map(r => n + "=" + this.encoder.encodeValue(r)).join("&") }).filter(e => "" !== e).join("&") } clone(e) { const n = new Qn({ encoder: this.encoder }); return n.cloneFrom = this.cloneFrom || this, n.updates = (this.updates || []).concat(e), n } init() { null === this.map && (this.map = new Map), null !== this.cloneFrom && (this.cloneFrom.init(), this.cloneFrom.keys().forEach(e => this.map.set(e, this.cloneFrom.map.get(e))), this.updates.forEach(e => { switch (e.op) { case "a": case "s": const n = ("a" === e.op ? this.map.get(e.param) : void 0) || []; n.push(OE(e.value)), this.map.set(e.param, n); break; case "d": if (void 0 === e.value) { this.map.delete(e.param); break } { let r = this.map.get(e.param) || []; const i = r.indexOf(OE(e.value)); -1 !== i && r.splice(i, 1), r.length > 0 ? this.map.set(e.param, r) : this.map.delete(e.param) } } }), this.cloneFrom = this.updates = null) } } class Ak { constructor() { this.map = new Map } set(e, n) { return this.map.set(e, n), this } get(e) { return this.map.has(e) || this.map.set(e, e.defaultValue()), this.map.get(e) } delete(e) { return this.map.delete(e), this } has(e) { return this.map.has(e) } keys() { return this.map.keys() } } function NE(t) { return "undefined" != typeof ArrayBuffer && t instanceof ArrayBuffer } function xE(t) { return "undefined" != typeof Blob && t instanceof Blob } function FE(t) { return "undefined" != typeof FormData && t instanceof FormData } class Gs { constructor(e, n, r, i) { let s; if (this.url = n, this.body = null, this.reportProgress = !1, this.withCredentials = !1, this.responseType = "json", this.method = e.toUpperCase(), function Rk(t) { switch (t) { case "DELETE": case "GET": case "HEAD": case "OPTIONS": case "JSONP": return !1; default: return !0 } }(this.method) || i ? (this.body = void 0 !== r ? r : null, s = i) : s = r, s && (this.reportProgress = !!s.reportProgress, this.withCredentials = !!s.withCredentials, s.responseType && (this.responseType = s.responseType), s.headers && (this.headers = s.headers), s.context && (this.context = s.context), s.params && (this.params = s.params)), this.headers || (this.headers = new Tn), this.context || (this.context = new Ak), this.params) { const o = this.params.toString(); if (0 === o.length) this.urlWithParams = n; else { const a = n.indexOf("?"); this.urlWithParams = n + (-1 === a ? "?" : a < n.length - 1 ? "&" : "") + o } } else this.params = new Qn, this.urlWithParams = n } serializeBody() { return null === this.body ? null : NE(this.body) || xE(this.body) || FE(this.body) || function Ok(t) { return "undefined" != typeof URLSearchParams && t instanceof URLSearchParams }(this.body) || "string" == typeof this.body ? this.body : this.body instanceof Qn ? this.body.toString() : "object" == typeof this.body || "boolean" == typeof this.body || Array.isArray(this.body) ? JSON.stringify(this.body) : this.body.toString() } detectContentTypeHeader() { return null === this.body || FE(this.body) ? null : xE(this.body) ? this.body.type || null : NE(this.body) ? null : "string" == typeof this.body ? "text/plain" : this.body instanceof Qn ? "application/x-www-form-urlencoded;charset=UTF-8" : "object" == typeof this.body || "number" == typeof this.body || "boolean" == typeof this.body ? "application/json" : null } clone(e = {}) { var n; const r = e.method || this.method, i = e.url || this.url, s = e.responseType || this.responseType, o = void 0 !== e.body ? e.body : this.body, a = void 0 !== e.withCredentials ? e.withCredentials : this.withCredentials, l = void 0 !== e.reportProgress ? e.reportProgress : this.reportProgress; let u = e.headers || this.headers, c = e.params || this.params; const d = null !== (n = e.context) && void 0 !== n ? n : this.context; return void 0 !== e.setHeaders && (u = Object.keys(e.setHeaders).reduce((f, h) => f.set(h, e.setHeaders[h]), u)), e.setParams && (c = Object.keys(e.setParams).reduce((f, h) => f.set(h, e.setParams[h]), c)), new Gs(r, i, o, { params: c, headers: u, context: d, reportProgress: l, responseType: s, withCredentials: a }) } } var Ce = (() => ((Ce = Ce || {})[Ce.Sent = 0] = "Sent", Ce[Ce.UploadProgress = 1] = "UploadProgress", Ce[Ce.ResponseHeader = 2] = "ResponseHeader", Ce[Ce.DownloadProgress = 3] = "DownloadProgress", Ce[Ce.Response = 4] = "Response", Ce[Ce.User = 5] = "User", Ce))(); class Tf { constructor(e, n = 200, r = "OK") { this.headers = e.headers || new Tn, this.status = void 0 !== e.status ? e.status : n, this.statusText = e.statusText || r, this.url = e.url || null, this.ok = this.status >= 200 && this.status < 300 } } class Sf extends Tf { constructor(e = {}) { super(e), this.type = Ce.ResponseHeader } clone(e = {}) { return new Sf({ headers: e.headers || this.headers, status: void 0 !== e.status ? e.status : this.status, statusText: e.statusText || this.statusText, url: e.url || this.url || void 0 }) } } class il extends Tf { constructor(e = {}) { super(e), this.type = Ce.Response, this.body = void 0 !== e.body ? e.body : null } clone(e = {}) { return new il({ body: void 0 !== e.body ? e.body : this.body, headers: e.headers || this.headers, status: void 0 !== e.status ? e.status : this.status, statusText: e.statusText || this.statusText, url: e.url || this.url || void 0 }) } } class PE extends Tf { constructor(e) { super(e, 0, "Unknown Error"), this.name = "HttpErrorResponse", this.ok = !1, this.message = this.status >= 200 && this.status < 300 ? `Http failure during parsing for ${e.url || "(unknown url)"}` : `Http failure response for ${e.url || "(unknown url)"}: ${e.status} ${e.statusText}`, this.error = e.error || null } } function If(t, e) { return { body: e, headers: t.headers, context: t.context, observe: t.observe, params: t.params, reportProgress: t.reportProgress, responseType: t.responseType, withCredentials: t.withCredentials } } let kE = (() => { class t { constructor(n) { this.handler = n } request(n, r, i = {}) { let s; if (n instanceof Gs) s = n; else { let l, u; l = i.headers instanceof Tn ? i.headers : new Tn(i.headers), i.params && (u = i.params instanceof Qn ? i.params : new Qn({ fromObject: i.params })), s = new Gs(n, r, void 0 !== i.body ? i.body : null, { headers: l, context: i.context, params: u, reportProgress: i.reportProgress, responseType: i.responseType || "json", withCredentials: i.withCredentials }) } const o = V(s).pipe(gi(l => this.handler.handle(l))); if (n instanceof Gs || "events" === i.observe) return o; const a = o.pipe(gr(l => l instanceof il)); switch (i.observe || "body") { case "body": switch (s.responseType) { case "arraybuffer": return a.pipe(J(l => { if (null !== l.body && !(l.body instanceof ArrayBuffer)) throw new Error("Response is not an ArrayBuffer."); return l.body })); case "blob": return a.pipe(J(l => { if (null !== l.body && !(l.body instanceof Blob)) throw new Error("Response is not a Blob."); return l.body })); case "text": return a.pipe(J(l => { if (null !== l.body && "string" != typeof l.body) throw new Error("Response is not a string."); return l.body })); default: return a.pipe(J(l => l.body)) }case "response": return a; default: throw new Error(`Unreachable: unhandled observe type ${i.observe}}`) } } delete(n, r = {}) { return this.request("DELETE", n, r) } get(n, r = {}) { return this.request("GET", n, r) } head(n, r = {}) { return this.request("HEAD", n, r) } jsonp(n, r) { return this.request("JSONP", n, { params: (new Qn).append(r, "JSONP_CALLBACK"), observe: "body", responseType: "json" }) } options(n, r = {}) { return this.request("OPTIONS", n, r) } patch(n, r, i = {}) { return this.request("PATCH", n, If(i, r)) } post(n, r, i = {}) { return this.request("POST", n, If(i, r)) } put(n, r, i = {}) { return this.request("PUT", n, If(i, r)) } } return t.\u0275fac = function (n) { return new (n || t)(C(IE)) }, t.\u0275prov = F({ token: t, factory: t.\u0275fac }), t })(); class LE { constructor(e, n) { this.next = e, this.interceptor = n } handle(e) { return this.interceptor.intercept(e, this.next) } } const jE = new O("HTTP_INTERCEPTORS"); let Nk = (() => { class t { intercept(n, r) { return r.handle(n) } } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275prov = F({ token: t, factory: t.\u0275fac }), t })(); const xk = /^\)\]\}',?\n/; let BE = (() => { class t { constructor(n) { this.xhrFactory = n } handle(n) { if ("JSONP" === n.method) throw new Error("Attempted to construct Jsonp request without HttpClientJsonpModule installed."); return new ye(r => { const i = this.xhrFactory.build(); if (i.open(n.method, n.urlWithParams), n.withCredentials && (i.withCredentials = !0), n.headers.forEach((h, p) => i.setRequestHeader(h, p.join(","))), n.headers.has("Accept") || i.setRequestHeader("Accept", "application/json, text/plain, */*"), !n.headers.has("Content-Type")) { const h = n.detectContentTypeHeader(); null !== h && i.setRequestHeader("Content-Type", h) } if (n.responseType) { const h = n.responseType.toLowerCase(); i.responseType = "json" !== h ? h : "text" } const s = n.serializeBody(); let o = null; const a = () => { if (null !== o) return o; const h = i.statusText || "OK", p = new Tn(i.getAllResponseHeaders()), g = function Fk(t) { return "responseURL" in t && t.responseURL ? t.responseURL : /^X-Request-URL:/m.test(t.getAllResponseHeaders()) ? t.getResponseHeader("X-Request-URL") : null }(i) || n.url; return o = new Sf({ headers: p, status: i.status, statusText: h, url: g }), o }, l = () => { let { headers: h, status: p, statusText: g, url: y } = a(), _ = null; 204 !== p && (_ = void 0 === i.response ? i.responseText : i.response), 0 === p && (p = _ ? 200 : 0); let m = p >= 200 && p < 300; if ("json" === n.responseType && "string" == typeof _) { const D = _; _ = _.replace(xk, ""); try { _ = "" !== _ ? JSON.parse(_) : null } catch (T) { _ = D, m && (m = !1, _ = { error: T, text: _ }) } } m ? (r.next(new il({ body: _, headers: h, status: p, statusText: g, url: y || void 0 })), r.complete()) : r.error(new PE({ error: _, headers: h, status: p, statusText: g, url: y || void 0 })) }, u = h => { const { url: p } = a(), g = new PE({ error: h, status: i.status || 0, statusText: i.statusText || "Unknown Error", url: p || void 0 }); r.error(g) }; let c = !1; const d = h => { c || (r.next(a()), c = !0); let p = { type: Ce.DownloadProgress, loaded: h.loaded }; h.lengthComputable && (p.total = h.total), "text" === n.responseType && !!i.responseText && (p.partialText = i.responseText), r.next(p) }, f = h => { let p = { type: Ce.UploadProgress, loaded: h.loaded }; h.lengthComputable && (p.total = h.total), r.next(p) }; return i.addEventListener("load", l), i.addEventListener("error", u), i.addEventListener("timeout", u), i.addEventListener("abort", u), n.reportProgress && (i.addEventListener("progress", d), null !== s && i.upload && i.upload.addEventListener("progress", f)), i.send(s), r.next({ type: Ce.Sent }), () => { i.removeEventListener("error", u), i.removeEventListener("abort", u), i.removeEventListener("load", l), i.removeEventListener("timeout", u), n.reportProgress && (i.removeEventListener("progress", d), null !== s && i.upload && i.upload.removeEventListener("progress", f)), i.readyState !== i.DONE && i.abort() } }) } } return t.\u0275fac = function (n) { return new (n || t)(C(rv)) }, t.\u0275prov = F({ token: t, factory: t.\u0275fac }), t })(); const Af = new O("XSRF_COOKIE_NAME"), Rf = new O("XSRF_HEADER_NAME"); class VE { } let Pk = (() => { class t { constructor(n, r, i) { this.doc = n, this.platform = r, this.cookieName = i, this.lastCookieString = "", this.lastToken = null, this.parseCount = 0 } getToken() { if ("server" === this.platform) return null; const n = this.doc.cookie || ""; return n !== this.lastCookieString && (this.parseCount++, this.lastToken = Q_(n, this.cookieName), this.lastCookieString = n), this.lastToken } } return t.\u0275fac = function (n) { return new (n || t)(C(Fe), C(na), C(Af)) }, t.\u0275prov = F({ token: t, factory: t.\u0275fac }), t })(), Of = (() => { class t { constructor(n, r) { this.tokenService = n, this.headerName = r } intercept(n, r) { const i = n.url.toLowerCase(); if ("GET" === n.method || "HEAD" === n.method || i.startsWith("http://") || i.startsWith("https://")) return r.handle(n); const s = this.tokenService.getToken(); return null !== s && !n.headers.has(this.headerName) && (n = n.clone({ headers: n.headers.set(this.headerName, s) })), r.handle(n) } } return t.\u0275fac = function (n) { return new (n || t)(C(VE), C(Rf)) }, t.\u0275prov = F({ token: t, factory: t.\u0275fac }), t })(), kk = (() => { class t { constructor(n, r) { this.backend = n, this.injector = r, this.chain = null } handle(n) { if (null === this.chain) { const r = this.injector.get(jE, []); this.chain = r.reduceRight((i, s) => new LE(i, s), this.backend) } return this.chain.handle(n) } } return t.\u0275fac = function (n) { return new (n || t)(C(AE), C(tt)) }, t.\u0275prov = F({ token: t, factory: t.\u0275fac }), t })(), Lk = (() => { class t { static disable() { return { ngModule: t, providers: [{ provide: Of, useClass: Nk }] } } static withOptions(n = {}) { return { ngModule: t, providers: [n.cookieName ? { provide: Af, useValue: n.cookieName } : [], n.headerName ? { provide: Rf, useValue: n.headerName } : []] } } } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275mod = st({ type: t }), t.\u0275inj = Xe({ providers: [Of, { provide: jE, useExisting: Of, multi: !0 }, { provide: VE, useClass: Pk }, { provide: Af, useValue: "XSRF-TOKEN" }, { provide: Rf, useValue: "X-XSRF-TOKEN" }] }), t })(), jk = (() => { class t { } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275mod = st({ type: t }), t.\u0275inj = Xe({ providers: [kE, { provide: IE, useClass: kk }, BE, { provide: AE, useExisting: BE }], imports: [[Lk.withOptions({ cookieName: "XSRF-TOKEN", headerName: "X-XSRF-TOKEN" })]] }), t })(), Bk = (() => { class t { constructor(n) { this.http = n, this.apiUrl = "http://localhost:3000" } getStages() { return this.http.get(`${this.apiUrl}/stages`) } } return t.\u0275fac = function (n) { return new (n || t)(C(kE)) }, t.\u0275prov = F({ token: t, factory: t.\u0275fac, providedIn: "root" }), t })(), Vk = (() => { class t { constructor(n) { this.router = n, this.stageBanned = new xe, this.stageUnbanned = new xe, this.isBanned = !1 } ngOnInit() { } onClick() { this.isBanned = !this.isBanned, this.isBanned ? this.stageBanned.emit(this.stage) : this.stageUnbanned.emit(this.stage) } } return t.\u0275fac = function (n) { return new (n || t)(S(Ye)) }, t.\u0275cmp = xt({ type: t, selectors: [["app-stage-card"]], inputs: { stage: "stage" }, outputs: { stageBanned: "stageBanned", stageUnbanned: "stageUnbanned" }, decls: 7, vars: 7, consts: [[1, "stage-card", 3, "click"], [3, "src", "alt"]], template: function (n, r) { 1 & n && (Oe(0, "div", 0), Vn("click", function () { return r.onClick() }), Oe(1, "mat-card")(2, "mat-card-title")(3, "p"), Un(4), Ne()(), Oe(5, "mat-card-content"), Bn(6, "img", 1), Ne()()()), 2 & n && (wt(4), hs(r.stage.name), wt(2), $o("banned", r.isBanned)("unbanned", !r.isBanned), Ho("src", "", r.stage.imagePath, " ", Oo), fc("alt", r.stage.name)) }, directives: [SE, TE, ME], styles: [".mat-card[_ngcontent-%COMP%]{background-color:#f2f2f2;padding:10px;border-radius:5px;width:25vw;min-height:15vh;text-align:center;img {width: 90%; height: 90%;}}.mat-card-header[_ngcontent-%COMP%]{font-size:20px;color:#333}.banned[_ngcontent-%COMP%]{filter:grayscale(100%)}.unbanned[_ngcontent-%COMP%]{filter:none}"] }), t })(); function Uk(t, e) { if (1 & t) { const n = uc(); us(0), Oe(1, "app-stage-card", 3), Vn("stageBanned", function (i) { return ki(n), ds().handleStageBanned(i) })("stageUnbanned", function (i) { return ki(n), ds().handleStageUnbanned(i) }), Ne(), cs() } if (2 & t) { const n = e.$implicit; wt(1), yn("stage", n) } } function Hk(t, e) { if (1 & t) { const n = uc(); us(0), Oe(1, "app-stage-card", 3), Vn("stageBanned", function (i) { return ki(n), ds().handleStageBanned(i) })("stageUnbanned", function (i) { return ki(n), ds().handleStageUnbanned(i) }), Ne(), cs() } if (2 & t) { const n = e.$implicit; wt(1), yn("stage", n) } } const $k = [{ path: "", component: wk }, { path: "stage-list-bans", component: (() => { class t { constructor(n, r) { this.dbService = n, this.cd = r, this.starterStages = [], this.counterpickStages = [], this.bannedList = [] } ngOnInit() { this.dbService.getStages().subscribe(n => { this.starterStages = n.filter(r => !1 === r.isCounterpick), this.counterpickStages = n.filter(r => !0 === r.isCounterpick) }) } handleStageBanned(n) { this.bannedList.push(n) } handleStageUnbanned(n) { n.isBanned = !1, this.bannedList = this.bannedList.filter(r => r.id !== n.id) } } return t.\u0275fac = function (n) { return new (n || t)(S(Bk), S(ra)) }, t.\u0275cmp = xt({ type: t, selectors: [["app-stage-list-bans"]], decls: 10, vars: 2, consts: [[1, "stage-list__container"], [1, "stage-list__header"], [4, "ngFor", "ngForOf"], [3, "stage", "stageBanned", "stageUnbanned"]], template: function (n, r) { 1 & n && (Oe(0, "div", 0)(1, "div", 1)(2, "h2"), Un(3, "Starters"), Ne()(), nc(4, Uk, 2, 1, "ng-container", 2), Ne(), Oe(5, "div", 0)(6, "div", 1)(7, "h2"), Un(8, "Counterpicks"), Ne()(), nc(9, Hk, 2, 1, "ng-container", 2), Ne()), 2 & n && (wt(4), yn("ngForOf", r.starterStages), wt(5), yn("ngForOf", r.counterpickStages)) }, directives: [Z_, Vk], styles: [".stage-list__container[_ngcontent-%COMP%]{display:flex;flex-wrap:wrap;justify-content:center;align-items:center;gap:8px;margin-top:16px}.stage-list__header[_ngcontent-%COMP%]{font-size:20px;color:#333;width:100%;text-align:center}.stage-list__stage[_ngcontent-%COMP%]{min-height:15vh;text-align:center}"] }), t })() }, { path: "power-rankings", component: (() => { class t { constructor() { } ngOnInit() { } } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275cmp = xt({ type: t, selectors: [["app-power-rankings"]], decls: 2, vars: 0, template: function (n, r) { 1 & n && (Oe(0, "p"), Un(1, "power-rankings works!"), Ne()) }, styles: [""] }), t })() }, { path: "community", component: (() => { class t { constructor() { } ngOnInit() { } } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275cmp = xt({ type: t, selectors: [["app-community"]], decls: 2, vars: 0, template: function (n, r) { 1 & n && (Oe(0, "p"), Un(1, "community works!"), Ne()) }, styles: [""] }), t })() }]; let zk = (() => { class t { } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275mod = st({ type: t }), t.\u0275inj = Xe({ imports: [[ED.forRoot($k)], ED] }), t })(), qk = (() => { class t { constructor() { this.title = "cape-smash" } } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275cmp = xt({ type: t, selectors: [["app-root"]], decls: 1, vars: 0, template: function (n, r) { 1 & n && Bn(0, "router-outlet") }, directives: [jd], styles: [""] }), t })(), Gk = (() => { class t { } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275mod = st({ type: t, bootstrap: [qk] }), t.\u0275inj = Xe({ providers: [], imports: [[pv, zk, G1, Ck, jk]] }), t })(); (function YA() { M_ = !1 })(), hN().bootstrapModule(Gk).catch(t => console.error(t)) } }, ie => { ie(ie.s = 644) }]);
